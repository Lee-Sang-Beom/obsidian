
#### 1. BOM(Browser Object Model)

- 모든 서비스는 웹 브라우저를 바탕으로 실행되기 때문에, 웹 서비스 개발은 브라우저와 밀접한 관련이 있다.
	- 이 브라우저와 관련된 객체 집합이 **BOM(브라우저 객체 모델)** 이다.
	- BOM을 이용해서, 브라우저와 관련된 기능을 구성할 수 있다.

- 아래에서 다룰 **DOM은** BOM 중 하나이며, 이 BOM의 최상위객체는 **window**객체이다.
	- window객체는 모든 객체가 소속된 객체이고, 전역 객체이면서 창이나 프레임을 의미한다
	- 아래와 같은 종류가 있다.
		1. `window.screen`: 사용자 환경의 디스플레이 객체
		2. `window.location`: 현재 페이지의 url을 다루는 객체
		3. `window.navigator`: 웹 브라우저 및 브라우저 환경 정보 객체
		4. `window.history`: 현재 브라우저가 접근해왔던 `URL History`(기록)
   
- 참고로, 브라우저에서 제공하는 이 모든 기능을 통틀어 **Web API**라고 한다. Web API는 자바스크립트의 기능은 아니지만 자바스크립트 등에 의해 제어될 수 있도록 브라우저에서 제공하고 있다.


#### 2. DOM(Document Object Model)

- 사용자가 웹 사이트에 접속하면, 웹 브라우저는 HTML 문서를 읽어들이고 해석한다.
	- 이 브라우저가 HTML코드를 해석하는 과정을 **파싱**이라 부른다.

- 이 파싱 작업이 완료되면 화면을 통해 사용자에게 해석된 결과물을 보여준다.
	- 해석한 HTML 코드를 화면에 보여주는 과정을 **렌더링**이라고 부르고, 렌더링 결과로 해석된 결과물에는 DOM이 존재한다.

	- 좀 더 자세히 말하자면, 브라우저는 HTML 코드를 해석하여 HTML 요소들을 **아래 이미지**처럼 트리 형태로 구조화하여 표현하는 웹 문서를 생성한다. 이 트리 전체를 **DOM**이라 하며, 브라우저는 DOM을 통해 화면에 웹 콘텐츠들을 렌더링하게 된다. [(이미지 출처 - 막블로그)](https://otep.tistory.com/34)
		- `HTML 코드 해석 -> HTML 요소를 트리구조로 표현한 DOM 생성 -> DOM 기반 웹 콘텐츠 렌더링`
![[DOM.png]]

- **DOM**은 `HTML/XML` 문서의 프로그래밍 `interface`라고 정의되고 있다. 즉, 문서와 상호작용할 수 있는 API라고 이해할 수 있는 것이다.
	- DOM은 **문서의 구조화된 표현을 제공**하며 프로그래밍 언어가 `XML/HTML`로 작성된 문서 구조에 접근할 수 있는 방법을 제공한다. 즉, 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다는 뜻이다.
		- 문서 객체란, `<html>`이나 `<body>` 같은 `HTML 태그`들을 자바스크립트가 이용할 수 있는 **객체**로 만든 것
		- DOM은 `HTML/XML`문서를 자바스크립트로 접근 가능한 **객체**의 집합 형태로 만든 것이라고도 이해할 수 있다. 
	

	- DOM을 구성하는 트리의 요소 하나하나를 **노드(Node)** 라고 부른다.
	- DOM은 `window.document`객체이다. 
		- 즉, DOM은 window객체의 하위 객체가 된다.

- 개발자들은 자바스크립트와 같은 **스크립트 언어**를 이용해 DOM을 수정하고 웹 페이지 요소, css 등을 제어할 수 있다.
	- 이렇게 할 수 있는 이유는, 웹 콘텐츠(HTML)요소를 제어 및 조작할 수 있는 **DOM API**라는 것이 제공되고 있기 때문이다.


#### 3. CRP(Critical Rendering Path)

- **CRP**란, 웹 브라우저가 원본 HTML문서를 읽어들인 후, 스타일을 입히고 대화형 페이지로 만들어 뷰포트(Viewport)에 표시하기까지의 과정을 의미한다.

- 대략적인 단계는 아래와 같다.
	1. **파싱**: 브라우저의 렌더링 엔진은 서버로부터 받은 HTML, CSS파일을 해석하는 파싱 과정을 거친다.
	2. **DOM 트리 구축**: 브라우저의 렌더링 엔진은 HTML 문서를 파싱하여, **DOM 트리**를 만든다.
		- **DOM(Document Object Model)** : HTML 요소의 구조화된 표현을 제공하며, 문서 상호작용을 돕는 방법 제공
	
	3. **CSSOM 트리 구축**: 브라우저의 렌더링 엔진은 `<style>` 태그를 만나게 되면, HTML 파싱을 멈추고 CSS파싱 작업을 시작하여 **CSSOM 트리**를 구축한다.
		- **CSSOM(Cascading Style Sheets Object Model)** : HTML 요소들과 연관된 스타일 정보의 구조화된 표현 제공
	
	4. **자바스크립트 실행**
		- 이 과정은 DOM 트리를 구성하는 과정 사이에 일어날 수도 있다.
		- 만약, HTML 파싱 중 자바스크립트를 의미하는 `<script>` 태그나 외부 스크립트 참조 구문을 만나게 되면, DOM 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘겨 스크립트를 실행한다.
		- 그리고, 스크립트 실행이 끝나면 다시 DOM 트리를 그리기 시작한다.
	
	5. **렌더 트리 구축**: DOM트리와 CSSOM 트리를 결합해 렌더 트리를 형성한다.
		- 렌더 트리는 웹 페이지에 표시될 HTML, 스타일 요소로 구성되는 트리이다.
		- 브라우저는 렌더 트리를 생성하기 위해 **DOM, CSSOM** 두 개의 트리를 필요로 한다.
	
	6. **레이아웃 생성**: 렌더 트리가 형성되면, 디바이스의 뷰포트 내에서 노드들의 정확한 위치와 크기를 계산하는 **레이아웃** 단계를 거친다.
	
	7. **페인트(Paint)**
		- 마지막으로, 렌더링 엔진은 페인트 이벤트를 발생시킨다.
		- 해당 단계에서는, 렌더 트리를 탐색하며 레이아웃 단계를 거쳐 알아낸 구성 노드 정보를 이용해, 노드들을 화면에 표시한다.


#### 4. DOM의 필요성

- 그렇다면 DOM은 대체 왜 쓰이는 것일까?
	- HTML코드는 정적인 텍스트이므로, 웹 화면이 사용자와 동적으로 상호작용을 하기 위해서 DOM이 필요하다.

- 앞서 자바스크립트를 활용해 문서 구조에 접근할 수 있고, 상호작용할 수 있다고 말했다.
	- 즉, 문서 내의 각 요소들에 대해 자바스크립트를 활용해 여러 작업을 시도할 수 있는데, 이는 **DOM이 해당 수정 및 제어 작업을 가능하도록 문서의 구조화된 표현을 제공**하고 있기 때문에 가능하다는 것이다.

- 아래는 DOM이 **언제 활용**될 수 있는지를 정리한 것이다.
	1. 뷰포트(Viewport) 에 무엇을 렌더링할지 결정할 때
	2. 자바스크립트로 새로운 HTML 요소나 속성을 추가/제거할 때
	3. 자바스크립트로 HTML 문서의 HTML 요소/속성을 변경할 때
	4. 자바스크립트로 HTML 문서의 CSS 스타일 요소를 변경할 때
	5. 자바스크립트로 HTML 문서에 새로운 HTML 이벤트를 추가할 때
	6. 자바스크립트로 HTML 문서에 작성된 HTML 이벤트에 대해 반응할 때


#### 5. Virtual DOM의 개념

- 지금까지, Virtual DOM(가상 DOM)에 대한 개념을 이해하기 위해 DOM이 무엇인지 알아보았다. 그럼 지금부터는 Virtual DOM이 무엇인지 알아보도록 하자.

- 웹 페이지의 **특정 요소의 색상을 변경해야 한다**는 상황이 있다고 가정해보자.
	- 기존 DOM에서는 해당 요소를 찾고 색상을 변경한 후, 그 변경 사항을 적용하기 위해 해당 요소부터 하위 요소까지 브라우저가 화면을 다시 그리는데 굉장히 많은 비용이 발생한다.
	- 특히, **리플로우(Reflow)** 및 **리페인트(Repaint)** 비용이 많이 발생한다.

> [!note] 리플로우(Reflow)
> - 즉, 생성된 DOM 요소의 레이아웃 수치(너비, 높이, 위치 등) 변경 시 영향을 받은 모든 노드의 위치를 다시 계산하는 과정을 의미한다.
> - **레이아웃 단계**를 다시 수행하는 것으로 생각할 수 있다.
> - 예를 들어, 요소의 크기나 위치를 변경하면 리플로우가 발생한다.

> [!note] 리페인트(Repaint)
> - 요소의 색상이나 테두리 등의 외양이 변경되면, 브라우저는 해당 요소를 다시 그린다. 이 과정을 리페인트라고 한다.
> - 노드의 위치를 재계산하는 리플로우가 발생한다면, 필연적으로 변경된 요소를 실제로 화면에 그려주는 리페인트 작업이 실행된다고 볼 수 있다.

- React는 Virtual DOM이라는 것을 이용해, 실제 DOM을 조작하는 일을 빠르게 만들어준다. 


#### 6. Virtual DOM의 동작

> [이미지 출처: 별코딩님의 React 가상돔](https://www.youtube.com/watch?v=gc-kXt0tjTM&t=57s)

![[diffing과 reconciliation.png]]

1. React는 **렌더링이 발생될 상황**에 놓일 때마다, 실제 브라우저 화면에 그려지기 이전에 새로운 화면에 들어갈 내용이 담긴 Virtual DOM을 생성한다.
	- Virtual DOM은 실제 DOM의 복사본으로, JavaScript 객체 형태로 메모리 내에 존재한다.
	- React는 항상 2가지 Virtual DOM 객체를 가지고 있다.
		- 1. **렌더링 이전의 화면 구조**를 가지는 Virtual DOM 객체
		- 2. **렌더링 이후의 화면 구조**를 가지는 Virtual DOM 객체

2. 렌더링 이전의 화면 구조를 가지는 Virtual DOM과 업데이트 이후의 화면 구조를 가지는 Vitrual DOM을 비교하여, 정확히 어느 `element`들이 변했는지를 찾아낸다.
	- 이러한 과정을 **diffing**이라고 하며, 정확히 어떤 `element`가 변경했는지 굉장히 빠르게 찾을 수 있도록 한다.

> [!note] **재조정(reconciliation)**
> - 이전 Virtual DOM Tree와 새로운 Virtual DOM Tree를 비교하고, Root 노드에서 시작하여 이전 노드와 새로운 노드를 비교한다.
> - 만약, 두 노드가 다른 유형이면 새 노드를 생성하여 기존 노드를 대체한다.
> - 만약, 두 노드가 같은 유형이면 속성을 비교해서 변경된 것이 있는지 확인하고 변경된 속성이 없으면 그대로 사용하고 있으면 속성을 업데이트한다.
> -  자식노드에도 재귀적으로 비교하는 과정을 거친다.
> - 이후, React는 변경된 `element`부분만 실제 DOM(실제 브라우저 화면)에 **한번에** 적용시킨다.

3. 재조정(Reconciliation)을 통해 변경 사항이 파악되면, 해당 변경 사항만 실제 DOM에 반영하여 업데이트한다.
	- 이런 방식으로 전체 DOM 트리를 재구축하지 않고, 필요한 부분만 빠르게 업데이트할 수 있다.
	- 재조정(Reconciliation)과정이 굉장히 효율적인 이유는, **React에서 여러 상태 업데이트를 한 번에 수행**하는 **Batch Update** 메커니즘 덕분이다.  

  > [!note] **React Batch Update**
> - **Batching**이란, React가 더 나은 성능 개선을 위해. 여러 개의 `state` 업데이트를 한 번의 리렌더링으로 묶어 진행하는 것을 말한다.
> - 여기서는, 변경된 모든 `element`를 실제 DOM에 한 번에 적용시킨다고 이해하고 넘어가자.
> 	- `element`가 변경될 때마다, 실제 DOM에 반복해서 적용하는 것 보다는 바뀐 내용을 한 번에 적용시키는 게 성능 상 이점이 있다는 의미이다.
> 	- DOM 조작에 있어 가장 비용이 많이 드는 작업은 **변경사항을 화면에 그려주는 작업**이기 때문이다.
> - 이에 대한 내용은 React의 `useState hook`동작 방식을 보면 보다 확실히 이해할 수 있다.
> 	- [[useState]]

- 이렇게 **Virtual DOM** 은 실제 DOM을 직접 조작하는 대신, 간접적으로 조작하면서 **렌더링 성능을 향상**시키는 역할을 한다.

> [이미지 출처: 별코딩님의 React 가상돔](https://www.youtube.com/watch?v=gc-kXt0tjTM&t=57s)

![[가상 DOM(별코딩).png]]
