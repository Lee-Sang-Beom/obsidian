
- 코드의 재사용/유지보수를 위해 파일을 분리한 것을 **모듈**이라고 한다. 
	- 자주 사용하는 코드는 모듈로 분리하는 것이 좋다는 것 정도는 알고 있을 수 있다.
	- 하지만, 개발 편의성을 위해 모듈을 너무 많이 만들면 어떻게 될까?

- **웹 애플리케이션을 만들고,** 사용자가 개발된 웹 사이트에 접속할 때 내부적으로 아래와 같은 과정이 발생한다.
	1. 웹 애플리케이션 완성 시, 웹 서버에 HTML, CSS, JavaScript 파일을 배포한다.
	2. 사용자가 브라우저를 통해 웹 사이트에 접근하면, 브라우저는 사용자에게 웹 사이트를 보여주기 위해 웹 서버에 HTML, CSS, JavaScript 등의 리소스를 요청한다.
	3. 웹 서버는 리소스를 포함해 응답한다. 이 과정이 끝나면 렌더링 이후, 비로소 사용자는 웹 사이트를 볼 수 있게 된다.

- **그런데 만약 모듈이 너무 많아지면,** 아래와 같은 문제가 발생하게 된다.
	- 모듈이 많으면 그만큼 서버에 요청하는 HTTP 통신 횟수가 많아진다.
	- 그에 따라, 페이지 로딩시간과 네트워크 비용이 증가한다.

#### 1. Webpack

> [이미지 출처: Khaydarov Murod 포스트](https://codex.so/webpack-tutorial)
![[webpack.jpg]]
- 위의 문제를 해결하기 위한 하나의 방법으로, 서버로 요청하는 HTTP 통신 횟수가 감소되도록 개발할 때는 모듈로 나눠 개발하고 웹 서버에 배포할 때는 하나의 파일로 묶어 배포하는 방법을 생각할 수 있다.
	- 여기서, 여러 모듈을 하나로 묶는 작업을 **번들(Bundle)** 이라고 하고, 묶어주는 도구를 **모듈 번들러(Module Bundler)** 라고 한다.
		- 모듈 번들러가 없으면 수동으로 파일을 결합하거나, 수많은 `<script>`태그를 사용하여 자바 스크립트를 HTML로 로드해야 한다.
	- Webpack은 이 모듈 번들러의 하나이다.

- **즉, Webpack은 여러 파일을 하나의 파일로 묶는 모듈 번들러 중 하나라고 정리할 수 있다.**
	- 모듈 번들러는 프론트엔드 측에서 서버로 HTTP 요청 시, 요청 개수를 줄여줌으로써 **웹 페이지 성능을 향상**시키고, 공백 등을 없앰으로써 **리소스**를 최적화시켜준다.
	- 참고: [WEBPACK Handbook](https://joshua1988.github.io/webpack-guide/)


#### 2. Babel

- Babel이 탄생하게 된 이유는 **크로스 브라우징**과 관련이 있다.
	- 크로스 브라우징은 HTML5, CSS3, Javascript 작성 시, W3C 웹 규격을 준수하며 개발을 진행함으로써 **다양한 브라우저 및 기기 등에서 개발된 웹 사이트가 의도한 대로 보여지고 작동될 수 있도록 하는** 기법이다.
	- 만약 일부 최신 브라우저에만 동작하는 기능을 다른 브라우저에 구현해야 하는 경우가 발생하면, 그 기능을 단순화하거나 생략해야 하는 일이 발생할 수 있다.

- 크로스 브라우징 작업이 필요한 이유는 브라우저마다 **렌더링 엔진**이 다르며, 그로 인한 아래의 문제가 발생하기 때문이다.
	- 브라우저의 렌더링 엔진마다 작동하지 않는 HTML5, CSS, JavaScript 코드가 존재할 수도 있다.
	- 브라우저의 자체 CSS가 존재할 수 있다.
	- 브라우저마다 예상치 못한 버그가 존재할 수 있다. 

![[babel.png]]
- 이 이슈를 해결하기 위해 생겨난 Tool이 **Babel(바벨)** 이다.
	- Babel은 ES6+ 버전의 자바스크립트 코드를 하위버전(ES5)으로 변환함으로써, 최신버전의 자바스크립트가 지원되지 않는 다른 브라우저에서도 동작할 수 있도록 하는 자바스크립트 컴파일러이다.

- Babel의 처리 단계는 크게 3단계로 나뉜다.
	 1. **STEP 1. 파싱**
		- 코드를 읽고 **AST**(추상구문트리)로 변환하는 과정
		- Babel은 자바스크립트 코드를 받아서 AST를 만들고, **만들어진 AST를 활용하여 새로운 자바스크립트 코드를 출력**한다.
		- 여기서, AST는 **프로그래밍 언어 문법에 따라 소스코드의 구조를 나타내는 계층적 프로그램 표현**을 의미한다.

	2. **STEP 2. 변환**
		- 적용된 **플러그인**을 통해 AST를 탐색하고 변경하는 과정
		- AST를 변환하는 단계는 사실 Babel의 플러그인이 담당한다. 플러그인은 코드를 어떻게 변환할지에 대한 규칙을 정의한다.
		- 여기서, 플러그인의 묶음을 프리셋(preset)이라 부른다. 프리셋을 설정하여 필요한 플러그인들을 목적에 따라 세트로 묶어서 적용하기도 한다.
			- 현재 바벨은 `env` 하나로 합쳐서 편리하게 사용할 수 있다. 대표적인 프리셋은 ES6+로 변환하는 `preset-env`가 있다.

	 3. **STEP 3. 출력**
		- 수정된 AST에서 새로운 코드를 생성하고, 변환된 결과물을 출력하는 과정

> [!note] preset-env
> - **Babel은 그 자체만 설치하고 실행**하게 되면, 코드는 아무것도 변하지 않는다. 왜냐하면, Babel은 preset과 플러그인을 추가하지 않으면 아무것도 하지 않기 때문이다.
> - Babel이 무언가를 변경시키게끔 하려면, 변환을 담당하는 플러그인을 따로 설치해 주어야 한다.
> 	- 예를 들어, 화살표 함수를 컴파일하는 과정이 필요하다면, 화살표 함수의 변환을 담당하는 플러그인을 npm 패키저로 설치해야 하는 것이다.
> - 하지만, **매번 ES6 버전 이상의 기능을 사용**하고 싶다면, 매번 npm으로 관련 플러그인을 설치해야 한다. 
> - 그래서 **babel foundation**이라는 곳에서는 플러그인들을 모아놓은 번들을 포함한 **preset**이라는 것을 만들었다.
> - preset은 플러그인들을 미리 모아놓은 파일으로, preset 설치 및 설정을 수행하면 모든 ES6+ 버전의 기능을 컴파일할 수 있는 플러그인들이 자동적으로 설치된다.


#### 3.Polyfill

- 하지만, Babel만으로는 모든 ES6+ 코드를 변환할 수 없다.
	- 어떤 ES6+ 문법은 정상적으로 Babel에 의해 컴파일되지만, 어떤 문법은 컴파일되지 못하는데, 이 때 필요한 게 **Polyfill**이다.
	- MDN에서는 Polyfill를 아래와 같이 정의하고 있다.
		- `이전 브라우저에서 기본적으로 지원하지 않는 최신 기능을 제공하는 데 필요한 코드`

- 이쯤에서 Babel과 Polyfill의 차이에 대해 다시 정리하고 넘어가자.
	-  참고자료도 있다.

> [!note] 바벨(Babel)
> - 구 브라우저에서, 최신 자바스크립트 코드를 사용할 수 있도록 변환해주는 컴파일러(트랜스파일러)이다.
> - ES5에서 자바스크립트 문법이 아니었던 ES6+의 문법들을 구 브라우저에서 사용할 수 있도록 변환해준다.
> - **컴파일 시간(Compile-time)** 에 코드를 구 브라우저에서 사용가능하게 변환한다.
> - ES5 환경의 전역 객체에 존재하지 않는 **객체, 메서드, 함수** 등은 바벨이 컴파일해줄 수 없다.
> 	- 새로운 객체, 메서드, 함수 등이 아닌 아래와 같은 문법의 경우, 바벨이 컴파일 가능하다.
> 		- `const`, `let`
> 		- spread operator
> 		- arrow function `()=>{}`
> 		- class
> 		- destructuring

> [!note] 폴리필(Polyfill)
> - 브라우저가 이해할 수 없는 코드에 대하여, 이해할 수 있는 코드 소스를 제공한다.
> - 자바스크립트 문법으로 읽히지만, 정의되지 않은 객체/메소드/함수를 정의해준다.
> - Babel이 컴파일하지 못한 전역 객체/메소드/함수들을 브라우저에서 실행되는 시점인 **실행 시간(Run-time)** 에 변환해준다.
> - **ES5의 global namespace(window/전역 객체)에 존재하지 않는 것은 폴리필이 필요하다.**
> 	- 새로운 객체 (Promise, IntersectionObserver, Set, Map …)
> 	- 기존 객체의 새로운 메서드 (Array.prototype.includes, Object.entries …)
> 	- 새로운 함수 (fetch)

> [!note] 컴파일, 트랜스파일
> - 컴파일: 한 언어로 작성된 소스 코드를 다른 언어로 변환하는 작업 
> 	- C -> Assembly
> 	- Java -> Bytecode
> - 트랜스파일: 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 작업이다.
> 	- 보통 모듈 번들러에 트랜스파일러를 추가해서 사용하는 방식을 사용한다
> 	- ES6 -> ES5 (Babel)
> 	- JSX -> Javascript
> 	- Typescript -> JavaScript
> 	- sass / scss -> css

> [!note] 컴파일러, 트랜스파일러, 인터프리터
> - **컴파일러**: 고급 언어로 작성된 프로그램 **전체**를 목적 프로그램으로 번역한 후, 링킹 작업을 통해 컴퓨터에서 실행 가능한 실행 프로그램을 생성하는 번역기
> 	- C, C++ 등이 있다.
> 	- 컴파일러 언어: 컴파일 단계와 실행 단계가 분리된 언어
> 	
> - **트랜스파일러**: 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 도구
> 	- 트랜스파일러는 소스 코드를 분석하고 변환하는 과정을 거쳐 원본 코드와 동일한 동작을 하는 대상 언어 코드를 생성한다. (지원하지 않는 언어를 지원하는 다른 언어로 변환하기 위해서 필요하다.)
> 	- Typscript, Babel 등이 있다.
>
> - **인터프리터**: 고급 언어로 작성된 프로그램을 한 줄 단위로 번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 번역기
> 	- 작성한 코드를 한 줄씩 즉시 기계어로 번역하는 번역기
> 	- JavaScript, Python 등이 있다.
> 	- 인터프리터 언어: 컴파일 없이 소스코드를 바로 실행하는 언어

> [!note] 컴파일 시간, 런타임 시간?
> - 컴파일 타임(Compile Time) : 소스 파일이 실행 파일로 만들어지기까지의 시간
> - 런타임 시간(Run-time Time) : 실행 파일이 실행되어 종료되기까지의 시간
> - [참고](https://velog.io/@ericagong/CS-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%83%80%EC%9E%84%EC%9D%B4%EB%9E%80-%EB%9F%B0%ED%83%80%EC%9E%84%EC%9D%B4%EB%9E%80#:~:text=%ED%8C%8C%EC%9D%BC%20%EB%A1%9C%20%EB%B3%80%ED%99%98-,%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%ED%83%80%EC%9E%84%EA%B3%BC%20%EB%9F%B0%ED%83%80%EC%9E%84%EC%9D%98%20%EA%B5%AC%EB%B6%84,%EC%8B%9C%EA%B0%84%EC%9D%B4%20%EB%B0%94%EB%A1%9C%20%EB%9F%B0%ED%83%80%EC%9E%84%20%EC%9D%B4%EB%8B%A4.)
