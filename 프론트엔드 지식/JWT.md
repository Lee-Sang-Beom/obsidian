> [참고자료: 김츄의 개발일지](https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token)

#### 1. JWT 토큰이란?

- JWT(Json Web Token)는 JSON 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰이다.
- **JSON** 포맷을 이용하여 사용자에 대한 속성을 저장하는 **Claim** 기반의 Web 토큰으로, JWT는 필요한 정보를 자체적으로 지니는 **Self-Contained** 방식으로 정보를 안정성 있게 전달한다.


#### 2. JWT 프로세스

 >로그인 전
1. 사용자가 ID/PW 혹은 소셜 로그인을 이용하여 서버에 **로그인 요청**을 보낸다.
2. 서버는 **비밀키**를 사용하여, JSON 객체를 암호화한 JWT 토큰을 발급한다.
3. JWT를 `헤더`에 담아 클라이언트에 보낸다.

> 로그인 후
1. 클라이언트는 JWT를 **로컬**에 저장해놓는다.
2. API 호출을 할 때마다 header에 JWT를 포함하여 전달한다.
3. 서버는 header를 매번 확인하여 사용자가 신뢰할만한지 체크하고, 인증이 완료되면 API에 대한 응답을 보낸다.


#### 3. JWT 구조

- JWT는 아래의 요소들로 구성되어 있다.
	1. Header
	2. Payload
	3. Signature

- JSON으로 포맷된 각 부분은 **Base64**로 인코딩되어 표현되며, 각각의 구성 요소는 **.(점)** 으로 구분한다.

![[JWT structure.png]]

> **1️⃣ Header(헤더)**
- 토큰의 헤더는 **alg**, **typ**로 구성된다.
	- `alg`: 해싱 알고리즘으로, 서명(Signature) 및 토큰 검증에 사용된다.
		- *Signature*에서 사용하는 알고리즘은 대표적으로 `RS256`(공개키/개인키)와 `HS256`(비밀키(대칭키))가 있다.

	- `typ`: 토큰의 타입

> **2️⃣ Payload(페이로드)**
- 토큰의 Payload에는 토큰에서 사용할 정보의 조각들을 일컫는 **클레임(Claim)** 이 포함되어 있다.
	- 클레임은 **등록된 클레임(Registered Claim)**, **공개 클레임(Public Claim)**, **비공개 클레임(Private Claim)** 으로 나뉘어진다.
	- 클레임은 `key-value` 형태로 존재한다.

> [!note] 등록된 클레임(Registered Claim)
> - 토큰 정보를 표현하기 위하여 이미 정해진 종류의 데이터들이다. (사용 권장됨)
> 	- iss: 토큰 발급자(issuer)
> 	- sub: 토큰 제목(subject)으로, 유니크한 값을 사용한다. (주로 유저 이메일 사용)
> 	- aud: 토큰 대상자(audience)
> 	- exp: 토큰 만료시간(expiration)으로, NumbericDate 형식으로 되어 있어야 한다.
> 	- nbf: 토큰 활성날짜(not before)
> 	- iat: 토큰 발급시간(issued at)으로, 토믄 발급 이후의 경과 시간
> 	- jti: JWT 토큰 식별자(JWT ID)로, 중복 방지를 위하여 일회용 토큰(Access Token) 등에 사용된다.

> [!note] 공개 클레임(Public Claim)
> - 사용자 정의 클레임으로, 공개용 정보를 위해 사용된다.
> - 충돌 방지를 위하여, URI 포맷을 이용한다.

> [!note] 비공개 클레임(Private Claim)
> - 사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장한다.

> **3️⃣ Signature(서명)**
- 서명(Signature)은 **토큰을 인코딩**하거나 **유효성 검증**을 할 때 사용하는 고유한 암호화 코드이다.
	- Header(헤더)와 Payload(페이로드), 그리고 비밀 키를 기반으로 생성되며 **해당 토큰이 변조되지 않았음을 확인**하기 위한 메커니즘이다.

**※ 서명 생성 과정**
1. 헤더(Header)와 페이로드(Payload)의 값을 각각 **Base64**로 인코딩
2. 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 **해싱(Hashing)**
3. 해싱한 값을 다시 **Base64**로 인코딩하여 생성