
### 1. CSR
- CSR은 웹 애플리케이션의 페이지의 렌더링이 서버 측이 아니라, 브라우저 측에서 이루어지는 렌더링 방식입니다.
- 사용자가 웹 페이지를 요청하면 서버는 (최초 HTML 구조만 포함된) 빈 HTML 파일과 자바스크립트 다운로드가 가능한 링크를 브라우저에게 전달합니다. 그리고 브라우저는 자바스크립트 파일을 다운받고 실행하면서 DOM이 생성됩니다.
- 그리고 자바스크립트가 실행되면 API 요청 등을 활용해 필요한 데이터를 가져오며 동적으로 콘텐츠를 화면에 표시합니다.

- CSR은 초기 화면이 비어있어 UX 저하의 문제가 있으며, 초기화면 부재로 인한 robot의 접근이 어려워 SEO에서 아쉬움이 있습니다.

### 2. SSR
- SSR은 서버에서 웹 페이지 HTML가 미리 렌더링되어 클라이언트로 전달되는 방식입니다.
- 사용자가 웹 페이지를 요청하면, 서버는 요청한 페이지 내용에 대한 웹 페이지 HTML을 미리 렌더링합니다. (이 과정에서도 자바스크립트가 실행되는데, 페이지의 초기 HTML을 생성하기 위해서만 사용됩니다.)
- 그다음 완성된 HTML이 클라이언트로 전달되면 새로 렌더링할 필요없이 클라이언트는 HTML을 화면에 즉시 표시합니다. 이후 클라이언트 측에서 자바스크립트를 다운로드 받고, 자바스크립트 프레임워크가 실행되면 페이지 상호작용을 위한 자바스크립트 로직이 초기화되면서 상호작용 가능한 페이지가 구성되게 됩니다.

### 3. Hydration
- 전통적인 SSR방식과 현대 웹 프레임워크에서의 SSR방식은 차이가있는데 저는 제일 큰 차이가 Hydration이라고 봅니다.
	- 현대 SSR방식에서는 서버에서 렌더링된 HTML를 클라이언트에서 받아 즉시 표시하고, 이 HTML파일에 **클라이언트 측 자바스크립트**를 연결하여, **대화형 요소들**을 활성화시키는 과정을 거칩니다. 이게 hydration입니다.
	- Hydration이 있을때는 서버가 HTML파일을 렌더링해서 클라이언트로 전달할 때 자바스크립트 코드도 함께 전달합니다. 반면 없을 때는 자바스크립트 코드가 함께 전달되지 않기에, 클라이언트 측 페이지는 오직 정적인 상태로 존재합니다. (나중에 동적으로 바뀌는데 html을 바꿔야해서 지금들어온건 정적으로밖에 활용할수없는거임)
	- 이러한 차이 때문에 자바스크립트 로드 후 상호작용을 가능케 할 때, 차이점이 발생합니다. Hydration이 없을때는 정적이었던 HTML을 변경해서 동적기능을 추가했었다면, Hydration 사용 시 이미 서버에서 전달된 HTML이 변경될 필요없이 상호작용을 위한 이벤트리스너가 자동으로 연결되면서 상호작용이 가능해지게 됩니다.

### 4. SPA
- 브라우저 내부에서 동작하는 앱으로 정의됩니다. 하나의 페이지로 이루어진 애플리케이션이며, 하나의 HTML 파일을 기반으로 자바스크립트를 이용해서 동적으로 화면 컨텐츠를 바꾸는 방식을 사용합니다.
- SPA 방식은 맨 처음에만 서버로부터 HTML, CSS, JS 등의 리소스를 받아오고 그 다음부터는 기존 페이지의 내부를 수정하며 보여주는 특징이 있습니다. 따라서 변경 시 필요한 부분만 서버로부터 전달받기에 깜빡임 현상이 적고, 초기 로딩 이후에 성능상 MPA보다 유용합니다.
- 반면, 초기로딩이 느리며, SPA는 모든 것을 자바스크립트로 처리하기에, 초기 HTML 파일에는 대부분 해당 웹을 작동시키기 위한 자바스크립트 파일만 포함되고 나머지 컨텐츠는 텅 비어 있습니다. 따라서 웹 크롤러가 맨 처음 페이지에 접근했을 때 페이지 정보를 읽을 수 없어 SEO에 불리합니다.

### 5. MPA
- MPA는 화면마다 HTML이 존재합니다. 즉, 여러 페이지로 구성된 애플리케이션입니다.
- 사용자가 페이지를 요청할 때마다 서버에서는 렌더링된 정적 리소스 HTML, CSS, JS를 전달하고 클라이언트는 이를 다운로드합니다.
- 사용자가 보는 화면방식이 곧 웹 크롤러가 보는 방식과 같기에 SEO가 유리하고 첫 페이지 로딩시간이 SPA보다 빠릅니다.
- 하지만, SPA는 필요한부분만 변경하는 반면 MPA는 접근하는 페이지를 매번 요청해야합니다. 따라서 깜빡임 현상이 있습니다. 서버측도 매 페이지마다 정적 리소스를 전달해줘야하니 부하도 있고요.

### 6. RSC, RCC
- RSC는 Next.js v13 버전에서 추가된 개념으로 서버에서 렌더링되는 컴포넌트를, RCC는 클라이언트 측에서 렌더링되는 컴포넌트입니다.

- 사용자가 특정 웹사이트에 요청을 보내면 서버에서는 컴포넌트 트리를 root부터 직렬화된 JSON형태로 재구성합니다. 그리고 이 RSC가 그 대상인데, RSC는 서버에 의해 직렬화되어 stream 형태로 클라이언트에게 전달됩니다.(stream: 데이터를 연속적으로 처리하는 방식으로 청크단위 전송)
- 그리고 클라이언트에서는 이 데이터를 React 런타임에서 UI로 표시할 수있도록 해석하는 과정만 거치면 새로 렌더링 할 필요 없이 화면에 즉각 표시할 수 있습니다.

- 반면 RCC는 서버에서 렌더링되지 못하며, 직렬화를 우회한 채 placeholder로서 표시됩니다. 서버에서 렌더링된 HTML 내에 **클라이언트 컴포넌트가 자리 잡을 공간**을 미리 만들어두는 마커가 placeholder인데, 이 placeholder는 JavaScript가 로드된 후 해당 클라이언트 컴포넌트가 정상 동작되게끔 Hydration하기 위해 사용됩니다. 여튼 클라이언트에서는 해석하지 못한 RCC를 마저 해석(렌더링)합니다. 그리고 마저 해석된 결과물이 DOM에 반영되면 실제 화면에 보여지게됩니다.

- Next.js에서는 사용하는 SSR방식은 전통적인 SSR방식과 거리가 있습니다. 초기속도가 느리다는 CSR방식의 단점 보완을 위해, 서버에서 HTML파일을 SSR방식으로 빠르게 받아오면서 병렬적으로 자바스크립트 번들을 다운받아 미리 받아온 HTML파일이랑 바로 연결하면서 대화형 페이지로 만들어버리는 Hydration이 적용되어 있습니다.

- 여기에 RSC, RCC방식을 추가하면 큰 이점이 있습니다.
	- 첫번째로 RSC는 서버에서 이미 해석되어 직렬화된 JSON형태로 전달되며, 이 결과물은 HTML 스니펫 형태로 클라이언트에 전달됩니다. 클라이언트에서 해당 결과물은 UI형태로 변환한다음 그대로 표시하기만 하지 어떤 동적요소도 주입되지 않기때문에 자바스크립트를 로드한 후 Hydration의 대상이 되지 않습니다. 따라서 자바스크립트 번들 사이즈에 영향을 주지 않습니다.
	- Next.js v12버전까지 사용했던 getServerSideProps와 같은 함수는 서버에 접근해서 데이터를 얻기위해 페이지 맨 상단에서 제한적으로 사용해야했던 함수입니다. 하지만 RSC는 서버에서 실행되는 컴포넌트이기 때문에 굳이 이제 사용안해도 됩니다.
	- 그리고 RSC가 직렬화되어 JSON형태로 만들어진다음 stream 형태로 클라이언트에게 전달된다고 했습니다. 데이터가 stream 형태로 전달되면 클라이언트에서는 먼저 수신된 부분부터 반영하여 화면에 띄워줄 수 있는데 이 기술이 Streaming입니다.
	- 그리고 이와 함께 사용하면 좋은 기술 중 Suspense가 있는데 동적 컴포넌트가 로드될동안 대체 출력 컴포넌트를 출력할 수 있도록 하는 기술입니다. 즉, 모든 데이터를 기다릴 필요없이 먼저 출력해줄 수 있는 부분은 뷰에 반영해줄 수 있다는 뜻입니다.