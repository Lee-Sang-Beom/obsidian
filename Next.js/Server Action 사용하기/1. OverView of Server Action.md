
#### 1. 들어가기 전에

 - [Next.js14](https://nextjs.org/blog/next-14#nextjs-learn-course)버전에 대한 업데이트 내용을 보던 중 **server-action(stable)** 이라는 내용이 문득 눈에 띄었다. 
	 - 안정화되지 않았을 때에는 "오, 이런 게 나왔구나"라고만 하고 넘어갔기 때문에, 포스트를 작성하는 이 시점까지도 이게 뭔지 참 궁금했다.
 
 - 이 참에 사용해보면서 해당 기능에 대해 알아보고, 거기다 기록까지 해 두면 좋을 것 같아 포스트를 작성하게 되었다.

- 참고링크는 다음과 같다.
	- [공식 문서](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)


#### 2. Server Actions?

- Next.js의 공식문서에서는 ***Server Actions***에 대해 아래와 같이 소개하고 있다.

> - ***Server Actions***은 서버에서 실행되는 비동기 함수입니다. 
> - 이는 Next.js 애플리케이션에서 Form 제출과 데이터 변경을 다루는 데 사용될 수 있습니다.

- 필자는 개념을 보는 이 타이밍에 궁금한 것이 생겼다.
	- 서버에서 실행되는 비동기 함수가 어떻게 Form 제출 및 데이터 변경과 연관될 수 있는가?
	- 지금까지 사용자 입력 이벤트로 인해 저장되어야 하는 데이터는 ***react hooks in RCC***들로 관리를 해왔었기에, 적어도 나는 이 개념에 대해 **굉.장.히** 궁금했다.

- Next.js v13.4 이상에서 작동하며, stable 버전인 Next.js v14.0.0 이상이 아니라면 아래의 코드를 `next.config.js`에 추가해주어야 한다.
```js
module.exports = { experimental: { serverActions: true, }, };
```



#### 5. 예제: Forms 사용
 
- React는 HTML `<form>` 요소를 확장하여 Server Action을 action 속성으로 호출할 수 있게 한다.
	- Form에서 호출될 때 action은 자동으로 FormData객체를 받는데, 필드를 관리하기 위해 **React의 `useState hook`을 사용할 필요가 없으며, 대신 네이티브 FormData 메소드를 사용**하여 데이터를 추출할 수 있다.

```tsx
// Server Component
export default function Page() {
  // 함수안에 'use server' 를 작성해두면 그 함수 내용을 자동으로 서버 API로 만들어 준다.
  // 함수안에 있는 코드는 유저에게 노출되는 코드가 아니라 서버코드기 때문에, 거기서 맘대로 폼내용을 DB에 저장하거나 검사해도 되는 장점이 있다.
  async function createInvoice(formData: FormData) {
    "use server";

    const rawFormData = {
      title: formData.get("title"),
      body: formData.get("body"),
      userId: formData.get("userId"),
    };

    console.log("raw : ", rawFormData);

    // mutate data(데이터 업데이트)
    fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(rawFormData),
    })
      .then((response) => response.json())
      .then((json) => {
        console.log("jsonData is ", json);
      });

    // revalidate cache
  }

  return (
    // Form 전송 시, action 전달 함수 실행
    <form action={createInvoice}>
      <input type="text" name="title" />
      <input type="text" name="body" />
      <input type="text" name="userId" />
      <button type="submit">POST</button>
    </form>
  );
}

```


#### 6. 예제: 추가 인수 전달

- 자바스크립트의 `bind` 메소드를 사용하면, Server Action에 추가 인수를 전달할 수 있다.
```js
const boundFunction = someFunction.bind(thisArg, arg1, arg2, ...);
```

##### 6-1. `.bind()` 메소드

- `bind()` 메소드는 JavaScript의 내장된 메소드 중 하나로, 함수를 호출할 때 특정한 컨텍스트로 설정하고, 해당 함수에 인수를 전달할 때 사용된다.
	1. `someFunction`: 바인딩할 함수이다.
	2. `thisArg`: 함수 내부에서 `this` 키워드가 참조할 객체이다. 이는 바인딩된 함수가 호출될 때 함수 내부에서 `this`로 사용된다.
	3. `arg1`, `arg2`, `...`: 바인딩된 함수에 전달할 추가 인수

- `.bind()` 메소드를 사용하면 원본 함수를 호출하는 대신 새로운 함수를 생성한다.
	- 이 새로운 함수는 지정된 `this` 값으로 호출될 때 원본 함수의 복사본이며, 추가 인수가 바인딩된 함수에 전달된다.
	- 예시는 아래와 같다.

```js
function greet(name) {
  console.log(`Hello, ${name}!`);
}

const greetBob = greet.bind(null, 'Bob');
greetBob(); // 출력: Hello, Bob!
```
- 위의 예제는 `bind()` 메소드를 사용하여 `greet()` 함수에 'Bob'이라는 인수를 고정시켜 새로운 함수 `greetBob`을 생성하고 있다. 
	- 이렇게 생성된 `greetBob` 함수는 항상 'Bob'을 인수로 받아 호출된다.

#### 6-2. Server Action 예제

- 이제, `bind()` 메소드에 대해 알아봤으니, Server Action 예제를 살펴보자.

- 먼저, Server Action을 사용하지 않는 방법으로 아이디와 비밀번호로 로그인 화면을 만들어보았다.
	- `nextauth`를 함께 사용하면, AuthOption으로 지정한 방법대로 로그인한 사용자의 세션 정보를 불러올 수 있을 것이다.
```tsx
"use client";

import { signIn } from "next-auth/react";
import { useState } from "react";
export default function Login2({ to }: { to?: boolean }) {
  const [id, setId] = useState<string>("");
  const [pw, setPw] = useState<string>("");

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        padding: "5px",
        gap: "1rem",
      }}
    >
      <input
        value={id}
        style={{ width: "100%", height: "40px" }}
        onChange={(e) => {
          setId(e.currentTarget.value);
        }}
      />
      <input
        value={pw}
        style={{ width: "100%", height: "40px" }}
        onChange={(e) => {
          setPw(e.currentTarget.value);
        }}
      />

      <button
        style={{ width: "100px", height: "40px" }}
        onClick={() => {
          signIn("credentials", {
            userId: id,
            userPw: pw,
            redirect: false,
          }).then((res) => {
            window.location.href = "/";
          });
        }}
      >
        로그인
      </button>
    </div>
  );
}
```

- 서버 컴포넌트에서는, 로그인된 정보를 받아온 후, 클라이언트 컴포넌트로 `userId`를 전달한다.
	- nextauth에서는, 서버 컴포넌트 측에서 `getServerSession()` 메소드를 사용하면, Session 정보를 얻어올 수 있다.
```tsx
export const dynamic = "force-dynamic";

import { getServerSession } from "next-auth/next";
import ClientComponent from "./ClientComponent";
import { authOption } from "../api/auth/[...nextauth]/AuthOptions";

// Server Component
export default async function Page() {
  const session = await getServerSession(authOption);

  // 유저 정보 불러오기
  return (
    <ClientComponent
      userId={session && session.user ? session.user.userId : "null"}
    />
  );
}
```

- 클라이언트 컴포넌트에서는 Server Action 함수를 import하고, `<form>`태그를 추가해, 사용자 이벤트를 관리하고 있다.
```tsx
"use client";

import React from "react";
import { updateUser } from "../utils/action/actions";

const ClientComponent = ({ userId }: { userId: string | null }) => {
  if (!userId) {
    return null;
  }

  const updateUserWithId = updateUser.bind(null, userId);
  return (
    <form action={updateUserWithId}>
      <input type="text" name="userNm" />
      <input type="text" name="age" />
      <button type="submit">Update User</button>
    </form>
  );
};

export default ClientComponent;
```

- `actions.ts`파일에 따로 저장한 `updateUser()` 메소드는 아래와 같이 구성했다. 
	- 만약 ClientComponent에서 `action`이 실행되면, 해당 함수 내의 `console.log` 함수가 실행될 것이다.
```ts
"use server";

export async function updateUser(userId: string, formData: any) {
  console.log("userId : ", userId);
  console.log("formData userNm : ", formData.get("userNm"));
  console.log("formData age : ", formData.get("age"));
  
  // ...
}
```

- **결과는 아래와 같다.**
	1. 클라이언트 컴포넌트에서 구성한 Form의 입력
	![[serveraction 추가인수전달 클라이언트.png]]
	2. `updateUser()` 메소드 출력결과
	![[serveraction 추가인수전달.png]]
	
	- **formData** 뿐 아니라, **추가적으로 전달한 유저 ID** 또한 잘 전달되고 있다.


#### 7. 예제: Pending State

- React의 `useFormStatus hook`을 사용하면, Form이 제출되는 동안 보류 중인 상태를 표시할 수 있다.
	-  이 때, `useFormStatus`는 특정 `<form>`에 대한 상태를 반환하므로, **꼭** `<form>` 요소의 자식으로 정의되어야 한다.
	- 그리고 당연히, `useFormStatus`는 React `hook`이므로 클라이언트 컴포넌트에서 사용되어야 한다.

- 바로 위의 예제에서, **클라이언트 컴포넌트에 조금의 변경**을 가해보자.
```tsx
"use client";

import React from "react";
import { updateUser } from "../utils/action/actions";
import { SubmitButton } from "./SubmitButton";

const ClientComponent = ({ userId }: { userId: string | null }) => {
  if (!userId) {
    return null;
  }

  const updateUserWithId = updateUser.bind(null, userId);
  return (
    <form action={updateUserWithId}>
      <input type="text" name="userNm" />
      <input type="text" name="age" />
	  {/* 변경 */}
      <SubmitButton />
    </form>
  );
};

export default ClientComponent;
```

- 다음으로, `<SubmitButton />` 컴포넌트를 추가해야 한다. 
	- 아래 코드에서는, `useFormStatus hook`의 `pending`요소를 꺼내와, `<button/>`태그에 전달하고 있다.
	- 이를 통해, action으로 전달한 Server Action 메소드가 처리가 되었는지 여부를 확인할 수 있다.
```tsx
"use client";

import { useFormStatus } from "react-dom";

export function SubmitButton() {
  const { pending } = useFormStatus();
    console.log("pending: ", pending, " date is ", new Date());
  return (
    <button type="submit" disabled={pending}>
      Update
    </button>
  );
}
```

- 마지막으로, Server Action으로 지정한 메소드에 `for문`으로 의도적인 지연시간을 넣어줄 것이다.
	- 자바스크립트의 `for문`은 동기적인 형태를 띄기 때문에, 다음 코드는 `for문`의 동작이 완료되어야 수행될 것이다.
	- 그리고, `updateUser` 내부 동작이 실행될 동안에는 `pending === true`일 것이다.
```ts
"use server";

export async function updateUser(userId: string, formData: any) {
  console.log("isStart: ", new Date());

  for (let i = 0; i < 999999999; i++) {}
  
  console.log("userId : ", userId);
  console.log("formData userNm : ", formData.get("userNm"));
  console.log("formData age : ", formData.get("age"));

  console.log("isEnd: ", new Date());
  // ...

}
```

- 결과는 아래와 같다.
	1. 먼저, 아래와 같은 입력이 발생했다.
	![[serveraction pending 클라이언트 미클릭.png]]
	
	2. Update 버튼을 누르면, `updateUser()`메소드의 처리를 수행한다.
	![[serveraction pending 터미널.png]]
	
	3. `updateUser()`메소드가 실행되는 동안에는, `pending`이 `true`가 된다. 
	![[serveraction pending true.png]]
	
	4. 이 때, 사용자(클라이언트)는 화면에 표시된 버튼이 disabled 처리되는 것을 확인하게 된다.
	![[serveraction pending 클라이언트 클릭.png]]
	
	5. `updateUser()`메소드 수행이 종료되면, `pending`이 `false`가 된다.
	![[serveraction pending false.png]]


#### 8. 예제 : 