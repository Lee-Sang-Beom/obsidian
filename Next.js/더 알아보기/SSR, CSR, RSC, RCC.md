
#### 1. Next.js 의 RSC, RCC, SSR, CSR 알아보기

 > [2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)

- 위의 **포스트**에서는, Next.js의 RSC(React Server Component), RCC(React Client Component)의 동작과 이것들이 Next.js의 SSR과 어떻게 맞물리는지를 굉장히 알기 쉽게 설명하고 있다.

- 여기서는, 링크한 포스트에서 주의깊게 살펴보아야 할 내용을 요약하고, 잘 이해되지 않았던 내용을 다시금 정리하며 Next.js의 컴포넌트 동작에 대해 좀 더 자세히 알아가보고자 한다.


#### 2. RSC(React Server Component) vs RCC(React Client Component)

- RSC(React Server Component)란, 서버에서 렌더링되는 컴포넌트를 의미한다. RSC에서는, `async`, `await`을 사용하여 비동기 데이터를 가져와 렌더링하는 것이 가능하다.
	- 해당 개념이 등장하기 이전의 **Next.js**에서는, 서버에 접근해 데이터를 **Fetch**한 후 하위 컴포넌트에 데이터를 넘겨주기 위해서는 페이지 최상단에서 `getServerSidePros`함수를 사용하여 일일히 넘겨줘야 했다.
	- 하지만, **서버에서 동작하는 컴포넌트**라면? 서버에서 Fetch를 수행하기 때문에 굳이 `getServerSideProps`를 사용하지 않아도 되게 된다.

- 반면, RCC(React Client Component)는 클라이언트 측에서 렌더링되는 컴포넌트이며, Next.js v12까지 개발 시 사용했던 모든 컴포넌트이기도 하다. 아래의 동작을 관리할 수 있다.
	- **브라우저 API** 및 브라우저 전용 API에 의존하는 사용자 지정 `hook` 사용
	- `react hook` 과 관련된 상태(state) 및 수명 주기 효과 사용
	- 사용자 상호관리 및 Event listener의 관리

![[서버 컴포넌트와 클라이언트 컴포넌트.png]]


#### 3. RSC(React Server Component)의 동작 방식

- 그렇다면, RSC는 어떻게 렌더링 될까?
	- 사용자가 특정 웹사이트에 요청을 보내면, 서버는 **컴포넌트 트리를 `root`부터 직렬화된 JSON형태로 재구성하기 시작한다.**
	- [이미지 출처 - 2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)
![[직렬화 전 클라이언트 및 서버 컴포넌트.png]]
##### 3-1. 직렬화와 서버 컴포넌트(RSC)

- 여기서 **직렬화**란, 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일하거나 **다른 컴퓨터 환경에 저장**하고 **나중에 재구성할 수 있는 포맷으로 변환**하는 과정이다.
	- 즉, 특정 개체를 다른 컴퓨터 환경으로 전송 및 재구성할 수 있는 형태로 변경하는 과정이라고 정리할 수 있다. 
	- `JSON.stringify()`가 직렬화, `JSON.parse`가 역직렬화를 수행하는 함수이다.

- 직렬화 과정은 모든 서버 컴포넌트를 실행한 다음, 컴포넌트 트리가 **JSON 객체 형태의 트리로 재구성될 때까지 진행**된다.

- 이 때, 함수는 직렬화하지 못하는 객체로 분류된다. 이는 함수가 **실행코드 및 실행 컨텍스트를 모두 포함**하는 개념이기 때문이다.
	- 함수는 단순한 데이터가 아니라, 프로그램이나 스크립트의 일부로서 동작하며, 자바스크립트 엔진에게 **실행되어야 하는 코드**이다.
		- 함수가 하는 일에 대한 **설명**이나 함수의 **설정 정보를 저장**할 수는 있으나, 그 함수를 완전히 저장하고 나중에 불러와 실행할 수 있다는 것은 일반적으로 어렵고 복잡한 과정이다.
		
	- 왜냐하면, 함수를 직렬화하려면 자신이 선언된 스코프에 대한 참조를 유지하고, 해당 시점의 외부 변수에 대한 참조를 기억하여야 하기 때문이다. 
		- 이는 함수의 직렬화를 진행하려면, 함수의 **내용** 뿐 아니라 **실행 컨텍스트**와 함께 **스코프, 클로저와 같은 모든 종속성**을 저장해야 한다는 의미이다. 일반적으로 **굉장히 복잡하고, 비효율적**인 일이라고 한다.
		- 때문에, 함수를 직렬화할 수 없다는 것은 일반적으로 프로그래밍 언어 및 환경에 대한 제약사항으로 분류된다. 몇몇 특정한 상황에서는 함수를 직렬화할 수 있도록 하는 라이브러리나 도구가 있을 수 있지만, 이는 일반적인 상황에서는 드물고, 일반적으로 권장되지 않는다고 한다.

##### 3-2. 직렬화와 클라이언트 컴포넌트(RCC)

- 앞서, 사용자가 특정 웹사이트에 요청을 보내면, 서버는 **컴포넌트 트리를 `root`부터 직렬화된 JSON형태로 재구성하기 시작한다**고 언급했다.

- 이 직렬화 과정은 모든 컴포넌트에 대해 실행되는 것이 아니라, **RCC**인 경우 건너뛰게 된다.
	- 왜냐하면, RCC는 **클라이언트가 JS 번들을 다운로드 받은 후 해석하게 되는 위치**이며, 곧 **함수**이기 때문이다.
	- 대신 **RCC**의 경우, 직접 직렬화 과정을 거치면서 해석하는 것이 아니라 `module reference` 라고 하는 새로운 타입을 적용하여, 해당 컴포넌트의 경로를 명시함으로써 직렬화를 우회하게 된다. (RCC 영역이라고 `placeholder` 배치)

- 직렬화 작업이 끝나면, 컴포넌트 트리는 JSON 트리로 생성된다.
	- [이미지 출처 - 2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)
![[사용 이미지/Next.js/더 알아보기/직렬화 후 클라이언트 및 서버 컴포넌트.png]]

- 직렬화 작업 결과물(JSON Tree)은 이후, `Stream` 형태로 클라이언트가 전달받게 된다
	- 클라이언트는 함께 다운로드 한 `JS Bundle`을 참조하여 `module reference` 타입이 등장할 때마다 RCC를 렌더링한다.
	- 서버 측에서 직렬화하며 해석하지 못한 RCC를 마저 해석(렌더링)한 후, 결과가 DOM에 반영되면 실제 화면에 보여지게 된다.
		- 이 때 비로소, `placeholder`로서 표시만 되었던 클라이언트 컴포넌트가 다시 구성요소로서 완전히 전환되는 것이다.
![[직렬화 후 해석된 클라이언트 및 서버 컴포넌트.png]]


#### 4. RSC의 제약사항

- 위의 과정을 토대로, RSC와 RCC 사용 시, 몇 가지 제약사항이 있음을 이해하고 도출해낼 수 있다.

##### 4-1. RSC에서 RCC로 `function`과 같은 직렬화 불가능한 객체를 `prop`으로 넘겨줄 수 없다.

- RSC는 서버에서 해석되어 **직렬화된 JSON 형태**로 변환된다. 
	- 그래서 **서버 컴포넌트의 구성 요소는 직렬화 가능해야 한다**라는 전제조건이 붙는다. 

- 만약, RSC가 자식 컴포넌트인 RCC에게 함수를 `props`로 넘겨주면, 서버에 의해 해석된 서버 컴포넌트의 직렬화된 JSON 데이터에 이 사실이 명시되어야 하므로, 에러가 발생할 수 있다.
```tsx
export default function Page(){
	function eventFunc(){
		// ...
	}
	
	return <ClientComponent func={func} ... />
}
```

```tsx
 {
   $$typeof: Symbol(react.element),
   type: "div",
   props: { 
 		children: {
 		  $$typeof: Symbol(react.element),
           type: {
             $$typeof: Symbol(react.module.reference),
             name: "page",
             filename: "./src/ClientComponent.js"
           },
 		  props: {callback:function}, // 이처럼 JSON에 function이 명시되어야만 한다.
 		  ...
 		}
 	},
   ...
 }
```

- 그 외에도 아래와 같은 이유가 있다.
	- 1. **SSR과 CSR으로서의 차이**: RSC는 서버 측에서 렌더링되고 클라이언트에게 HTML 형태로 전달된다. 이에 반해 RCC는 브라우저에서 자바스크립트를 사용하여 렌더링된다. 서버와 클라이언트 간에 함수를 전달하면, 서버에서는 함수를 실행하고 결과를 HTML로 렌더링하지만, 클라이언트에서는 함수가 다시 실행되지 않고 단순히 결과만 받게 된다. 
    
	2. **클라이언트-서버 간 분리**: 서버 측과 클라이언트 측의 환경은 분리되어 있다. 서버에서 사용되는 함수는 서버 환경을 고려하여 작성되었을 수 있으며, 클라이언트 환경에서는 작동하지 않을 수 있다. 
	
	3. **보안 이슈**: 클라이언트 측에 함수를 전달하면 해당 함수가 악의적인 코드로 대체될 수 있으며, 이는 보안 문제로 이어질 수 있습니다. 사용자 입력 또는 외부 소스에서 받은 데이터를 사용하여 함수를 생성하거나 실행하는 경우, 클라이언트 측에 해당 함수를 전달하는 것은 특히 위험할 수 있다.

- 하지만, **RSC에서 다른 RSC로 함수를 넘기는 것은 문제가 없다.** 왜냐하면, RSC간의 함수 전달은 서버 환경에서 실행되는 자바스크립트 코드로 간주되기 때문이다.
	- RSC는 Node.js와 같은 서버 환경에서 실행되며, 클라이언트 환경에서는 실행되지 않는다.
		- 어차피 서버에서 렌더링되는 RSC간의 함수 전달을 굳이 클라이언트 측으로 넘기는 `Stream`에 서술할 필요가 없다.
	- 이에 따라 **RSC 간에 함수를 전달하더라도 클라이언트 측에서는 이 함수를 직접 사용할 수 없기 때문에 클라이언트에서 함수가 실행되어야 하는 상황에서 단순히 결과만 받게되는 문제가 아예 발생하지 않는 것**이다.

> **예외**
```tsx
const ServerComponent = ()=>{
  const add = async (a:number,b:number) =>{
    'use server'
    return a+b
  }

  return <div>
        <ClientComponent addFunc={add}/>
    </div>
}
```
 -  next.js의 `server action`을 사용하면 **RSC에서 RCC로 함수를 전달할 수 있다.**
	 - 위와 같이 RSC에서 `use server` 지시어와 함께 함수를 정의하면 RCC로 넘겨줄 수 있다.
	 - 이 때, 해당 함수의 `params`와 `return data`은 모두 직렬화가 가능해야 한다. 

- 이 때, RSC에서 RCC로 함수를 전달할 수 있는 이유는 **"use server" 지시문**과 관련이 있다고 예상할 수 있다.
	- **`'use server'` 지시문**: 클라이언트 컴포넌트에서 서버 컴포넌트로 함수를 전달하려면, 해당 함수가 "use server" 지시문을 사용하여 정의되어야 한다. 이렇게 하면 해당 함수가 서버 환경에서 실행될 것으로 표시되어 클라이언트 컴포넌트에서도 사용할 수 있게 되기 때문이다.
	- `server action`에 대한 자세한 내용은 [여기](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)를 참조하자.

##### 4-2. RCC는 RSC를 직접 return해줄 수 없으며, 반드시 `children prop`의 형태로 넘겨주어야 한다.
```tsx
const ChildServerComponent = () =>{
	...
  return <div>server component</div>;
}

const ParentClientComponent = () =>{
	...
	return <div><ChildServerComponent/></div>;
}

function ContainerServerComponent() {
  return <ParentClientComponent/>;
}
```

- **서버**에서는 모든 RSC가 순차적으로 해석되다가, 중간에 **RCC**를 만나면 `placeholder`로 표시해두고 넘어간다고 언급했다. 
	- 즉, RCC는 서버 측에서 해석되지 않기 때문에, RCC(`<ParentClientComponent/>`) 내부에서 반환되는 **children RSC**(`<ChildServerComponent />`) 가 있다면, RSC임에도 불구하고 서버에서 해석되지 못한다. 이러한 경우 해당 RSC는 RCC와 동일하게 클라이언트에서 렌더링된다.

```tsx
function ChildServerComponent() {
	...
  return <div>server component</div>;
}

function ParentClientComponent({children}) {
	...
  return <div onChange={...}>{children}</div>;
}

function ContainerServerComponent() {
  return <ParentClientComponent>
			<ChildServerComponent/>
	</ParentClientComponent>;
}
```
- 하지만 `children props`을 통해 **children RSC**(`<ChildServerComponent />`)를 넘기게 되면, 이야기가 다르다.
	- 사실상 `<ContainerServerComponent />`를 공통 부모로 갖고 있기 때문에, 공통 부모인 `<ContainerServerComponent />`가 서버에서 렌더링되는 시점에 **children RSC**(`<ChildServerComponent />`)도 함께 렌더링된다.


#### 5. CSR과 SSR

> [참고 출처](https://velog.io/@taek2yo/CSR-%EA%B3%BC-SSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
##### 5-1. CSR
- CSR은 서버에서 초기 렌더링 없이, 클라이언트(브라우저)에서 자바스크립트(Javascript)를 사용해 애플리케이션을 렌더링하는 방식을 사용하는 렌더링 방법이다
	- 클라이언트는 서버로부터 **빈 HTML를 다운로드** 받고, 함께 넘겨준 자바스크립트 다운로드 링크를 통해 **자바스크립트 다운로드**를 완료하면, 이 자바스크립트를 실행하여 동적으로 페이지를 만들어서 **브라우저에 띄워준다.**

- 예를 들어 React로 만든 홈페이지에 들어가면 `index.html`을 다운받게 되고, 그 안의 `index.js` 파일을 다운로드 하게 된다.
	- 이 `index.js` 파일에 모든 코드들이 들어있기 때문에 처음 다운로드 하는데 시간이 걸릴 수 있다.

- 전통적인 CSR의 **단계**는 아래와 같다.
	1. 사용자가 웹 사이트 요청을 보낸다.
	2. 서버는 **빈 HTML과 접근 가능한 JS 링크**를 응답으로 보내준다.
		- 이 때, CDN에 의해 **엔드 유저의 요청에 물리적으로 가까운 서버에서** 응답해 줄 수 있다.
		
	3. 클라이언트는 접근 가능한(연결된) 자바스크립트 링크를 통해, 서버로부터 다시 자바스크립트 파일을 다운로드한다.
		- 이때, SSR과 다르게 사용자는 화면을 볼 수 없다.
		
	4. 자바스크립트 다운로드가 완료되면, 자바스크립트가 실행되며 **데이터를 위한 API가 호출**된다.
	5. 서버가 API로부터의 요청에 응답하면, 클라이언트는 **response data**(서버로부터 받아온 데이터)를 `placeholder` 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

> 장점
- 초기로딩 이후 구동속도가 빠르다. 
- 페이지 전환이 매끄럽다. (화면 깜빡임이 없다.)
- 반응속도가 빠르고 UX가 우수하다 
- 서버측 부하가 적다 

> 단점
- SEO에 불리하다 (초기에 빈 HTML을 전달하므로, 검색엔진에 걸리지 않는다.)
- 자바스크립트 다운로드 후 동적으로 DOM을 생성하는 시간을 기다려야 하기에 초기 로딩 속도가 느리다. 

##### 5-2. SSR
- SSR은 서버에서 컴포넌트를 해석한 다음, 요청이 들어온 매 페이지마다 서버에서 즉시 렌더링 가능한 HTML을 생성해서 클라이언트에 전달하는 방식을 사용하는 렌더링 방법이다.

- 전통적인 SSR의 **단계**는 아래와 같다.
	1. 사용자가 웹 사이트 요청을 보낸다.
	2. 서버는 **즉시 렌더링 가능한 HTML 파일**을 만든다.
	3. 클라이언트는 이미 렌더링 준비가 된 HTML 파일을 받고, 즉시 HTML을 렌더링한다.
		- 그러나 **사이트 자체는 조작 불가능**하다. (자바스크립트가 읽히기 전이다.)  
		
	4. 클라이언트가 자바스크립트(`bundle`)를 다운받는다.  
		- 스크립트 다운로드 중, 사용자 조작이 발생하면, 해당 시점의 사용자 조작을 기억하고 있는다.  
		
	5. 브라우저가 **자바스크립트 프레임워크를 실행**한다.  
	6. 자바스크립트까지 성공적으로 컴파일되면, 기억하고 있던 사용자 조작이 실행되고, 웹 페이지가 상호작용 가능해진다.

>장점
- HTML에 모든 데이터가 담긴 채 브라우저에 전달되므로 **SEO에 유리**하다.
- 자바스크립트를 다운로드 받고 실행하기 전에 사용자가 미리 화면을 볼 수 있다. (초기 구동 속도가 빠르다.) 물론 이 때 동작은 불가하고 화면만 보이는 상태이다.

>단점
- TTV(Time To View)와 TTI(Time to Interact) 간의 시간 간격이 존재한다. 
- 화면 깜빡임이 있다. 

#### 6. Next.js의 SSR과 RSC

- Next.js에서 사용하는 SSR은 전통적인 SSR과는 거리가 있다. SSR과 CSR의 장점을 최대한 취하기 위해 절충점을 찾은 형태라 볼 수 있다.
	- Next.js는 초기 로딩속도가 느리다는 CSR 단점을 보완하기 위해서, **서버에서 HTML 파일을 SSR방식으로 빠르게 받아오고**, 병렬적으로 자바스크립트 번들(Javascript Bundle)을 함께 다운로드하여 미리 받아온 HTML 파일과 병합하는 **Hydration 과정**을 거치게 된다.

- Next.js의 RSC는 SSR과 함께 사용될 경우, 이점이 극대화될 수 있다. 그 내용은 아래와 같다.

##### ※ Zero Bundle Size
- RSC는 서버에서 이미 모두 실행된 후 직렬화된 JSON 형태로 전달되기 때문에 **Bundle에 포함될 필요가 없다.**
	- 즉, RSC의 소스파일, RSC에서만 사용하는 **외부 라이브러리**들은 Bundle에 포함될 필요가 없기 때문에 Bundle size를 줄일 수 있다.

##### ※ No more getServerSideProps / getStaticProps
- Next.js v12까지는 서버에 접근하는 함수로 `getServerSideProps`와 `getStaticProps`를 사용했다. Data fetch를 수행할 때는 페이지 최상단에서 이 함수를 사용하여야만 했다.

- 하지만, RSC는 서버에서 실행되는 컴포넌트이기 때문에, 더이상 **서버에 접근하기 위한 목적**으로 `getServerSideProps`와 `getStaticProps`를 사용할 필요가 없어졌다. 즉, RSC 내부에서 Data Fetch를 실행해도 문제가 없다는 뜻이다.

##### ※ Progressive Rendering
- Next.js v13부터는 컴포넌트가 서버에서 한차례 렌더링되는 과정에서, 직렬화된 JSON이 수행된다. 그리고 클라이언트 측에서는 그 결과물을 `stream` 형태로 수신한다.

- 데이터가 `stream`형태로 전달되면, 클라이언트는 스크린의 모든 화면정보를 수신할 때까지 기다릴 필요가 없어진다.
	- 먼저 수신된 부분부터 반영하기 시작하여 화면에 띄워줄 수 있게 되기 때문이다.
	- Next.js에서는 이 기술을 **Streaming**이라고 하여, **경로를 더 작은 "청크"로 나누어 서버에서 클라이언트로 점진적으로 스트리밍하는 데이터 전송 기술**이라고 소개하고 있다.
	- 이 기술을 사용해 **우선순위가 높은 컴포넌트를 먼저 작동**하게 해 줄 수 있기 때문에, 사용자는 모든 데이터가 로드될 때 까지 기다리지 않고, **페이지의 일부를 보고 상호작용**할 수 있게 된다.

- **Streaming** 기술 중 Suspense라는 것이 있다. 이는 동적 컴포넌트를 감쌀 수 있는 컴포넌트이며, 동적 컴포넌트가 로드되는 동안 보여줄 대체 컴포넌트를 전달할 수 있다.
	- 이는 응용 프로그램 일부의 렌더링 부분을, 일부 조건을 충족할 때까지 지연시킬 수 있다는 의미이다.
	- 정리하면, **Streaming** 기술 중 Suspense라는 것을 사용하면 **모든 데이터를 기다릴 필요 없이 먼저 그릴 수 있는 부분을 반영하여 뷰를 로드한 뒤, data fetch가 완료되면 그 결과가 즉각적으로 스트림에 반영**할 수 있다.

##### ※ 컴포넌트 단위 refetch
- 전통적인 SSR의 경우 완성된 HTML파일을 내려주기 때문에 작은 변경사항이 발생하더라도 전체 페이지를 전부 새로 그려서 받아와야 했다. 하지만 RSC를 사용하는 경우, 서버가 클라이언트에게 전달하는 최종 결과물이 직렬화(JSON)된 `stream` 형태라고 말했다.

- 그리고 클라이언트는 이 `stream`을 해석하여 **virtualDOM**을 형성하고, **Reconciliation**이라는 과정을 통해 뷰를 갱신한다.

- 이렇게 하면, 화면에 변경사항이 발생하여 서버에서 새로운 데이터를 받아와야 하더라도, 새로운 스크린으로 갈아끼우는 것이 아니라 기존 화면의 `state` 및 `context`를 유지한 채로 변경된 사항만 선택적으로 반영할 수 있게 된다.


#### 7. 더 알아보기 (SSR과 SSG)

- SSG(Static Site Generation)은 Static Rendering이라고도 불리며, 서버에서 HTML을 보내준다는 차원에서는 SSR과 유사하지만, 언제 만들어지는지가 다르다.
##### ※ SSR
- SSR은 요청 시 서버에서 즉시 HTML을 만들어 응답하기 때문에, **데이터가 달라지거나 자주 바뀌어서 미리 만들어두기 어려운 페이지에 적합**하다.
##### ※ SSG
- SSG는 **페이지들을 모두 서버에 만들어둔 후 요청 시에 해당 페이지를 응답하는 것**이기 때문에, 바뀔 일 없이 캐싱해두면 좋을 페이지에 사용하기 좋다.


#### 8. 더 알아보기 (기타)

###### 1. 이전까지의 렌더링 방식은?
- 예전에는 **SSR을 사용한 MPA방식**을 사용했다.
	- 페이지 이동마다 페이지를 재생성해야했기 때문에, 서버 부하가 존재했고, 사용자가 페이지를 이동할 때마다 초기에 흰 화면을 보는 문제가 있었다.

###### 2. React는?
-  React는 CSR을 사용한 SPA 방식을 사용한다.
	- 초기 로딩시간은 길지만, 초기 로딩 이후 페이지 전환이 빠르고 UX가 부드럽다. 
	- 그러나 SEO에 불리하다.


###### 3. SPA(Single Page Application)
-  브라우저 내부에서 동작하는 앱으로, 사용하는 동안 페이지의 전환을 요구하지 않는다.
	-  Gmail, Google Maps, Facebook 같은 페이지가 대표적인 예시이다.

- 단, **하나의 페이지로 이루어진 애플리케이션**이다.
	- **하나의 HTML 파일을 기반으로, 자바스크립트를 이용해 동적으로 화면 컨텐츠를 바꾸는 방식**을 사용한다.
	- 맨 처음에만 서버로부터 리소스(HTML, CSS, 자바스크립트)들을 받아오고, 이후에는 기존 페이지의 내부를 수정하면서 보여주는 특징이 있다.
		- 만약, 추가적인 데이터가 필요하면, **필요한 부분만 서버로부터 전달받아 화면을 갱신한다.**

- 주의해야할 점은, SPA는 모든 것을 자바스크립트로 처리하기 때문에 HTML 파일에는 대부분 해당 웹을 작동시키기 위한 자바스크립트 파일만 포함되고 나머지 컨텐츠는 텅 비어 있다. 
	- 이 때문에, **웹 크롤러**가 맨 처음 페이지에 접근하였을 때 페이지 정보를 읽을 수 없어 SEO 측면에서 불리하다는 이야기가 나오는 것이다.

> 장점
1. 전체 페이지를 업데이트할 필요가 없으므로, 깜빡임 현상이 없다. (UX 유리)
2. 초기 로딩 이후에는, 필요한 리소스만 부분적으로 가져오면 되므로 성능상 유리하다 (MPA보다)
3. 컴포넌트 별 개발이 용이하기에, 생산성에서 뚜렷한 장점이 있다.

> 단점
1. 맨 처음에 전체 리소스를 받아오는 과정에서, 자바스크립트 파일을 번들링하여 한 번에 다운로드하기 때문에 초기 구동속도가 느리다.
	- 이 문제를 해결하기 위해, Webpack의 **코드 스플리팅** 기능이 있다고 한다.

2. SSR에서는 사용자 정보를 서버 측에서 세션으로 관리할 수 있지만, CSR방식에서는 클라이언트 쿠키, 웹 스토리지 등을 제외하고는 사용자 정보를 저장할 공간이 마땅치 않다. (보안 이슈가 있음)

3. 검색엔진 최적화가 어렵다.


###### 4. MPA(Multiple Page Application)
-  이름에서도 알 수 있듯, 화면마다 HTML이 존재한다.
	- **여러 개의 페이지로 구성된 애플리케이션**이다.

- 사용자가 페이지를 요청할 때마다 서버에서는 렌더링된 **정적 리소스(HTML ,CSS, JavaScript)** 를 전달하고, 클라이언트 측에서는 이를 다운로드한다.
	- 페이지를 이동하거나, 새로고침하면 전체 페이지를 다시 렌더링한다.

> 장점
1. 사용자가 보는 화면의 방식이 곧 **웹 크롤러가 보는 방식과 동일**하므로, SEO 관점에서 유리하다.
    - MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받으므로, 검색엔진이 페이지를 크롤링하기에 적합하다.
    
2. 첫 페이지 로딩 시간이 짧다.  
    - 서버에서는 이미 요청한 페이지를 렌더링하여 클라이언트에게 전달해주기 때문이다.
    - 그러나 클라이언트가 자바스크립트 파일을 모두 다운로드하고 적용하기 전까지는, 각 이벤트 기능이 동작하지 않는다.

> 단점
1. 새로운 페이지를 이동할 때매다, 매 페이지를 요청하기 때문에 깜빡이는 현상이 발생하여, UX에 불리하다.
2. 페이지를 이동할 때마다, 불필요한 **템플릿도 중복해서 로딩**하기 때문에 성능면에서 아쉽다.
3. 매 페이지마다 서버에서 정적 리소스를 전달해주어야 하므로, 서버에 비교적 많은 부하가 가해진다.
