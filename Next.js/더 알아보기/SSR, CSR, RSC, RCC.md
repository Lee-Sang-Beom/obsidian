
#### 1. Next.js 의 RSC, RCC, SSR, CSR 알아보기

 > [2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)

- 위의 **포스트**에서는, Next.js의 RSC(React Server Component), RCC(React Client Component)의 동작과 이것들이 Next.js의 SSR과 어떻게 맞물리는지를 굉장히 알기 쉽게 설명하고 있다.

- 여기서는, 링크한 포스트에서 주의깊게 살펴보아야 할 내용을 요약하고, 잘 이해되지 않았던 내용을 다시금 정리하며 Next.js의 컴포넌트 동작에 대해 좀 더 자세히 알아가보고자 한다.

---
#### 2. RSC(React Server Component) vs RCC(React Client Component)

- RSC(React Server Component)란, 서버에서 렌더링되는 컴포넌트를 의미한다. RSC에서는, `async`, `await`을 사용하여 비동기 데이터를 가져와 렌더링하는 것이 가능하다.
	- 해당 개념이 등장하기 이전의 **Next.js**에서는, 서버에 접근해 데이터를 **Fetch**한 후 하위 컴포넌트에 데이터를 넘겨주기 위해서는 페이지 최상단에서 `getServerSidePros`함수를 사용하여 일일히 넘겨줘야 했다.
	- 하지만, **서버에서 동작하는 컴포넌트**라면? 서버에서 Fetch를 수행하기 때문에 굳이 `getServerSideProps`를 사용하지 않아도 되게 된다.

- 반면, RCC(React Client Component)는 클라이언트 측에서 렌더링되는 컴포넌트이며, Next.js v12까지 개발 시 사용했던 모든 컴포넌트이기도 하다. 아래의 동작을 관리할 수 있다.
	- **브라우저 API** 및 브라우저 전용 API에 의존하는 사용자 지정 `hook` 사용
	- `react hook` 과 관련된 상태(state) 및 수명 주기 효과 사용
	- 사용자 상호관리 및 Event listener의 관리

![[서버 컴포넌트와 클라이언트 컴포넌트.png]]

---
#### 3. RSC(React Server Component)의 동작 방식

- 그렇다면, RSC는 어떻게 렌더링 될까?
	- 사용자가 특정 웹사이트에 요청을 보내면, 서버는 **컴포넌트 트리를 `root`부터 직렬화된 JSON형태로 재구성하기 시작한다.**
	- [이미지 출처 - 2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)
![[직렬화 전 클라이언트 및 서버 컴포넌트.png]]
##### 3-1. 직렬화와 서버 컴포넌트(RSC)

- 여기서 **직렬화**란, 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일하거나 **다른 컴퓨터 환경에 저장**하고 **나중에 재구성할 수 있는 포맷으로 변환**하는 과정이다.
	- 즉, 특정 개체를 다른 컴퓨터 환경으로 전송 및 재구성할 수 있는 형태로 변경하는 과정이라고 정리할 수 있다. 
	- `JSON.stringify()`가 직렬화, `JSON.parse`가 역직렬화를 수행하는 함수이다.

- 직렬화 과정은 모든 서버 컴포넌트를 실행한 다음, 컴포넌트 트리가 **JSON 객체 형태의 트리로 재구성될 때까지 진행**된다.

- 이 때, 함수는 직렬화하지 못하는 객체로 분류된다. 이는 함수가 **실행코드 및 실행 컨텍스트를 모두 포함**하는 개념이기 때문이다.
	- 함수는 단순한 데이터가 아니라, 프로그램이나 스크립트의 일부로서 동작하며, 자바스크립트 엔진에게 **실행되어야 하는 코드**이다.
		- 함수가 하는 일에 대한 **설명**이나 함수의 **설정 정보를 저장**할 수는 있으나, 그 함수를 완전히 저장하고 나중에 불러와 실행할 수 있다는 것은 일반적으로 어렵고 복잡한 과정이다.
		
	- 왜냐하면, 함수를 직렬화하려면 자신이 선언된 스코프에 대한 참조를 유지하고, 해당 시점의 외부 변수에 대한 참조를 기억하여야 하기 때문이다. 
		- 이는 함수의 직렬화를 진행하려면, 함수의 **내용** 뿐 아니라 **실행 컨텍스트**와 함께 **스코프, 클로저와 같은 모든 종속성**을 저장해야 한다는 의미이다. 일반적으로 **굉장히 복잡하고, 비효율적**인 일이라고 한다.
		- 때문에, 함수를 직렬화할 수 없다는 것은 일반적으로 프로그래밍 언어 및 환경에 대한 제약사항으로 분류된다. 몇몇 특정한 상황에서는 함수를 직렬화할 수 있도록 하는 라이브러리나 도구가 있을 수 있지만, 이는 일반적인 상황에서는 드물고, 일반적으로 권장되지 않는다고 한다.

##### 3-2. 직렬화와 클라이언트 컴포넌트(RCC)

- 앞서, 사용자가 특정 웹사이트에 요청을 보내면, 서버는 **컴포넌트 트리를 `root`부터 직렬화된 JSON형태로 재구성하기 시작한다**고 언급했다.

- 이 직렬화 과정은 모든 컴포넌트에 대해 실행되는 것이 아니라, **RCC**인 경우 건너뛰게 된다.
	- 왜냐하면, RCC는 **클라이언트가 JS 번들을 다운로드 받은 후 해석하게 되는 위치**이며, 곧 **함수**이기 때문이다.
	- 대신 **RCC**의 경우, 직접 직렬화 과정을 거치면서 해석하는 것이 아니라 **`module reference` 라고 하는 새로운 타입을 적용하여, 해당 컴포넌트의 경로를 명시함으로써 직렬화를 우회**하게 된다. (RCC 영역이라고 `placeholder` 배치)

- 직렬화 작업이 끝나면, 컴포넌트 트리는 JSON 트리로 생성된다.
	- [이미지 출처 - 2ast님의 포스트](https://velog.io/@2ast/React-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8React-Server-Component%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0)
![[사용 이미지/Next.js/더 알아보기/직렬화 후 클라이언트 및 서버 컴포넌트.png]]

- 직렬화 작업 결과물(JSON Tree)은 이후, `Stream` 형태로 클라이언트가 전달받게 된다
	- 클라이언트는 함께 다운로드 한 `JS Bundle`을 참조하여 `module reference` 타입이 등장할 때마다 RCC를 렌더링한다.
	- 서버 측에서 직렬화하며 해석하지 못한 RCC를 마저 해석(렌더링)한 후, 결과가 DOM에 반영되면 실제 화면에 보여지게 된다.
		- 이 때 비로소, `placeholder`로서 표시만 되었던 클라이언트 컴포넌트가 다시 구성요소로서 완전히 전환되는 것이다.

![[직렬화 후 해석된 클라이언트 및 서버 컴포넌트.png]]

> stream이란?
- 정의
	- **Stream**이란, **데이터를 연속적으로 처리하는 방식**을 말한다. 
	- 이는 작은 단위의 데이터 청크(chunk)를 순차적으로 전송하거나 처리하여, 대량의 데이터를 한꺼번에 다루지 않고도 효율적으로 작업할 수 있게 하는 개념이다. 
	- 다양한 기술과 맥락에서 사용되며, 파일 처리, 네트워크 통신, 실시간 데이터 전송 등 여러 분야에서 활용된다.

- 특징
	- **순차적 처리**: 데이터가 작은 청크 단위로 도착하면 즉시 처리 가능.
	- **메모리 효율**: 한 번에 전체 데이터를 메모리에 올리지 않기 때문에 메모리 사용량이 적음.
	- **실시간 데이터**: 데이터를 모두 준비하지 않고도 처리나 전송 가능.

- 사례
	1. 파일 스트림: 대용량 파일을 한 번에 읽거나 쓰는 대신, 스트림을 사용해 **조금씩 읽고 처리**
	2. 네트워크 스트림 : 네트워크를 통해 데이터 전송 시, 데이터를 청크 단위로 전송
	3. RSC와 Stream
		- React Server Components(RSC)에서는 HTML이나 JSON 데이터가 스트림 방식으로 클라이언트로 전달될 수 있다.
		- **React 18+** 에서 스트리밍을 지원하여, 서버에서 컴포넌트를 렌더링하는 동안 데이터를 청크 단위로 클라이언트에 전송한다.
		- 클라이언트는 데이터를 조금씩 받아 UI를 점진적으로 렌더링할 수 있다.

---
#### 4. RSC의 제약사항

- 위의 과정을 토대로, RSC와 RCC 사용 시, 몇 가지 제약사항이 있음을 이해하고 도출해낼 수 있다.

##### 4-1. RSC에서 RCC로 `function`과 같은 직렬화 불가능한 객체를 `prop`으로 넘겨줄 수 없다.

- RSC는 서버에서 해석되어 **직렬화된 JSON 형태**로 변환된다. 
	- 그래서 **서버 컴포넌트의 구성 요소는 직렬화 가능해야 한다**라는 전제조건이 붙는다. 

- 만약, RSC가 자식 컴포넌트인 RCC에게 함수를 `props`로 넘겨주면, 서버에 의해 해석된 서버 컴포넌트의 직렬화된 JSON 데이터에 이 사실이 명시되어야 하므로, 에러가 발생할 수 있다.
```tsx
export default function Page(){
	function eventFunc(){
		// ...
	}
	
	return <ClientComponent func={func} ... />
}
```

```tsx
 {
   $$typeof: Symbol(react.element),
   type: "div",
   props: { 
 		children: {
 		  $$typeof: Symbol(react.element),
           type: {
             $$typeof: Symbol(react.module.reference),
             name: "page",
             filename: "./src/ClientComponent.js"
           },
 		  props: {callback:function}, // 이처럼 JSON에 function이 명시되어야만 한다.
 		  ...
 		}
 	},
   ...
 }
```

- RSC는 위에서 설명한 이유로, 서버에서 함수 실행의 결과만 클라이언트로 전달되기 때문에 RSC 관점에서는 클라이언트로 함수를 직접 전달할 수 없다. 아마 아래의 이유도 포함되어 있지 않을까 싶다.
	1. **클라이언트-서버 간 분리**: 서버 측과 클라이언트 측의 환경은 분리되어 있다. 서버에서 사용되는 함수는 서버 환경을 고려하여 작성되었을 수 있으며, 클라이언트 환경에서는 작동하지 않을 수 있다. 
	
	2. **일반적인 보안 이슈**: 클라이언트 측에 함수를 전달하면 해당 함수가 악의적인 코드로 대체될 수 있으며, 이는 보안 문제로 이어질 수 있다. 사용자 입력 또는 외부 소스에서 받은 데이터를 사용하여 함수를 생성하거나 실행하는 경우, 클라이언트 측에 해당 함수를 전달하는 것은 특히 위험할 수 있다.


- 하지만, **RSC에서 다른 RSC로 함수를 넘기는 것은 문제가 없다.** 왜냐하면, RSC간의 함수 전달은 서버 환경에서 실행되는 자바스크립트 코드로 간주되기 때문이다.
	1. **RSC 간 함수 전달은 안전하다**:
	    - RSC는 서버 환경에서 실행되며, RSC 간의 함수 전달은 서버 내부의 JavaScript 코드에서 처리된다. 
	    - 따라서, 서버 간 함수 실행은 일반적인 동작으로 문제가 없다.
	      
	2. **클라이언트에서 함수 실행 문제는 발생하지 않는다**:
	    - 클라이언트는 서버로부터 전달받은 결과 데이터만 사용하며, 서버에서 사용한 함수나 함수 호출은 클라이언트로 전달되지 않는다.
	    - 따라서 클라이언트에서 "함수 자체가 클라이언트로 전달되지 않기 때문에 함수 실행 문제는 처음부터 발생하지 않는다"고 말할 수 있다.
	      
	- **Stream에서 함수에 대한 서술은 필요 없다**:
	    - 클라이언트로 스트리밍되는 데이터는 RSC에서 처리된 결과 데이터이며, 서버 함수와는 무관하다. 
	    - 스트리밍에 서버 함수 자체를 포함하거나 이를 클라이언트에서 실행할 필요는 없다.

> **예외**
```tsx
const ServerComponent = ()=>{
  const add = async (a:number,b:number) =>{
    'use server'
    return a+b
  }

  return <div>
        <ClientComponent addFunc={add}/>
    </div>
}
```
 -  next.js의 `server action`을 사용하면 **RSC에서 RCC로 함수를 전달할 수 있다.**
	 - 위와 같이 RSC에서 `use server` 지시어와 함께 함수를 정의하면 RCC로 넘겨줄 수 있다.
	 - 이 때, 해당 함수의 `params`와 `return data`은 모두 직렬화가 가능해야 한다. 

- 이 때, RSC에서 RCC로 함수를 전달할 수 있는 이유는 **"use server" 지시문**과 관련이 있다고 예상할 수 있다.
	- **`'use server'` 지시문**: 클라이언트 컴포넌트에서 서버 컴포넌트로 함수를 전달하려면, 해당 함수가 "use server" 지시문을 사용하여 정의되어야 한다. 이렇게 하면 해당 함수가 서버 환경에서 실행될 것으로 표시되어 클라이언트 컴포넌트에서도 사용할 수 있게 되기 때문이다.
	- `server action`에 대한 자세한 내용은 [여기](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)를 참조하자.

##### 4-2. RCC는 RSC를 직접 return해줄 수 없으며, 반드시 `children prop`의 형태로 넘겨주어야 한다.
```tsx
const ChildServerComponent = () =>{
	...
  return <div>server component</div>;
}

const ParentClientComponent = () =>{
	...
	return <div><ChildServerComponent/></div>;
}

function ContainerServerComponent() {
  return <ParentClientComponent/>;
}
```

- **서버**에서는 모든 RSC를 순차적으로 해석하다가, 중간에 **RCC**를 만나면 `placeholder`로 표시해두고 넘어간다고 언급했다. 
	- 즉, RCC는 서버 측에서 해석되지 않기 때문에, RCC(`<ParentClientComponent/>`) 내부에서 반환되는 **children RSC**(`<ChildServerComponent />`) 가 있다면, RSC임에도 불구하고 서버에서 해석되지 못한다. 이러한 경우 해당 RSC는 RCC와 동일하게 클라이언트에서 렌더링된다.

> 불가능한 구조
```tsx
function ChildServerComponent() {
  // 서버에서 렌더링된 HTML을 반환
  return <div>server component</div>;
}

function ParentClientComponent() {
  // 동적 상호작용을 처리하는 클라이언트 컴포넌트
  return (
    <div onChange={...}>
      <ChildServerComponent />
    </div>
  );
}

function ContainerServerComponent() {
  return <ParentClientComponent />;
}

```
- **`ParentClientComponent`에서 `ChildServerComponent`를 포함**하는 위 코드에서 문제가 되는 부분은 `ParentClientComponent`가 **자기 자신의 렌더링**에서 `ChildServerComponent`를 직접 포함하고 있다는 점이다.
	- 이때 `ParentClientComponent`는 **클라이언트 컴포넌트**이고, `ChildServerComponent`는 **서버 컴포넌트**이다.
	- 서버 컴포넌트는 HTML을 렌더링하는 역할만 하고, 이벤트 핸들링이나 동적 상호작용을 처리할 수 없다. 서버 컴포넌트를 클라이언트 컴포넌트 내부에 직접 포함하려고 하면, 그 서버 컴포넌트가 **클라이언트에서 동적으로 상호작용할 수 없는 상태**가 되어버리기 때문이다.
	
	- **서버 컴포넌트가 클라이언트 컴포넌트의 자식으로 포함되는 구조에서 발생하는 문제는** 상호작용을 처리하는 데 제한이 있다는 점이다. 서버 컴포넌트가 렌더링된 HTML을 클라이언트에 전달하는 과정에서, 클라이언트에서 상호작용을 처리하려면 자바스크립트가 필요한데, 서버 컴포넌트는 자바스크립트가 로드되기 전에 이미 렌더링된 정적인 HTML을 제공하므로, 동적 상호작용을 할 수 없다.
	
	- 위 코드에서, **`ParentClientComponent`** 가 클라이언트에서 상호작용을 처리하려면, 그 안에 포함된 **서버 컴포넌트**가 동적으로 상호작용할 수 있는 상태여야 하지만, 이 구조에서는 `ChildServerComponent`가 **서버에서 정적인 HTML만 제공**하고, 자바스크립트나 이벤트 핸들링이 포함되지 않기 때문에 문제가 발생한다.


> 가능한 구조
```tsx
function ChildServerComponent() {
  // 서버에서 렌더링된 HTML을 반환
  return <div>server component</div>;
}

function ParentClientComponent({ children }) {
  // children을 받아서 동적 처리를 할 수 있는 컴포넌트
  return <div onChange={...}>{children}</div>;
}

function ContainerServerComponent() {
  return (
    <ParentClientComponent>
      <ChildServerComponent />
    </ParentClientComponent>
  );
}

```
- 하지만 `children props`을 통해 **children RSC**(`<ChildServerComponent />`)를 넘기게 되면, 이야기가 다르다.
	- 사실상 `<ContainerServerComponent />`를 공통 부모로 갖고 있기 때문에, 공통 부모인 `<ContainerServerComponent />`가 서버에서 렌더링되는 시점에 **children RSC**(`<ChildServerComponent />`)도 함께 렌더링된다.
	- 그리고, `ParentClientComponent`가 클라이언트에서 렌더링되고, 그 안에 `ChildServerComponent`를 자식으로 포함하는 방식의 경우 `ChildServerComponent`는 서버에서 렌더링된 HTML을 제공하고, `ParentClientComponent`는 클라이언트에서 동적 상호작용을 처리할 수 있기 때문에 문제 없이 동작한다.
	- 이 때문에, **클라이언트 컴포넌트는 서버 컴포넌트를 자식으로 가질 수 있다**는 규칙이 유지될 수 있는 것이다.

- 과정은 아래와 같다.
	1. **`children`은 렌더링 전까지 `placeholder`로 존재**:
		- **서버 컴포넌트**는 **서버에서 렌더링된 HTML**만을 반환한다. 이 HTML은 클라이언트에 전달되기 전에 `children`으로서 **`placeholder`** 로 처리된다.
	    - 서버에서 HTML이 반환될 때는, 서버 컴포넌트는 **동적 상호작용을 처리하지 않기 때문에** 단순히 **정적인 HTML**로만 전달된다.

	2. **실제 화면 렌더링 시, `children`이 동적으로 표시**:
	    - 클라이언트에서 **React는 `children`을 동적으로 렌더링**한다.
	    - 즉, 서버에서 렌더링된 HTML이 클라이언트로 전송되지만, 클라이언트는 이를 받아서 **동적 상호작용**을 추가할 수 있는 **컴포넌트로 변환**한다.

	3. **Hydration이 일어나면서 클라이언트의 동적 변화가 반영**:
	    - **Hydration**은 클라이언트에서 서버에서 이미 렌더링된 HTML을 기반으로 **React의 동적 처리**를 활성화하는 과정이다. 즉, **서버에서 전달된 HTML**을 클라이언트에서 **React가 동적으로 관리**할 수 있도록 변환하는 과정이 포함되는 것이다.
	    - 이 과정에서 클라이언트 컴포넌트는 **상호작용 기능을 추가**하고, **동적 상태**나 **이벤트 처리**와 같은 클라이언트 측 기능이 활성화된다.

##### ※ children
- 그럼 여기서 '`{children}`이 뭐길래 클라이언트 컴포넌트 안에 서버 컴포넌트를 넣었을 때 동작이 되게끔 할 수 있을까?'라는 의문이 들 수 있다.

> 정의
- React 컴포넌트에서 `{children}`은 **자식 컴포넌트** 또는 **부모 컴포넌트에 포함된 내용**을 받을 수 있게 해주는 프로퍼티이다.
- 부모 컴포넌트가 자식 컴포넌트를 아래와 같이 작성했을 때, `ChildComponent`는 `ParentComponent`의 `children`이 된다.
```jsx
<ParentCompoent>
	<ChildComponent>
</ParentCompoent>
```

- React에서는 **자식 컴포넌트를 동적으로 변경**하거나 **컴포넌트의 상태에 따라 UI를 업데이트**하는 데 `children`을 사용할 수 있다. 예를 들어, 조건에 따라 다른 자식을 전달할 수 있다.
```jsx
function MessageBox({ children }) {
  return <div>{children}</div>;
}

function App() {
  const isUserLoggedIn = true;  // 상태에 따라 다르게 렌더링
  return (
    <div>
      <MessageBox>
        {isUserLoggedIn ? "Welcome back, User!" : "Please log in."}
      </MessageBox>
    </div>
  );
}
```


> 동작 방식
- `children`은 **동적**으로 부모 컴포넌트가 자식 요소를 **전달할 수 있게** 해주며, **여러 자식 요소**가 있을 수 있다..
- 하나의 컴포넌트가 여러 자식을 가질 수 있게 해주며, 그 자식들은 부모 컴포넌트에서 `{children}`으로 받아서 처리한다.

 >왜 `children`으로 서버 컴포넌트를 전달할 때는 동작하는가?
1. **`children`을 사용하는 경우**
	- React 컴포넌트에서 `{children}`은 **부모 컴포넌트가 자식 컴포넌트를 동적으로 받아 렌더링**할 수 있게 해주는 React의 특별한 프로퍼티라고 했다.
	- 즉, 부모 컴포넌트는 자식 컴포넌트를 **임의로 받는 형태**로 설계될 수 있으며, `children`을 통해 전달된 컴포넌트는 React의 렌더링 과정에서 일종의 `placeholder`(자리에 일시적으로 표시되는 값이나 요소로, 준비되지 않은 상태에서 보이는 대체물)로 처리된다.
		- 부모 컴포넌트가 `children`을 렌더링할 때, 자식 컴포넌트(여기서는 서버 컴포넌트)는 **상호작용을 위한 클라이언트 코드로 감싸질 수 있는 구조**로 작동할 수 있게 된다.
		- 간단히 말해, `children`을 사용해 서버 컴포넌트를 전달하면, 서버 컴포넌트는 클라이언트 측에서 **`hydration`** 을 통해 동적으로 처리될 수 있는 것이다. 
		- **(핵심) :** `children`이라는 게 렌더링 시점에 동적으로 자식 컴포넌트를 표시할 수 있도록 하는 React의 특수한 프로퍼티인데, `{children}`을 사용하지 않고, 직접 클라이언트 컴포넌트 안에 서버 컴포넌트를 표시하려 하면 당연히, 동적 처리나 상호작용을 위한 `hydration` 과정이 **정상적으로 동작하지 않기 때문**에 문제가 되는 것이다.
    
2. **서버 컴포넌트의 동적 처리 가능**
	- `ParentClientComponent`는 클라이언트 컴포넌트이고, 이 컴포넌트 내에서 **`children`을 동적으로 처리**할 수 있다.
	- `ParentClientComponent`가 `children`을 사용하면, 부모 컴포넌트가 자식 컴포넌트를 **동적으로 포함**하고 그 자식은 **정적인 HTML**로 렌더링되는 건 이해가 될 것이다.
		- 이 과정에서 **서버 컴포넌트**는 **HTML로서 전달**되므로, React는 **상호작용을 처리하는 클라이언트 컴포넌트**와 **서버에서 렌더링된 정적 HTML**을 분리해서 처리할 수 있게 된다. 이 구조에서 **서버 컴포넌트가 클라이언트 컴포넌트의 자식으로 들어가도 문제가 발생하지 않게 되는 것이다.**
    
> 왜 직접 서버 컴포넌트를 넣으면 에러가 나는가?
1. **`ParentClientComponent`는 클라이언트에서 동작하는 컴포넌트**이고, 이 컴포넌트는 **서버 컴포넌트를 직접 포함할 수 없다**. 
	- React에서는 **클라이언트 컴포넌트가 서버 컴포넌트를 직접 포함하는** 것에 대한 제한을 **약속**으로 두고 있기 때문에 에러가 발생한다.
    
2. **클라이언트 컴포넌트와 서버 컴포넌트 간의 구분이 모호해짐**:
	- **서버 컴포넌트를 직접 포함**하는 경우, 클라이언트 컴포넌트가 그 안에서 동적인 작업(예: 이벤트 처리 등)을 해야 하기 때문에, 서버에서 정적으로 렌더링된 HTML을 동적으로 다룰 수 없다.
		- **서버에서 정적으로 렌더링된 HTML을 동적으로 다루기 위해서는, 위에서 언급한 `children`의 개념을 이용하여 부모 컴포넌트가 자식 컴포넌트를 동적으로 받아 렌더링될 수 있도록 해야하는 것이다.**
	
	- React에서는 이를 명확히 구분하려는 규칙이 있으며, **서버 컴포넌트가 클라이언트에서 동적으로 작동할 수 없으므로**, 서버 컴포넌트를 클라이언트 컴포넌트 내부에 직접 넣는 것은 **동적 상호작용을 위한 처리**를 방해하게 된다.

> 정리
- 언급한 내용을 정리해보자면, `children`을 통해 클라이언트 컴포넌트 안에 서버 컴포넌트를 전달할 경우, **서버 컴포넌트는 클라이언트 측에서** **`hydration`** 을 통해 동적으로 처리될 수 있으며, 클라이언트 컴포넌트 안에 서버 컴포넌트가 있음을 명시적으로 알고 역할을 분리할 수 있다.
- 즉, **서버에서 HTML만 렌더링된 후, 클라이언트에서 상호작용을 추가**할 수 있는 방식으로, 서버와 클라이언트 간의 경계를 **유연하고 분리된 역할을 인지하여 확실하게 처리**할 수 있게 된다. (`children`개념을 다시 보고오면 이해가 될 것이다)

---
#### 5. CSR과 SSR

> [참고 출처](https://velog.io/@taek2yo/CSR-%EA%B3%BC-SSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
##### 5-1. CSR
- CSR은 서버에서 초기 렌더링 없이, 클라이언트(브라우저)에서 자바스크립트(Javascript)를 사용해 애플리케이션을 렌더링하는 방식을 사용하는 렌더링 방법이다
	- 클라이언트는 서버로부터 **빈 HTML를 다운로드** 받고, 함께 넘겨준 자바스크립트 다운로드 링크를 통해 **자바스크립트 다운로드**를 완료하면, 이 자바스크립트를 실행하여 동적으로 페이지를 만들어서 **브라우저에 띄워준다.**

- 예를 들어 React로 만든 홈페이지에 들어가면 `index.html`을 다운받게 되고, 그 안의 `index.js` 파일을 다운로드 하게 된다.
	- 이 `index.js` 파일에 모든 코드들이 들어있기 때문에 처음 다운로드 하는데 시간이 걸릴 수 있다.

- 전통적인 CSR의 **단계**는 아래와 같다.
	1. 사용자가 웹 사이트 요청을 보낸다.
	2. 서버는 초기 **빈 HTML**(혹은 기본 HTML 템플릿)과 자바스크립트 파일의 경로를 포함한 HTML을 클라이언트로 보낸다.
		- 이 때, CDN에 의해 **엔드 유저의 요청에 물리적으로 가까운 서버에서** 응답해 줄 수 있다.
		- 접근 가능한 자바스크립트 링크를 주는 이유는 빈 HTML을 전달하기 때문에 자바스크립트 경로를 HTML 상에서 찾을 수 없기 때문이다.
	
	3. 클라이언트는 접근 가능한(연결된) 자바스크립트 링크를 통해, 서버로부터 다시 자바스크립트 파일을 다운로드한다.
		- 이때, SSR과 다르게 사용자는 화면을 볼 수 없다.
		- 클라이언트는 HTML에서 지정된 자바스크립트 파일을 요청하여 다운로드합니다. 이 자바스크립트 파일은 웹 애플리케이션의 로직을 포함하고 있다.
		
	4. 자바스크립트 다운로드가 완료되면, 자바스크립트가 실행되며 **데이터를 위한 API가 호출**된다.
		- 자바스크립트 파일이 다운로드되면, 클라이언트는 API를 호출하여 필요한 데이터를 서버에서 비동기적으로 가져온다.
	
	5. 서버가 API로부터의 요청에 응답하여 전달해준 데이터를, 클라이언트는 이를 적절한 위치에 삽입하여, 최종적으로 페이지 내용이 동적으로 렌더링되게 된다. 이제 페이지는 상호작용이 가능해진다.
		- 자바스크립트가 다운로드되어 실행되면, 비로소 클라이언트는 HTML 문서 내에서 **동적으로 콘텐츠를 삽입**하거나 **업데이트**한다.
		- 이 과정에서 화면이 동적으로 구성된다.

> **장점**
- 초기로딩 이후 구동속도가 빠르다. (이후 발생하는 페이지 변경 및 상호작용에 대해서는 서버로부터 필요한 데이터만 요청하므로)
- 페이지 전환이 매끄럽다. (화면 깜빡임이 없다.)
- 반응속도가 빠르고 UX가 우수하다 
- 서버측 부하가 적다. (서버에서 렌더링을 하지않으며, 서버는 데이터(API)와 자바스크립트 파일을 제공하는 역할만 함)

> **단점**
- SEO에 불리하다 (초기에 빈 HTML을 전달하므로, 검색엔진에 걸리지 않는다.)
- 자바스크립트 다운로드 후 동적으로 DOM을 생성하는 시간을 기다려야 하기에 초기 로딩 속도가 느리다. 

##### 5-2. SSR
- SSR은 서버에서 컴포넌트를 해석(RSC 방식)한 다음, 요청이 들어온 매 페이지마다 브라우저가 HTML을 바로 렌더링할 수 있도록 완전한 HTML을 서버 측에서 생성해서 클라이언트에 전달하는 방식을 사용하는 렌더링 방법이다.

- 전통적인 SSR의 **단계**는 아래와 같다.
	1. 사용자가 웹 사이트 요청을 보낸다.
	2. 서버는 요청을 받은 후, 클라이언트가 바로 화면에 표시할 수 있는 **완전한 HTML 파일**을 동적으로 생성하여 응답으로 보낸다.
		- **SSR** 방식에서 서버는 요청을 받은 후 **완전한 HTML**을 생성해서 클라이언트에 전달한다.
		- **"완전한 HTML"** 이란, 서버 측에서 **요청한 페이지 내용**이 미리 렌더링된 상태의 HTML이라는 뜻이다. 즉, HTML은 **서버에서 렌더링된** 상태로 생성된다.
			- 이 때, 서버가 보낸 HTML은 **초기 데이터**를 이미 포함하고 있는데, 이 **초기 데이터**는 보통 `JSON` 형태로 포함되며, 클라이언트가 페이지를 처음 로드할 때 추가적인 **API 요청 없이** 데이터를 받아 화면을 그릴 수 있게 도와준다.
			- 즉, HTML 파일 안에 **페이지 내용과 함께 필요한 데이터**(예: 사용자 정보, 게시글 목록 등)가 **직접 포함되어 있기 때문에**, 클라이언트는 데이터를 따로 요청하지 않고도 **즉시** 페이지를 볼 수 있게 된다.
		
		- 예를 들어, React, Vue와 같은 프레임워크를 사용할 경우, 서버는 **JSX 또는 Vue 템플릿**을 **미리 렌더링하여** 해당 페이지의 HTML을 만들어 클라이언트에 보낸다.
	
	3. 클라이언트는 서버로부터 받은 HTML을 받으면, **렌더링된 HTML**을 화면에 표시하는 작업을 **즉시** 진행한다.
		- 서버 측에서는 이미 클라이언트 측 추가적인 API 요청으로 컨텐츠를 구성하지 않아도 될 수 있게, 이미 초기 데이터를 포함하여 완전한 HTML을 렌더링시켜서 보냈기 때문에 **사용자는 빠르게 페이지를 볼 수 있다**.
		- 그러나 **사이트 자체는 조작 불가능**하다. (자바스크립트가 읽히기 전이다.)  
		
	4. 클라이언트가 자바스크립트(`bundle`)를 다운받는다.  
		- 스크립트 다운로드 중, 사용자 조작이 발생하면, 해당 시점의 사용자 조작을 기억하고 있는다.  
		- 클라이언트는 서버에서 응답한 HTML 코드 중, 자바스크립트 번들 파일을 포함하는 `<script>` 태그를 통해, `bundle.js` 파일을 받아와야 웹 애플리케이션의 **상호작용**을 활성화할 수 있다.
			- 예시 : `<script src="/static/js/bundle.js"></script>`
			- 결과적으로, HTML 코드를 먼저 받고, 자바스크립트 코드를 `<script>`태그를 통해 나중에 다운받는다.

	5. 브라우저가 **자바스크립트 프레임워크를 실행**한다.  
		- 이 과정에서 페이지의 **상호작용**을 위한 JavaScript 로직이 초기화된다.
		- 이후 클라이언트 측에서 **상호작용을 처리하기 위해 CSR 방식**으로 페이지를 업데이트하고 동적인 콘텐츠가 제공된다.
		- 클라이언트는 서버로부터 받은 HTML을 기반으로 동적으로 데이터를 추가하거나 화면을 업데이트하는 **CSR 방식**을 사용한다.
			- 전통적인 **SSR 방식**에서도 **CSR 방식**을 사용하여 상호작용 처리를 했다.
			- **현대의 애플리케이션**에서는 **SSR과 CSR을 결합**하고 **Hydration**을 추가함으로써 **초기 로딩**과 **UX 문제**를 크게 개선했다.
				- 초기로딩 문제 : HTML 페이지는 서버에서 바로 렌더링되지만, 자바스크립트 로딩이 완료되기 전에 **페이지가 동적으로 변하지 않기** 때문에 **상호작용이 지연**될 수 있다.
				- UX 문제: 자바스크립트가 로드되기 전까지는 페이지 내 상호작용이 불가능하며, 브라우저의 렌더링 속도나 트워크 환경에 따라 사용자가 상호작용을 시작하는 데 시간이 걸릴 수 있다.
	
	6. 자바스크립트까지 성공적으로 컴파일되면, 기억하고 있던 사용자 조작이 실행되고, 웹 페이지가 상호작용 가능해진다.

>**장점**
- HTML에 모든 데이터가 담긴 채 브라우저에 전달되므로 **SEO에 유리**하다.
- 자바스크립트를 다운로드 받고 실행하기 전에 사용자가 미리 화면을 볼 수 있다. (초기 구동 속도가 빠르다.) 물론 이 때 동작은 불가하고 화면만 보이는 상태이다.

>**단점**
- TTV(Time To View)와 TTI(Time to Interact) 간의 시간 간격이 존재한다. 
- 화면 깜빡임이 있다. 

---
#### 6. Next.js의 SSR과 Hydration, 그리고 RSC

- Next.js에서 사용하는 SSR은 전통적인 SSR과는 거리가 있다. SSR과 CSR의 장점을 최대한 취하기 위해 절충점을 찾은 형태라 볼 수 있다.
	- Next.js는 초기 로딩속도가 느리다는 CSR 단점을 보완하기 위해서, **서버에서 HTML 파일을 SSR방식으로 빠르게 받아오고**, 병렬적으로 자바스크립트 번들(Javascript Bundle)을 함께 다운로드하여 미리 받아온 HTML 파일과 병합하는 **Hydration 과정**을 거치게 된다.
		- **Hydration**: 기본적으로 **SSR**(서버사이드 렌더링) 방식으로 제공된 **정적인 HTML**을 클라이언트에서 **동적인 페이지**로 변환하는 과정이다. 이 과정에서 클라이언트는 HTML을 단순히 렌더링하는 것이 아니라, **자바스크립트**와 연결하여 **동적인 상호작용**이 가능하도록 만든다.
	
	- **현대의 애플리케이션 (SSR + CSR + Hydration)** 은 SSR 방식으로 빠르게 HTML을 렌더링한 후, **Hydration**을 통해 클라이언트에서 **CSR 방식으로 상호작용을 활성화**하는 방식을 사용한다.
		- 이 방식은 위에서 언급했던(5번과정) 전통적 SSR의 문제였던 **초기 로딩 속도**와 **UX 문제**를 해결하여, 페이지가 빠르게 렌더링되고 이후 상호작용이 원활하게 이루어지도록 개선한다.
	
	- 기존에는 자바스크립트가 로드되기 전까지 **동적 상호작용이 불가능**했지만, **Hydration**을 통해 자바스크립트가 로드되면 페이지가 **즉시 상호작용 가능한 상태**로 바뀌므로 **초기 로딩 이후 상호작용까지의 지연**이 크게 줄어들게 되었다.
		- **Hydration이 적용되면**, 클라이언트에서 자바스크립트가 로드된 후, **HTML의 동적 변환**이 일어나게 되어 상호작용이 가능해진다. 이는 SSR로 렌더링된 정적인 HTML이 클라이언트에서 동적으로 변환시키는 것이 Hydration 과정이라는 것이다.
	
	-  Hydration이 있을 때와 없을 때의 경우가 똑같아 보일 수 있는데 핵심 차이점은 아래와 같다.
		- **Hydration이 있을 때**
			1. **서버에서 HTML과 자바스크립트 전달**:
			    - 서버는 HTML을 렌더링하여 클라이언트로 전달한다.
			    - 이때 HTML뿐만 아니라 **자바스크립트 코드**도 함께 제공된다. 즉, **HTML과 자바스크립트가 동시에 전달**된다.
			
			2. **HTML과 자바스크립트 연결**:
			    - 클라이언트에서 자바스크립트가 로드되면, 이미 서버에서 전달된 HTML을 기반으로 **동적 기능**이 활성화된다.
			    - 이 과정에서 자바스크립트가 HTML을 **"동적으로 활성화"** 하는데, 이는 버튼 클릭 같은 상호작용을 자동으로 처리하게 한다.
			    - **HTML을 변경할 필요가 없고, 상호작용을 위한 기능이 자동으로 활성화**되므로, 자바스크립트 실행 후 HTML은 동적으로 변환된다.
			      
			3. **예시**:
			    - 서버에서 버튼 HTML과 자바스크립트 파일이 함께 전달된다.
			    - 자바스크립트가 로드되면, 해당 버튼에 이벤트 리스너가 자동으로 연결되어 상호작용이 가능해진다.
		  
		- **Hydration이 없을 때**
			1. **서버에서 HTML만 전달**:
			    - 서버는 정적인 HTML을 렌더링하여 클라이언트에 전달한다. 이때 **자바스크립트 코드**는 함께 전달되지 않는다.
			    - HTML만 전달되므로, 페이지는 초기 로딩 시 **동적인 기능이 활성화되지 않은 정적인 상태**로 존재한다.
			
			2. **자바스크립트 로드 후 상호작용 가능**:
			    - HTML에 의한 페이지가 로드된 후, 클라이언트는 자바스크립트 파일을 **별도로 요청하여 로드**한다.
			    - 자바스크립트가 로드되면, 그때서야 버튼이나 다른 동적 요소들에 **이벤트 리스너**를 추가하여 상호작용을 가능하게 한다.
			
			3. **HTML 변경 필요**:
			    - 자바스크립트가 로드되기 전까지는 페이지가 정적인 상태로만 존재합니다. 즉, **HTML을 변경**해서 동적 기능을 추가해야 합니다.
			    - 예를 들어, 버튼 HTML을 서버에서 보내고, 자바스크립트가 로드되면 버튼에 클릭 이벤트를 추가하여 동적 상호작용을 가능하게 만들어야 한다.

- Next.js의 RSC는 SSR과 함께 사용될 경우, 이점이 극대화될 수 있다. 그 내용은 아래와 같다.

##### ※ Zero Bundle Size
- RSC는 서버에서 이미 모두 실행된 후 직렬화된 JSON 형태로 전달되기 때문에 **Bundle에 포함될 필요가 없다.**
	- 정확하게 말하자면, 서버 컴포넌트는 ***HTML 스니펫(특정 기능이나 콘텐츠를 나타내는 간단한 HTML 구조) 형태로 클라이언트에 전달되며, Hydration 대상에서 제외된다.***
	- 즉, 서버 컴포넌트가 반환하는 HTML은 "그대로" 브라우저에 삽입될 뿐, 클라이언트 측에서 사용되던 이벤트 핸들러나 `state` 등이 주입되지 않는다.
	- 때문에 서버 컴포넌트는 자바스크립트 번들을 거의 소비하지 않고, 성능 최적화에 큰 도움이 된다.
	- 즉, RSC의 소스파일, RSC에서만 사용하는 **외부 라이브러리**들은 Bundle에 포함될 필요가 없기 때문에 Bundle size를 줄일 수 있다.

##### ※ No more getServerSideProps / getStaticProps
- Next.js v12까지는 서버에 접근하는 함수로 `getServerSideProps`와 `getStaticProps`를 사용했다. Data fetch를 수행할 때는 페이지 최상단에서 이 함수를 사용하여야만 했다.

- 하지만, RSC는 서버에서 실행되는 컴포넌트이기 때문에, 더이상 **서버에 접근하기 위한 목적**으로 `getServerSideProps`와 `getStaticProps`를 사용할 필요가 없어졌다. 즉, RSC 내부에서 Data Fetch를 실행해도 문제가 없다는 뜻이다.

##### ※ Progressive Rendering
- Next.js v13부터는 컴포넌트가 서버에서 한차례 렌더링되는 과정에서, 직렬화된 JSON이 수행된다. 그리고 클라이언트 측에서는 그 결과물을 `stream` 형태로 수신한다.

- 데이터가 `stream`형태로 전달되면, 클라이언트는 스크린의 모든 화면정보를 수신할 때까지 기다릴 필요가 없어진다.
	- 먼저 수신된 부분부터 반영하기 시작하여 화면에 띄워줄 수 있게 되기 때문이다.
	- Next.js에서는 이 기술을 **Streaming**이라고 하여, **경로를 더 작은 "청크"로 나누어 서버에서 클라이언트로 점진적으로 스트리밍하는 데이터 전송 기술**이라고 소개하고 있다.
	- 이 기술을 사용해 **우선순위가 높은 컴포넌트를 먼저 작동**하게 해 줄 수 있기 때문에, 사용자는 모든 데이터가 로드될 때 까지 기다리지 않고, **페이지의 일부를 보고 상호작용**할 수 있게 된다.

- **Streaming** 기술 중 Suspense라는 것이 있다. 이는 동적 컴포넌트를 감쌀 수 있는 컴포넌트이며, 동적 컴포넌트가 로드되는 동안 보여줄 대체 컴포넌트를 전달할 수 있다.
	- 이는 응용 프로그램 일부의 렌더링 부분을, 일부 조건을 충족할 때까지 지연시킬 수 있다는 의미이다.
	- 정리하면, **Streaming** 기술 중 Suspense라는 것을 사용하면 **모든 데이터를 기다릴 필요 없이 먼저 그릴 수 있는 부분을 반영하여 뷰를 로드한 뒤, data fetch가 완료되면 그 결과가 즉각적으로 스트림에 반영**할 수 있다.

##### ※ 컴포넌트 단위 refetch
- 전통적인 SSR의 경우 완성된 HTML파일을 내려주기 때문에 작은 변경사항이 발생하더라도 전체 페이지를 전부 새로 그려서 받아와야 했다. 하지만 RSC를 사용하는 경우, 서버가 클라이언트에게 전달하는 최종 결과물이 직렬화(JSON)된 `stream` 형태라고 말했다.

- 그리고 클라이언트는 이 `stream`을 해석하여 **virtualDOM**을 형성하고, **Reconciliation**이라는 과정을 통해 뷰를 갱신한다.

- 이렇게 하면, 화면에 변경사항이 발생하여 서버에서 새로운 데이터를 받아와야 하더라도, 새로운 스크린으로 갈아끼우는 것이 아니라 기존 화면의 `state` 및 `context`를 유지한 채로 변경된 사항만 선택적으로 반영할 수 있게 된다.

---
#### 7. 더 알아보기 (SSR, SSG, ISR)

- SSG(Static Site Generation)은 Static Rendering이라고도 불리며, 서버에서 HTML을 보내준다는 차원에서는 SSR과 유사하지만, 언제 만들어지는지가 다르다.
##### ※ SSR
- SSR은 요청 시 서버에서 즉시 HTML을 만들어 응답하기 때문에, **데이터가 달라지거나 자주 바뀌어서 미리 만들어두기 어려운 페이지에 적합**하다.
##### ※ SSG
- SSG는 **빌드 시, 정적 페이지들을 모두 서버에 만들어둔 후 요청 시에 해당 페이지를 응답하는 것**이다. 
	- 때문에, 바뀔 일 없이 캐싱해두면 좋을 페이지에 사용하기 좋다.
##### ※ ISR
- SSG는 빌드 시에만 정적 페이지를 생성한다는 특징이 있다. 그러나, ISR는 이미 빌드된 웹에 정적 페이지를 새롭게 추가하거나, 업데이트(revalidate) 할 수 있도록 한다.

---
#### 8. 더 알아보기 (TTV, TTI)

- TTV(Time To View)
	- 사용자가 페이지를 요청한 이후로부터, 웹 브라우저에서 내용을 확인할 수 있을 때 까지의 시간 

- TTI(Time To Interact)
	- 사용자가 페이지를 요청한 이후로부터, 웹 브라우저에서 상호작용이 가능할 때까지의 시간 

- **CSR에서는 TTV와 TTI가 동일하다.**
	- 맨 처음에는 흰 화면이다가, 서버에서 빈 HTML과 자바스크립트를 다운로드 할 수 있는 링크를 받아와 클라이언트에서 측에서 자바스크립트를 모두 다운로드 하고, 실행함으로써 페이지 렌더링 과정을 마치면, 페이지 화면이 보임과 동시에 조작이 가능해지기 때문이다.

- **SSR에서는 TTV와 TTI가 다르다.** 
	- 서버에서 즉시 렌더링 가능한 HTML파일을 클라이언트가 받아온 후, 렌더링을 수행하면 화면이 먼저 그려진다. 
		- 이 때까지의 시점이 TTV이다.

	- 이후, HTML에 포함된 `script`태그를 통해 참조된 자바스크립트 번들 파일을 다운로드, 컴파일 및 실행이 완료된 후에 사용자와의 상호작용이 가능해진다.
		- 이 때까지의 시점이 TTI이다.

---
#### 9. 더 알아보기 (렌더링과 SPA & MPA)

##### 1. 이전까지의 렌더링 방식은?
- 예전에는 **SSR을 사용한 MPA방식**을 사용했다.
	- 페이지 이동마다 페이지를 재생성해야했기 때문에, 서버 부하가 존재했고, 사용자가 페이지를 이동할 때마다 초기에 흰 화면을 보는 문제가 있었다.

##### 2. React는?
-  React는 CSR을 사용한 SPA 방식을 사용한다.
	- 초기 로딩시간은 길지만, 초기 로딩 이후 페이지 전환이 빠르고 UX가 부드럽다. 
	- 그러나 SEO에 불리하다.

##### 3. Next.js는?
- Next.js 프레임워크가 등장하면서, SSR 렌더링 방식이 다시 대두되었다.
- 그러나, SSR방식이 다시 떠올랐다고 하더라도, Next.js를 활용하면 아래와 같은 렌더링 방식을 입맛에 맞게 사용할 수 있다.
	1. CSR (클라이언트 사이드 렌더링) : `useEffect`를 이용하거나, `SWR` 같은 상태관리 Tool을 이용해 렌더링의 책임을 사용자에게 전가할 수 있다. 화면 로딩이 사용자 눈에 보여 사용자 경험을 감소시키는 단점이 있다
    
	2. SSR (서버사이드 렌더링) : 렌더링의 책임이 **프론트엔드 서버**에게 주어지며, 웹사이트 사용자가 접속할때마다 새로운 페이지를 생성해내는 방식. 매번 최신 정보를 유지해야한다면 좋은 방식이긴 하지만, 성능상 이슈가 있고 화면 깜빡임 현상이 있다.
		- "**프론트엔드 서버**"는 SSR 방식에서 **동적으로 HTML을 생성하여 클라이언트로 전달**하는 서버를 의미한다.
		- 여기서의 "프론트엔드"는 페이지의 렌더링과 관련된 처리를 담당하는 서버를 지칭하는 것으로, 이 서버는 **페이지의 데이터를 실시간으로 처리하고** 사용자가 요청할 때마다 **동적으로 렌더링된 HTML**을 제공하는 역할을 수행한다.

    
	3. SSG (정적 생성) : **렌더링의 책임이 역시 프론트엔드 서버에게** 주어지지만, 프론트엔드 `build` 시간에 미리 화면에 대한 HTML을 미리 생성하여 사용자에게 미리 만들어진 화면을 제공한다. 이를 통해 성능상의 이점은 챙길 수 있으나, 미리 생성된 페이지를 제공하는 방식이기 때문에 페이지 내 데이터가 변화하더라도 **변화된 내용들을 전혀 제공해주지 못한다**.

- Next.js에서의 **SSG의 문제**가 보이는가?
	- 해당 SSG의 문제 상황 속에서 Next.js에서 성능 상의 이점은 챙기면서도 변화된 내용에 대한 업데이트를 제공해줄 수 있는 방식이 있는데, 이것이 **ISR**(Incremental Static Regeneration) 방식이다.
	- 즉, SSG 방식으로 미리 만들어놓은 사이트들도 필요하다면 업데이트가 가능하다는 이야기이다.
		- Data Fetch 시, `revalidate option(seconds)`를 추가해주면 된다.

##### 4. SPA(Single Page Application)
-  브라우저 내부에서 동작하는 앱으로, 사용하는 동안 페이지의 전환을 요구하지 않는다.
	-  Gmail, Google Maps, Facebook 같은 페이지가 대표적인 예시이다.

- 단, **하나의 페이지로 이루어진 애플리케이션**이다.
	- **하나의 HTML 파일을 기반으로, 자바스크립트를 이용해 동적으로 화면 컨텐츠를 바꾸는 방식**을 사용한다.
	- 맨 처음에만 서버로부터 정적 리소스(HTML, CSS, 자바스크립트)들을 받아오고, 이후에는 기존 페이지의 내부를 수정하면서 보여주는 특징이 있다.
		- 만약, 추가적인 데이터가 필요하면, **필요한 부분만 서버로부터 전달받아 화면을 갱신한다.**

- 주의해야할 점은, SPA는 모든 것을 자바스크립트로 처리하기 때문에 초기 HTML 파일에는 대부분 해당 웹을 작동시키기 위한 자바스크립트 파일만 포함되고 나머지 컨텐츠는 텅 비어 있다. 
	- 이 때문에, **웹 크롤러**가 맨 처음 페이지에 접근하였을 때 페이지 정보를 읽을 수 없어 SEO 측면에서 불리하다는 이야기가 나오는 것이다.

> 장점
1. 전체 페이지를 업데이트할 필요가 없으므로, 깜빡임 현상이 없다. (UX 유리)
2. 초기 로딩 이후에는, 필요한 리소스만 부분적으로 가져오면 되므로 성능상 유리하다 (MPA보다)
3. 컴포넌트 별 개발이 용이하기에, 생산성에서 뚜렷한 장점이 있다.

> 단점
1. 맨 처음에 전체 리소스를 받아오는 과정에서, 자바스크립트 파일을 번들링하여 한 번에 다운로드하기 때문에 초기 구동속도가 느리다.
	- 이 문제를 해결하기 위해, Webpack의 **코드 스플리팅** 기능이 있다고 한다.

2. SSR에서는 사용자 정보를 서버 측에서 세션으로 관리할 수 있지만, CSR방식에서는 클라이언트 쿠키, 웹 스토리지 등을 제외하고는 사용자 정보를 저장할 공간이 마땅치 않다. (보안 이슈가 있음)

3. 검색엔진 최적화가 어렵다.

##### 5. MPA(Multiple Page Application)
-  이름에서도 알 수 있듯, 화면마다 HTML이 존재한다.
	- **여러 개의 페이지로 구성된 애플리케이션**이다.

- 사용자가 페이지를 요청할 때마다 서버에서는 렌더링된 **정적 리소스(HTML ,CSS, JavaScript)** 를 전달하고, 클라이언트 측에서는 이를 다운로드한다.
	- 페이지를 이동하거나, 새로고침하면 전체 페이지를 다시 렌더링한다.

> 장점
1. 사용자가 보는 화면의 방식이 곧 **웹 크롤러가 보는 방식과 동일**하므로, SEO 관점에서 유리하다.
    - MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받으므로, 검색엔진이 페이지를 크롤링하기에 적합하다.
    
2. 첫 페이지 로딩 시간이 짧다.  
    - 서버에서는 이미 요청한 페이지를 렌더링하여 클라이언트에게 전달해주기 때문이다.
    - 그러나 클라이언트가 자바스크립트 파일을 모두 다운로드하고 적용하기 전까지는, 각 이벤트 기능이 동작하지 않는다.

> 단점
1. 새로운 페이지를 이동할 때매다, 매 페이지를 요청하기 때문에 깜빡이는 현상이 발생하여, UX에 불리하다.
2. 페이지를 이동할 때마다, 불필요한 **템플릿도 중복해서 로딩**하기 때문에 성능면에서 아쉽다.
3. 매 페이지마다 서버에서 정적 리소스를 전달해주어야 하므로, 서버에 비교적 많은 부하가 가해진다.


