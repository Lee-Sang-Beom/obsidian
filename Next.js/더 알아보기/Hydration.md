
### 1. Hydration이란?

- **Hydration**은 React와 같은 프레임워크에서 **서버에서 미리 렌더링된 HTML을 클라이언트에서 동적으로 연결**하여 React의 상태 관리와 이벤트 처리가 활성화되도록 하는 과정을 말한다. 
- 이를 통해 SSR(Server-Side Rendering)으로 생성된 정적 HTML이 클라이언트에서 React 앱으로 변환되어 동적인 UI와 상호작용을 지원할 수 있게 된다.

---
### 2. Hydration의 핵심 동작

1. **SSR로 정적 HTML 생성**:
    - 서버에서 React 컴포넌트가 렌더링되어 정적인 HTML로 변환된다.
	    - 이 때의 HTML은 React는 컴포넌트의 JSX(혹은 TSX) 구조를 활용하여 완성될 뿐 아니라, React 컴포넌트를 렌더링하면서, 각 컴포넌트의 **초기 상태값**과 **props**를 기반으로 **화면에 표시할 내용까지 포함하여 데이터를 채운 상태로 완성**된다.
	    - 즉 데이터까지 포함한 정적인 HTML이라는 것이다!
	
    - 이 HTML은 브라우저에 전달되며, 사용자가 페이지를 로드하면 초기 화면이 즉시 표시된다. 이를 통해 첫 화면 로딩 속도를 높일 수 있다.

2. **클라이언트로 HTML 전달**:
    - 브라우저는 서버에서 전달된 HTML을 DOM으로 렌더링하여 사용자에게 표시한다.
    - 이 시점의 HTML은 정적이며, 동적 상호작용(클릭, 입력, 상태 변경 등)은 아직 활성화되지 않은 상태이다.

3. **React 앱 초기화**:
    - 클라이언트에서 React의 JavaScript 번들이 로드된다.
    - React는 서버에서 렌더링된 HTML과 클라이언트의 React 컴포넌트 구조를 비교한다.
    - 이 과정을 통해 기존의 HTML DOM에 React의 이벤트 처리 및 상태 관리를 연결한다.

4. **이벤트 및 상태 활성화**:
    - 연결이 완료되면 React는 DOM을 제어하고, 사용자의 입력 및 상호작용에 반응할 수 있다.
    - 이 과정을 "Hydration"이라고 부른다.

---
### 3. Hydration의 필요성

- **초기 로딩 속도 개선**:
    - SSR을 통해 초기 HTML이 생성되므로, 사용자는 브라우저에서 빠르게 페이지를 볼 수 있다.
    - 이후 Hydration이 완료되면 동적인 상호작용이 가능해진다.

- **SEO(검색 엔진 최적화)**:
    - 검색 엔진은 HTML 콘텐츠를 크롤링하는데, 이 때 서버에서 렌더링된 HTML이 제공되면 SEO 성능이 향상된다.

- **React 생태계 통합**:
    - 클라이언트에서 React가 서버 렌더링된 HTML과 연결되므로 서버와 클라이언트 사이의 통합이 원활하게 이루어진다.

---
### 4. Hydration 동작 예시

> 서버 컴포넌트와 클라이언트 컴포넌트가 함께 동작하는 구조
```jsx
function ServerComponent() {
  return <div>서버에서 렌더링된 내용입니다.</div>;
}

function ClientComponent({ children }) {
  return <div onClick={() => alert('클릭 이벤트 활성화됨!')}>{children}</div>;
}

function App() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

1. **SSR 과정**:
	- `<ServerComponent />`는 서버에서 HTML로 렌더링된다.
	- `<ClientComponent />`는 서버에서 완전히 렌더링되지 않고, 클라이언트에서 JavaScript로 동작을 활성화해야 한다.  
		- 이 과정에서 **클라이언트 컴포넌트는 서버에서 단순한 "placeholder"로 렌더링**된다.
		- 즉, 클라이언트 컴포넌트의 기능(예: 클릭 이벤트 처리)은 서버에서 구현되지 않고 클라이언트에서 초기화된다.
	
	- 참고로, 서버에서 클라이언트 컴포넌트를 렌더링할 때, 해당 컴포넌트의 자리는 비워두는데, 이 상태를 **"placeholder"** 라고 표현한다.
		- 이 placeholder는 클라이언트에서 자바스크립트가 로드되고 실행되면, 실제 컴포넌트로 대체된다.
		- 서버에서 클라이언트 컴포넌트 렌더링 시, 해당 컴포넌트의 자리를 비워두는 이유는 **서버에서 HTML을 생성하지만, 클라이언트 컴포넌트의 로직(예: 이벤트 처리, 상태 관리)은 자바스크립트 없이 작동하지 않기 때문**에, 서버는 클라이언트 컴포넌트를 완전히 렌더링할 수 없으며, **자리만** 만들어둔 뒤, 클라이언트에서 실행되기를 기다린다.
		- 클라이언트 컴포넌트의 **"자리 비우기(placeholder)"** 는 Hydration(재활성화) 과정을 원활하게 하기 위한 것으로 클라이언트에서 자바스크립트가 로드되면, 이 placeholder에 컴포넌트가 "대체"되어 이벤트 처리 및 동적 로직이 활성화되는 것이다.

2. **Hydration 과정**:
    - 클라이언트에서 React의 JavaScript 코드가 로드되면, 서버에서 생성된 HTML에 React 컴포넌트와 상태 관리가 연결된다.
    - `<ClientComponent />`의 클릭 이벤트가 활성화된다.

3. **결과**:
    - 사용자가 화면을 볼 때는 서버에서 렌더링된 HTML이 표시된다.
    - 클릭 이벤트와 같은 동적 상호작용은 Hydration 후에 작동한다.

---
### 5. 서버 컴포넌트를 직접 클라이언트 컴포넌트에 넣을 때의 문제

- 다시 한번 아래 코드를 살펴보자.
```jsx
function ServerComponent() {
  return <div>서버에서 렌더링된 내용입니다.</div>;
}

function ClientComponent({ children }) {
  return <div onClick={() => alert('클릭 이벤트 활성화됨!')}>{children}</div>;
}

function App() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```
- **클라이언트 컴포넌트** 안에 **서버 컴포넌트를 직접 포함**하려고 하면 문제가 발생한다. 그 이유는 **서버 컴포넌트**는 **상호작용을 처리하지 않기** 때문에, **동적 처리**를 위한 클라이언트 컴포넌트 내에서 사용하기에 적합하지 않기 때문이다.
	- React는 **서버 컴포넌트를 클라이언트에서 직접 렌더링**할 수 없다고 간주하여, 직접 포함하는 사례의 경우에는 **에러**를 발생시킨다.

- 반면, React의 특수 프로퍼티인 `children`을 통해 서버 컴포넌트를 전달할 경우, 서버에서 HTML만 렌더링된 상태로 전달되고, 클라이언트에서 **hydration**이 진행된다. 이 과정에서 hydration 덕분에 클라이언트에서 상호작용을 처리할 수 있는 코드로 서버 컴포넌트가 감싸져 동적으로 처리될 수 있게 된다.
	- **`children`을 사용하는 방식**은 **서버 컴포넌트와 클라이언트 컴포넌트** 간의 **경계를 유연하게 처리**할 수 있는 방법으로 적용된다.

- 참고로, **`children`** 이란 **React 컴포넌트**에서 **동적으로 전달되는 자식 요소**를 의미한다. 이는 컴포넌트의 **구성 요소로서** 다른 컴포넌트를 포함할 수 있게 해준다.
	- **`children`** 은 부모 컴포넌트가 자식 컴포넌트를 **임의로** 받을 수 있도록 설계된 특수한 프로퍼티이다. 부모 컴포넌트는 이 프로퍼티를 통해 자식 컴포넌트를 **동적으로** 렌더링할 수 있게 된다.

---
### 6. Hydration의 한계

1. **Hydration 비용**:
    - 서버에서 생성된 HTML을 클라이언트에서 다시 분석하고 React와 연결하는 과정에서 성능 부담이 발생합니다.
    - 특히, 대규모 애플리케이션에서는 Hydration 시간이 길어질 수 있습니다.

2. **동기화 문제**:
    - 서버에서 렌더링된 HTML이 클라이언트에서 React 상태와 일치하지 않으면 경고나 렌더링 오류가 발생할 수 있습니다.

3. **JavaScript 의존성**:
    - Hydration은 클라이언트에서 JavaScript가 로드되어야만 작동합니다. 따라서 JavaScript 로딩이 지연되면 사용자가 상호작용할 수 있는 시점도 늦어집니다.

---
### 7. 결론

- Hydration은 서버에서 생성된 HTML을 클라이언트에서 React로 연결하는 필수 과정이다.
- 이를 통해 **SSR의 장점**(빠른 초기 로딩, SEO)과 **CSR의 장점**(동적 상호작용, 상태 관리)을 결합할 수 있다.
- 다만, 성능 최적화를 위해 필요에 따라 부분 Hydration이나 서버 컴포넌트 구조를 활용하는 것이 중요하다.

---

### 8. ``ReactDOM.hydrate()`

> `ReactDOM.hydrate()`
- `ReactDOM.hydrate()`가 뭘까?
	- `ReactDOM.hydrate()`는 **서버 측 렌더링(SSR)** 에서 **서버에서 렌더링된 HTML을 클라이언트에서 React 애플리케이션으로 "상호작용 가능하게" 만드는** 데 사용된다.

- 동작
	- 서버에서 HTML을 렌더링하여 클라이언트에 보내면, 클라이언트에서는 `hydrate()`가 호출되어 **서버에서 이미 렌더링된 HTML 마크업**이 React의 **Virtual DOM**과 맞춰지면서, **React가 관리하는 동적인 컴포넌트 트리**로 변환되게 된다.
	- 기존 HTML과 React 앱이 동일한 마크업을 가지고 있을 때, `hydrate()`는 React가 이미 있는 HTML을 덮어쓰지 않고, **React의 이벤트 리스너와 상태**를 동적으로 추가한다. 즉, 서버에서 렌더링된 HTML을 React 컴포넌트에 연결한다고 볼 수 있다.

 - 역할
	1. **서버에서 렌더링된 HTML을 재사용**:  
		- 서버에서 `ReactDOMServer`를 사용해 생성된 HTML이 클라이언트 브라우저에 전달된다.  
	    - 브라우저는 이 HTML을 화면에 그린 후, React는 이 HTML 구조를 그대로 유지하면서 이벤트 리스너나 컴포넌트 상태를 React의 Virtual DOM과 연결(=Hydration)한다.
    
	2. **최소한의 DOM 변경**:  
	    - `hydrate()`는 서버에서 렌더링된 HTML과 React의 Virtual DOM을 비교해 필요한 부분만 업데이트한다.  
	    - 즉, 서버가 전달한 HTML을 버리지 않고, 재활용하여 성능을 최적화한다.
