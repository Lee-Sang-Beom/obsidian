### 출처

> 본 내용은 [타락한스벨트전도사](https://velog.io/@k-svelte-master/posts)님의 포스트를 바탕으로 정리한 글입니다.

---
### 1. CSR, SSR, Hydration

#### 1-1. CSR(Client-Side Rendering)이란?
- CSR은 브라우저가 HTML과 JavaScript 번들을 서버로부터 받아 렌더링하는 방식이다.
	- 이 방식에서는 웹 애플리케이션의 페이지가 **서버에서 HTML을 미리 렌더링하지 않고**, 대신 **브라우저에서 자바스크립트를 사용하여 동적으로 HTML을 생성**하는 방식을 사용한다.

- React 앱의 경우, 서버로부터 비어 있는 `<div id="root"></div>`만 전달받고, 브라우저에서 JavaScript가 로드된 후 화면이 렌더링된다.

> **동작 원리**
1. 초기 요청
	- 사용자가 웹 페이지를 요청하면, 서버는 **빈 HTML 파일**과 **자바스크립트 번들**을 브라우저에 전달한다.
    - 이 HTML 파일에는 **최초의 HTML 구조**만 포함되고, 실제 콘텐츠는 자바스크립트가 로드된 후에 클라이언트에서 렌더링된다.
      
2. 자바스크립트 실행
	- 브라우저는 자바스크립트 파일을 다운로드하고, 실행한다.
    - 이 때 **React**, **Vue**, **Angular** 같은 자바스크립트 프레임워크/라이브러리가 브라우저 내에서 DOM을 생성하고 업데이트한다.
      
3. 동적 콘텐츠 생성
	- 자바스크립트가 실행되면, **API 요청** 등을 통해 필요한 데이터를 가져오고, 그 데이터를 바탕으로 **동적으로 콘텐츠**를 화면에 표시한다.
    - 이 방식은 **상호작용**이 중요한 애플리케이션에서 유용한데, 버튼 클릭 시 UI가 동적으로 업데이트되거나, 사용자 입력에 따라 화면이 변하는 경우가 그 예시이다.

>**CSR의 문제점**:
1. 초기 화면이 비어 있어 사용자 경험(UX)이 저하된다.
2. SEO가 어려워 검색엔진에서 페이지가 낮게 평가될 가능성이 있다.

#### 1-2. SSR(Server-Side Rendering)이란?
- SSR은 서버에서 React 컴포넌트를 HTML로 변환한 뒤 브라우저에 전달하는 방식이다.
	- 이 방식에서는 웹 페이지의 콘텐츠가 **서버에서 미리 렌더링되어** 클라이언트(브라우저)로 전송되며, 클라이언트는 이미 렌더링된 HTML을 받아 바로 화면에 표시할 수 있다.

- 브라우저는 전달받은 HTML을 즉시 표시하고, 이후 Hydration 과정을 통해 대화형 인터페이스를 활성화한다.

> **동작 원리**
1. 사용자 요청
	- 사용자가 웹 페이지를 요청한다.
      
2. 서버 렌더링
	- 서버는 요청을 받은 후, 웹 페이지의 **HTML을 서버에서 미리 렌더링**한다.
	- 서버에서 필요한 데이터를 가져오고, **템플릿 엔진**(예: **React**, **Vue.js** 등)을 사용해 **완전한 HTML**을 생성한다.
	- 이 과정에서 모든 자바스크립트 코드가 서버에서 실행되어 **최초의 HTML 페이지**를 생성한다.
		- 하지만 이때 실행되는 자바스크립트는 페이지의 **초기 HTML을 생성**하는 데만 사용된다. (서버에서 페이지의 HTML을 생성하기 위해 자바스크립트를 사용한다는 의미)
		- 서버에서는 사용자의 상호작용을 처리할 수 없고, 그저 **정적인 HTML**을 생성한다.
	- 예: `ReactDOMServer.renderToString()`을 사용하여 HTML을 생성 (서버 측 렌더링(SSR)에서 사용되며, React 컴포넌트를 HTML 문자열로 변환하는 메소드로, **완전한 HTML 마크업으로 변환**하여 반환하기 위해 사용됨)
		- `render()`는 React **클라이언트 애플리케이션**에서 컴포넌트를 **DOM**에 렌더링하는 메서드라 헷갈리면 안된다.
			- 이 메소드는 클라이언트 측 렌더링(CSR)에서 사용되며, 반환되는 값은 **React 엘리먼트**(JSX 형태)로 이 값은 실제 DOM에 반영된다.

| 항목    | renderToString()                       | render()                       |
| ----- | -------------------------------------- | ------------------------------ |
| 용도    | 서버 측 렌더링(SSR)용 HTML 문자열 생성             | 클라이언트 측 렌더링 (DOM에 실제 컴포넌트 렌더링) |
| 반환 값  | HTML 문자열 (예: `<div>Hello World</div>`) | React 엘리먼트 (예: React 컴포넌트 객체)  |
| 용도 예시 | 서버에서 HTML을 미리 렌더링하여 클라이언트에 전달          | 클라이언트에서 컴포넌트를 실제 DOM에 렌더링      |
| 결과    | 서버에서 렌더링된 HTML을 클라이언트가 받아서 표시          | 클라이언트에서 실제 DOM에 컴포넌트를 렌더링      |

3. HTML 응답 전송
	- 서버는 완성된 HTML을 클라이언트로 전송한다.
    - 클라이언트는 서버에서 전달받은 HTML을 **즉시 렌더링**하고 화면에 표시한다.
    - 이 HTML은 이미 **완성된 콘텐츠**를 포함하고 있어, 사용자에게 빠르게 표시된다.

4. 클라이언트 자바스크립트 실행
	- 서버에서 HTML을 받은 후, **클라이언트 측 자바스크립트**(React, Vue.js 등)는 클라이언트에서 실행되기 시작하는데, 이 과정을 **Hydration**이라고 부른다.
    - Hydration은 서버에서 렌더링된 HTML에 **클라이언트 측 자바스크립트**를 연결하여, **대화형 요소들**을 활성화시키는 과정이다. 예를 들어, 버튼 클릭, 입력 필드의 변경 등이 동작하도록 한다.
	    - 클라이언트 측 자바스크립트는 **Hydration** 과정에서 활성화된다. 서버 렌더링 과정에서 실행된 자바스크립트 코드와는 다르다.
	    - 즉, 서버에서 보내준 HTML을 기반으로 **동적 상호작용을 처리**하고, React 같은 프레임워크에서 정의된 **상태 관리와 이벤트 처리**를 클라이언트에서 실행한다.

>**SSR의 장점**:
1. 사용자는 페이지 로드 시 콘텐츠가 포함된 HTML을 바로 볼 수 있다.
2. SEO 최적화에 유리하다.

>**SSR 과정**:
1. 서버에서 HTML 생성
2. 클라이언트에 전달
3. 브라우저에서 JavaScript 로드 후 Hydration 실행

#### 1-3. Hydration
- Hydration은 SSR로 전달받은 정적 HTML을 React의 가상 DOM(Virtual DOM)과 연결하고, 이벤트 핸들러와 상태를 주입하는 과정이다.
	- Hydration을 통해 HTML은 대화형 UI로 변환된다.

- 즉, SSR을 통해 미리 ***형태만 있는*** HTML을 받아온 뒤, 자바스크립트가 로드되고 `hydrate()`가 실행되면 이 HTML 구조 위에 이벤트와 상태 관리 로직이 활성화되는 것이다.

>**Hydration의 과정**:
1. 서버에서 생성된 HTML이 브라우저에 표시
2. 브라우저에서 JavaScript 로드
3. React의 `hydrate()`가 실행되어 VDOM과 HTML 매칭
4. 이벤트 핸들러 및 상태 활성화

#### 1-4. `render() / ReactDOM.hydrate()`
| 함수                   | 사용 시점 및 목적                                             | 특징                        |
| -------------------- | ------------------------------------------------------ | ------------------------- |
| `ReactDOM.render()`  | 클라이언트 측 렌더링에서 처음 렌더링할 때 사용.                            | DOM에 React 컴포넌트 트리 마운트    |
| `ReactDOM.hydrate()` | 서버 측 렌더링(SSR)에서 서버 렌더링 HTML을 React로 상호작용 가능하게 만들 때 사용. | 서버에서 렌더링된 HTML을 React와 연결 |
| `render()`           | 클래스형 컴포넌트 내에서 컴포넌트의 JSX를 반환할 때 사용.                     | JSX 반환 (상태 변경 시 재호출)      |

> `render()` (`ReactDOM.render()` 아님)
- `render()`는 **React 컴포넌트 내에서** 사용되는 **메서드**로, **컴포넌트의 JSX를 반환**한다.
	- 컴포넌트의 상태(state)나 속성(props)이 변경되면, 해당 컴포넌트의 `render()` 메서드가 호출되어, **새로운 JSX를 반환**한다. 
	- 이는 `ReactDOM.render()` 또는 `ReactDOM.hydrate()`와 달리, 실제로 **React가 컴포넌트를 어떻게 렌더링할지 결정하는** 메서드이다.

- 동작
	- `render()`는 **클래스형 컴포넌트에서만 사용**되며, 함수형 컴포넌트는 JSX를 반환하는 함수로 `render()` 메서드를 대체한다.

- **React의 큰 특징 중 하나**는 Virtual DOM이다.
	- 만약 DOM에 변경사항이 발생한다면, 변경 이전과 변경 이후의 Virtual DOM끼리 비교하는 과정이 발생하여 바뀐 부분만 실제 DOM에 적용할 수 있게 된다.  
	- 이 과정은 React의 Reconciliation 과정에서 실행되며, 효율적인 업데이트를 위해 React의 DOM diffing 알고리즘을 사용한다.  
	- **따라서,** `ReactDOM.render()`를 통해 매번 새로운 웹 페이지를 구성할 DOM을 생성하는 것이 아니라는 의미이다.
		- 대신에, 컴포넌트의 **새로운 UI**를 반환하기 위해, 컴포넌트의 상태(state)나 속성(props) 변경에 따라 업데이트가 필요하면 **새로운 Virtual DOM**을 생성하고, 기존 Virtual DOM과 비교하여 **변경된 부분만** 실제 DOM에 반영되는 **Reconciliation**과정이 발생한다.

> `ReactDOM.hydrate()`
- 그럼, `ReactDOM.hydrate()`는 뭘까?
	- `ReactDOM.hydrate()`는 **서버 측 렌더링(SSR)** 에서 **서버에서 렌더링된 HTML을 클라이언트에서 React 애플리케이션으로 "상호작용 가능하게" 만드는** 데 사용된다.

- 동작
	- 서버에서 HTML을 렌더링하여 클라이언트에 보내면, 클라이언트에서는 `hydrate()`가 호출되어 **서버에서 이미 렌더링된 HTML 마크업**이 React의 **Virtual DOM**과 맞추어, **React가 관리하는 동적인 컴포넌트 트리**로 변환되게 된다.
	- 기존 HTML과 React 앱이 동일한 마크업을 가지고 있을 때, `hydrate()`는 React가 이미 있는 HTML을 덮어쓰지 않고, **React의 이벤트 리스너와 상태**를 동적으로 추가한다. 즉, 서버에서 렌더링된 HTML을 React 컴포넌트에 연결한다고 볼 수 있다.

 - 역할
	1. **서버에서 렌더링된 HTML을 재사용**:  
		- 서버에서 `ReactDOMServer`를 사용해 생성된 HTML이 클라이언트 브라우저에 전달된다.  
	    - 브라우저는 이 HTML을 화면에 그린 후, React는 이 HTML 구조를 그대로 유지하면서 이벤트 리스너나 컴포넌트 상태를 React의 Virtual DOM과 연결(=Hydration)한다.
    
	2. **최소한의 DOM 변경**:  
	    - `hydrate()`는 서버에서 렌더링된 HTML과 React의 Virtual DOM을 비교해 필요한 부분만 업데이트한다.  
	    - 즉, 서버가 전달한 HTML을 버리지 않고, 재활용하여 성능을 최적화한다.

---
### 2. 서버 컴포넌트 vs 클라이언트 컴포넌트

- React 18 이후 등장한 서버 컴포넌트는 "서버에서만 동작하는 컴포넌트"라는 새로운 패러다임을 제시했다. Next.js의 모든 컴포넌트는 기본적으로 서버 컴포넌트이며, 클라이언트에서 동작해야 하는 컴포넌트만 `use client`를 명시적으로 선언하게 되었다.

- 서버 컴포넌트는 ***HTML 스니펫(특정 기능이나 콘텐츠를 나타내는 간단한 HTML 구조) 형태로 클라이언트에 전달되며, Hydration 대상에서 제외된다.***
	- 즉, 서버 컴포넌트가 반환하는 HTML은 "그대로" 브라우저에 삽입될 뿐, 클라이언트 측에서 사용되던 이벤트 핸들러나 `state` 등이 주입되지 않는다.
	- 때문에 서버 컴포넌트는 자바스크립트 번들을 거의 소비하지 않고, 성능 최적화에 큰 도움이 된다.

- 반면 `use client`를 선언한 클라이언트 컴포넌트는 기존 React 컴포넌트처럼 동작한다.
	- 해당 동작 방식은, SSR을 통해 초기 HTML을 생성하고, 이후 Hydartion 과정을 거쳐 인터랙션을 활성화하는 방식이다. 
	- 따라서 `use client` 컴포넌트도 SSR이 가능하며, SSR + CSR을 연계한 Hydration 프로세스를 지원한다.

>**서버 컴포넌트(Server Components)**
- 서버에서 React 컴포넌트를 HTML 코드로 렌더링한 다음 클라이언트로 전달한다.
	- 이 때, 서버에서 React 컴포넌트를 실행하고, 그 결과를 HTML 문자열로 변환한다. (이 과정은 클라이언트가 아닌 서버에서 모든 렌더링 로직이 처리됨을 의미)
	- 결과적으로, 서버 컴포넌트에서 이미 렌더링이 완료된 상태로 클라이언트로 HTML이 전달되므로, 클라이언트에서 새로 렌더링할 필요가 없다.

- Hydration 대상이 아니므로 번들 크기가 줄어든다.
- 데이터베이스 접근, 파일 시스템 작업 등 서버에서만 가능한 작업 처리에 적합하다.

>**클라이언트 컴포넌트(Client Components)**
- `use client`로 선언한 컴포넌트만 클라이언트에서 실행된다.
- SSR로 초기 HTML을 생성한 뒤, Hydration을 통해 대화형 UI를 활성화한다.

---

### 3. 클라이언트 컴포넌트(`use client`)에서 발생하는 SSR + CSR 연계
#### 3-1. SSR + CSR의 연계
- `use client`는 **클라이언트 컴포넌트를 지정**하는 방식인데, 이 컴포넌트는 **SSR과 CSR을 결합한 방식**으로 동작한다.

 >**SSR (서버 측 렌더링)**
- 서버는 **초기 HTML을 렌더링**해서 브라우저에 전달합니다.
    - 예를 들어, React 서버 측에서 `use client`로 지정된 컴포넌트의 **초기 구조와 데이터**를 포함한 HTML을 생성하고 이 HTML이 클라이언트에 전달된다.
    - 이 때, 컴포넌트는 **정적 콘텐츠**만 포함되며, 브라우저에서 HTML을 바로 렌더링할 수 있는 상태이다.

> **CSR (클라이언트 측 렌더링)**
- **클라이언트는 자바스크립트 번들**(React 컴포넌트 코드 등)을 다운로드한 뒤, **Hydration** 과정을 시작합니다.
    - 이 과정에서 **React는 서버에서 받은 정적 HTML을** React의 Virtual DOM과 비교하고, **동적 기능**을 활성화한다.
    - 이때 **CSR이 연계**되어 클라이언트 측에서 대화형 UI를 만드는 과정이 진행된다.

#### 3-2. CSR이 연계된 부분
- `use client` 지시어가 붙은 컴포넌트는 **SSR로 HTML을 서버에서 먼저 렌더링**하지만, 클라이언트 측에서는 **CSR로 동작**하면서 페이지의 상호작용을 처리한다.
	- 즉, **HTML을 서버에서 생성하고, 클라이언트에서 동적으로 상태를 업데이트하거나 이벤트를 처리**하는 방식이다.

- **SSR**로 초기 HTML을 전달받은 후:
    1. **서버에서 정적 HTML**을 렌더링하여 클라이언트에 전달.
    2. 클라이언트는 **자바스크립트 파일**을 로드하여 React 컴포넌트가 서버에서 만든 HTML을 **대화형으로 변환**합니다.
- 이때 **CSR**은 JavaScript가 실행되어 **상호작용**이 가능한 UI로 변환되는 부분입니다. 예를 들어, 버튼 클릭, 입력 상자, 동적 데이터 로딩 등을 처리하는 부분이 CSR에 해당합니다.

#### 3-3. 요약
- **SSR**: 서버에서 HTML을 먼저 렌더링하여 클라이언트로 전달.
- **CSR**: 클라이언트에서 JavaScript가 로드되어 상호작용 가능한 UI로 변환.
- `use client` 컴포넌트는 **서버에서 HTML을 렌더링**하고, 클라이언트에서 **JavaScript로 동적 상호작용**을 처리하기 때문에 **SSR과 CSR이 결합**되어 작동합니다.
- Hydration 과정은 SSR로 받은 HTML을 **CSR로 동작하도록 변환**하는 단계입니다.

따라서 `use client` 컴포넌트에서는 **SSR로 초기 HTML을 생성**하고, **CSR로 이후 동적 기능을 활성화**하여 대화형 페이지가 만들어집니다.

---
### 4. 서버 컴포넌트의 등장 이전

- 서버 컴포넌트가 없던 시절, React 컴포넌트는 모두 클라이언트에서 Hydration 과정을 거쳐야 했다.
	- SSR을 하더라도 결국 클라이언트에선 모든 컴포넌트가 자바스크립트로 다시 로직을 주입받아야 했다.
	- 이 때문에 대규모 앱에서는 번들 사이즈가 커지고, 초기 로딩 시간이 길어질 수밖에 없었다.

- 서버 컴포넌트 도입 이후, "화면에 표시만 하면 되는 정적 부분"은 별도의 선언 없이 서버 컴포넌트로 처리하고, 상호작용이 필요한 부분만 `use client`로 선언하여 클라이언트 컴포넌트로 만들 수 있게 되었다.
	- 예를 들어 마크다운을 HTML로 렌더링하거나, 파일 시스템이나 DB 접근을 통해 결과를 HTML로 만든 뒤 클라이언트에 넘기는 작업은 서버 컴포넌트가 담당하고, **사용자 이벤트 처리나 상태 관리 같은 상호작용 부분은 클라이언트 컴포넌트(`use client`)에 맡기는 식**이다.
	- 이렇게 역할을 분리하면 성능 최적화가 용이해진다.

---
### 5. 면접 질문 대비: "use client도 SSR을 하나요?"

> 예상 질문:
- "Next.js에서 `use client`를 선언한 컴포넌트는 SSR이 가능한가요?"

> 모범 답변:
- "`use client` 컴포넌트는 클라이언트에서 동작하지만, SSR로 초기 HTML을 서버에서 렌더링한 뒤 클라이언트에서 Hydration 과정을 거쳐 대화형 UI로 완성됩니다. 
- 즉, `use client` 컴포넌트도 SSR이 가능합니다. 반면 서버 컴포넌트는 Hydration 과정을 거치지 않고, 순수 HTML만 전달되어 번들 크기를 줄이고 성능을 최적화할 수 있습니다!"

---
### 6. 서버 컴포넌트와 SSR의 관계의 오해

- 서버 컴포넌트는 SSR을 대체하는 것이 아니라, 기존에 클라이언트 컴포넌트만 있었을 시절의 고질적인 문제중 하나였던 문제를 해결하기 위해 등장한 기술이라는 것이다.
	- 예전에는 모든 컴포넌트가 클라이언트 컴포넌트였고, SSR방식으로 정적 HTML코드를 클라이언트 코드가 서버로부터 전달받으면 **Hydration 과정**이 이루어졌다.
	
	- 문제는, 이 Hydration 과정이 당시, 서버 컴포넌트가 존재하지 않았기에 모든 컴포넌트에서 이루어졌다는 것인데, 기본적으로 Hydration 과정이 포함되면 번들 사이즈가 커지게 된다.
		- **번들 사이즈가 커진다는 말의 의미**는 클라이언트(브라우저)가 서버로부터 다운로드받아 실행해야 하는 **자바스크립트 파일의 크기가 증가**한다는 뜻이다. 이는 브라우저가 대화형 UI를 렌더링하고 작동하게 만들기 위해 더 많은 데이터를 처리해야 한다는 것을 의미한다.
	
	- 번들 사이즈가 커지는 이유는 서버에서 미리 렌더링된 HTML을 클라이언트에서 대화형(UI에 반응하는) 상태로 전환하기 위해 필요한 **React의 자바스크립트 코드**가 추가로 다운로드되고 실행되기 때문이다.

- SSR은 초기 로딩 시, 서버로부터 전달받은 HTML 코드를 기반으로 **사용자에게 즉시 콘텐츠를 보여주는 데 초점을 맞추는 기술**이고, 서버 컴포넌트는 대화형 동작이 필요없는 페이지 혹은 페이지 부분을 Hydration이 일어나지 않도록 할 수 있도록 하여 번들 사이즈를 줄여줌과 함께, 데이터 fetching 최적화를 위해 제공된 또 다른 기술일 뿐이다.
	- 결국 SSR과 서버컴포넌트는 상반 관계라기보다는 최적화를 위한 **상호 관계**라고 보는 것이 옳다.

>※ **정리 및 요약**
> - SSR로 해결할 수 없었던 클라이언트 번들 크기 문제를 보완하기 위해 등장한 것이 서버 컴포넌트이며, 상호작용을 위해 Hydration을 수행할 필요가 없는 정적 부분은 서버 컴포넌트에서, 그 외는 클라이언트 컴포넌트에서 처리함으로써 최적화가 가능해졌다.
> - `'use client'` 지시어가 포함된 클라이언트 컴포넌트에서는 SSR방식으로 서버에서 렌더링하여 반환받은 초기 HTML 코드를 그대로 표시한 뒤, 서버에서 다운로드받은 자바스크립트 파일을 이용해 `Hydration` 과정을 거쳐 대화형 페이지로 전환되는 과정을 거친다.