> 이번 내용은 **([타락한스벨트전도사](https://velog.io/@k-svelte-master/posts)**)님의 포스트를 출처로 하여, 내용을 정리한 글임을 알립니다. 


### 1. CSR, SSR, Hydration

#### 1-1. CSR(Client-Side Rendering)이란?
- CSR은 브라우저가 HTML과 JavaScript 번들을 서버로부터 받아 렌더링하는 방식이다.
- React 앱의 경우, 서버로부터 비어 있는 `<div id="root"></div>`만 전달받고, 브라우저에서 JavaScript가 로드된 후 화면이 렌더링된다.

**CSR의 문제점**:
1. 초기 화면이 비어 있어 사용자 경험(UX)이 저하된다.
2. SEO가 어려워 검색엔진에서 페이지가 낮게 평가될 가능성이 있다.

#### 1-2. SSR(Server-Side Rendering)이란?
- SSR은 서버에서 React 컴포넌트를 HTML로 변환한 뒤 브라우저에 전달하는 방식이다.
- 브라우저는 전달받은 HTML을 즉시 표시하고, 이후 Hydration 과정을 통해 대화형 인터페이스를 활성화한다.

**SSR의 장점**:
1. 사용자는 페이지 로드 시 콘텐츠가 포함된 HTML을 바로 볼 수 있다.
2. SEO 최적화에 유리하다.

**SSR 과정**:
1. 서버에서 HTML 생성
2. 클라이언트에 전달
3. 브라우저에서 JavaScript 로드 후 Hydration 실행

#### 1-3. Hydration
- Hydration은 SSR로 전달받은 정적 HTML을 React의 가상 DOM(Virtual DOM)과 연결하고, 이벤트 핸들러와 상태를 주입하는 과정이다.
	- Hydration을 통해 HTML은 대화형 UI로 변환된다.

- 즉, SSR을 통해 미리 "형태만 있는" HTML을 받아온 뒤, 자바스크립트가 로드되고 `hydrate()`가 실행되면 이 HTML 구조 위에 이벤트와 상태 관리 로직이 활성화되는 것이다.

**Hydration의 과정**:
1. 서버에서 생성된 HTML이 브라우저에 표시
2. 브라우저에서 JavaScript 로드
3. React의 `hydrate()`가 실행되어 VDOM과 HTML 매칭
4. 이벤트 핸들러 및 상태 활성화

---
### 2. 서버 컴포넌트 vs 클라이언트 컴포넌트

- React 18 이후 등장한 서버 컴포넌트는 "서버에서만 동작하는 컴포넌트"라는 새로운 패러다임을 제시했다. Next.js의 모든 컴포넌트는 기본적으로 서버 컴포넌트이며, 클라이언트에서 동작해야 하는 컴포넌트만 `use client`를 명시적으로 선언하게 되었다.

- 서버 컴포넌트는 ***HTML 스니펫(특정 기능이나 콘텐츠를 나타내는 간단한 HTML 구조) 형태로 클라이언트에 전달되며, Hydration 대상에서 제외된다.***
	- 즉, 서버 컴포넌트가 반환하는 HTML은 "그대로" 브라우저에 삽입될 뿐, 클라이언트 측에서 사용되던 이벤트 핸들러나 `state` 등이 주입되지 않는다.
	- 때문에 서버 컴포넌트는 자바스크립트 번들을 거의 소비하지 않고, 성능 최적화에 큰 도움이 된다.

- 반면 `use client`를 선언한 클라이언트 컴포넌트는 기존 React 컴포넌트처럼 동작한다.
	- 해당 동작 방식은, SSR을 통해 초기 HTML을 생성하고, 이후 Hydartion 과정을 거쳐 인터랙션을 활성화하는 방식이다. 
	- 따라서 `use client` 컴포넌트도 SSR이 가능하며, SSR + CSR을 연계한 Hydration 프로세스를 지원한다.

#### 서버 컴포넌트(Server Components)
- 서버에서 React 컴포넌트를 HTML 코드로 렌더링된 뒤 클라이언트로 전달한다.
- Hydration 대상이 아니므로 번들 크기가 줄어든다.
- 데이터베이스 접근, 파일 시스템 작업 등 서버에서만 가능한 작업 처리에 적합하다.

#### 클라이언트 컴포넌트(Client Components)
- `use client`로 선언한 컴포넌트만 클라이언트에서 실행된다.
- SSR로 초기 HTML을 생성한 뒤, 하이드레이션을 통해 대화형 UI를 활성화한다.

---
### 3. 서버 컴포넌트의 등장 이전

- 서버 컴포넌트가 없던 시절, React 컴포넌트는 모두 클라이언트에서 Hydration 과정을 거쳐야 했다.
	- SSR을 하더라도 결국 클라이언트에선 모든 컴포넌트가 자바스크립트로 다시 로직을 주입받아야 했다.
	- 이 때문에 대규모 앱에서는 번들 사이즈가 커지고, 초기 로딩 시간이 길어질 수밖에 없었다.

- 서버 컴포넌트 도입 이후, "화면에 표시만 하면 되는 정적 부분"은 별도의 선언 없이 서버 컴포넌트로 처리하고, 상호작용이 필요한 부분만 `use client`로 선언하여 클라이언트 컴포넌트로 만들 수 있게 되었다.
	- 예를 들어 마크다운을 HTML로 렌더링하거나, 파일 시스템이나 DB 접근을 통해 결과를 HTML로 만든 뒤 클라이언트에 넘기는 작업은 서버 컴포넌트가 담당하고, 사용자 이벤트 처리나 상태 관리 같은 상호작용 부분은 클라이언트 컴포넌트(`use client`)에 맡기는 식이다.
	- 이렇게 역할을 분리하면 성능 최적화가 용이해진다.

---
### 4.면접 질문 대비: "use client도 SSR을 하나요?"

> 예상 질문:
- "Next.js에서 `use client`를 선언한 컴포넌트는 SSR이 가능한가요?"

> 모범 답변:
- "`use client` 컴포넌트는 클라이언트에서 동작하지만, SSR로 초기 HTML을 서버에서 렌더링한 뒤 클라이언트에서 Hydration 과정을 거쳐 대화형 UI로 완성됩니다. 
- 즉, `use client` 컴포넌트도 SSR이 가능합니다. 반면 서버 컴포넌트는 Hydration 과정을 거치지 않고, 순수 HTML만 전달되어 번들 크기를 줄이고 성능을 최적화할 수 있습니다!"

---
### 5. 서버 컴포넌트와 SSR의 관계의 오해

- 서버 컴포넌트는 SSR을 대체하는 것이 아니라, 기존에 클라이언트 컴포넌트만 있었을 시절의 고질적인 문제중 하나였던 문제를 해결하기 위해 등장한 기술이라는 것이다.
	- 예전에는 모든 컴포넌트가 클라이언트 컴포넌트였고, SSR방식으로 정적 HTML코드를 클라이언트 코드가 서버로부터 전달받으면 **Hydration 과정**이 이루어진다.
	  
	- 문제는, 이 Hydration 과정이 당시, 서버 컴포넌트가 존재하지 않았기에 모든 컴포넌트에서 이루어졌다는 것인데, 기본적으로 Hydration 과정이 포함되면 번들 사이즈가 커지게 된다.
		- **번들 사이즈가 커진다는 말의 의미**는 클라이언트(브라우저)가 서버로부터 다운로드받아 실행해야 하는 **자바스크립트 파일의 크기가 증가**한다는 뜻이다. 이는 브라우저가 대화형 UI를 렌더링하고 작동하게 만들기 위해 더 많은 데이터를 처리해야 한다는 것을 의미한다.
	
	- 번들 사이즈가 커지는 이유는 서버에서 미리 렌더링된 HTML을 클라이언트에서 대화형(UI에 반응하는) 상태로 전환하기 위해 필요한 **React의 자바스크립트 코드**가 추가로 다운로드되고 실행되기 때문이다.

- SSR은 초기 로딩 시, 서버로부터 전달받은 HTML 코드를 기반으로 **사용자에게 즉시 콘텐츠를 보여주는 데 초점을 맞추는 기술**이고, 서버 컴포넌트는 대화형 동작이 필요없는 페이지 혹은 페이지 부분을 Hydration이 일어나지 않도록 할 수 있도록 하여 번들 사이즈를 줄여줌과 함께, 데이터 fetching 최적화를 위해 제공된 또 다른 기술일 뿐이다.
	- 결국 SSR과 서버컴포넌트는 상반 관계라기보다는 최적화를 위한 **상호 관계**라고 보는 것이 옳다.