### 기본 `fetch()`와 Next.js의 차이점:

- **브라우저의 `fetch`**는 요청이 어떻게 브라우저의 HTTP 캐시와 상호작용할지 정의하는 옵션을 제공합니다.
- **Next.js의 확장된 `fetch`**는 서버 측에서 **데이터 캐시**와의 상호작용 방식을 제어하는 `cache` 옵션을 추가합니다. 이를 통해 서버에서 요청을 어떻게 처리할지 설정할 수 있습니다.

### `fetch` 함수 사용 예시


```ts
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```
위 예시에서는 `fetch()`를 사용하여 외부 API에서 데이터를 가져오고 이를 화면에 표시하는 페이지를 작성했습니다. 이때 **`fetch`**를 사용할 때 **`cache` 옵션**을 설정하여 요청이 **Next.js의 데이터 캐시**와 어떻게 상호작용할지를 제어할 수 있습니다.

### `cache` 옵션의 설명:

`fetch`에서 **`cache` 옵션**은 서버에서 요청된 데이터를 **Next.js의 데이터 캐시**와 어떻게 처리할지 설정하는 것입니다. 아래는 가능한 값입니다:

1. **`auto` (기본값)**:
    
    - **개발 모드**에서는 매번 원격 서버에서 리소스를 가져옵니다.
    - **배포 모드**에서는 정적 사이트 생성(SSG) 경로가 미리 빌드되므로, 해당 경로는 한 번만 서버에서 데이터를 가져오고 이후 요청에서는 캐시된 데이터를 사용합니다.
    - 동적 API가 감지되면, 모든 요청에서 서버로부터 데이터를 가져옵니다.
2. **`no-store`**:
    
    - **매 요청마다** 원격 서버에서 데이터를 가져옵니다.
    - **동적 API가 감지되지 않더라도**, 데이터를 캐시하지 않고 매번 서버에서 **최신 데이터를 가져옵니다**. 이 설정은 **캐시를 사용하지 않**고, 항상 최신 데이터를 요청하는 방식입니다.
3. **`force-cache`**:
    
    - **Next.js 데이터 캐시**를 먼저 확인하고, 캐시가 존재하고 여전히 유효하면 **캐시된 데이터를 반환**합니다.
    - **캐시가 없거나 오래된 데이터**인 경우, 원격 서버에서 데이터를 다시 가져와서 **캐시를 업데이트**합니다.
    - 이 설정은 **캐시된 데이터를 사용**하려고 시도하고, **최신 데이터를 가져와서 캐시를 업데이트**합니다.

### 사용 예시:

ts

코드 복사

`fetch('https://api.vercel.app/blog', { cache: 'force-cache' })`

이 요청은 **Next.js 데이터 캐시**에서 이미 데이터를 찾을 수 있다면, 캐시된 데이터를 반환하고, 그렇지 않거나 캐시가 오래된 경우에는 **서버에서 최신 데이터를 가져와** 캐시를 갱신합니다.

### 요약:

- **`auto`**: 개발 모드에서 매번 서버 요청, 배포 모드에서는 한 번만 데이터 요청 후 캐시 사용.
- **`no-store`**: 매번 서버에서 최신 데이터를 요청, 캐시를 사용하지 않음.
- **`force-cache`**: 데이터가 캐시되었으면 캐시된 데이터를 반환, 없거나 오래되면 서버에서 최신 데이터를 요청 후 캐시 갱신.

```ts
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog?id=${id}', {
    cache: 'no-cache', // 기본값인 no-cache 사용
  })
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}

```
서버에서 **3초마다 다른 데이터를 반환**해야 하고, **`id` 값은 같을 때** `fetch`의 기본 캐시 옵션인 `no-cache`를 사용할 경우, 동작 방식은 다음과 같습니다.

### `no-cache` 옵션 동작 방식

- **`no-cache`**는 **HTTP 캐시를 사용하지 않고 매번 서버에서 최신 데이터를 요청**하게 만듭니다.
- 요청을 보낼 때, **같은 `id` 값으로 요청하더라도**, 매번 **서버에 새로운 요청을 보내고** 그에 대한 **응답을 받게** 됩니다. 이 과정에서 서버는 **3초마다 다른 데이터를 반환**하므로, 클라이언트는 **매번 최신 데이터를 받게** 됩니다.

### 예시 코드에서 동작

ts

코드 복사

`export default async function Page() {   let data = await fetch('https://api.vercel.app/blog?id=${id}', {     cache: 'no-cache', // 기본값인 no-cache 사용   })   let posts = await data.json()   return (     <ul>       {posts.map((post) => (         <li key={post.id}>{post.title}</li>       ))}     </ul>   ) }`

이 경우, `fetch` 함수에서 `cache: 'no-cache'`가 명시되지 않더라도, **`no-cache`는 기본값**으로 동작합니다. 즉, 다음과 같이 설명할 수 있습니다:

1. `id` 값이 동일하더라도, **서버에 새로운 요청**이 전달됩니다.
2. **서버는 매번 3초마다 다르게 변경된 데이터를 응답**하게 됩니다.
3. **클라이언트는 항상 최신 데이터를 받으며** 표시됩니다.

즉, **`id`가 같더라도 매번 서버에서 다른 데이터를 요청**하게 되어, 서버가 변경된 데이터를 응답하기 때문에 **3초마다 다른 데이터를 받아서 화면에 표시**됩니다.

### 정리

- **`no-cache`**는 요청을 보낼 때마다 **서버에서 새 데이터를 요청**하게 하므로, **`id`가 같아도** 서버에서 반환하는 **다른 데이터를 계속 받을 수 있습니다**.
- 서버가 3초마다 데이터를 변경하더라도, `no-cache`를 사용하면 항상 **최신 데이터를 반영**할 수 있습니다.