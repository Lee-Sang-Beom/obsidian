
#### 1. API Layer

- [API(응용 프로그램 프로그래밍 인터페이스)](https://www.cloudflare.com/learning/security/api/what-is-an-api/)는 하나의 응용 프로그램이 다른 응용 프로그램에 서비스를 요청하는 방식이다.

- API는 애플리케이션 코드와 데이터베이스 사이의 중간 계층으로, API를 사용하는 경우는 아래와 같다.
	1. 3rd party 서비스를 사용하여 API를 제공하는 경우
	2. 클라이언트에서 데이터를 가져오는 경우, 데이터베이스의 secrets 데이터를 클라이언트에 노출시키지 않기 위해 서버에서 실행되는 API Layer가 필요하다.

- Next.js에서는 Route Handlers를 사용하여 API 엔드포인트를 생성할 수 있다.
	- API 엔드포인트는 [API 호출](https://www.cloudflare.com/learning/security/api/what-is-api-call/)이 수행되는 부분이다.


#### 2. Database Query

- 만약, 풀스택 애플리케이션을 개발한다면데이터베이스와 상호작용하는 로직을 작성하는 것은 필수라 할 수 있다, 
	-  Postgres와 같은 관계형 데이터베이스의 경우 SQL 또는 Prisma와 같은 ORM을 사용할 수 있다.

- 데이터베이스 쿼리를 작성해야 하는 경우는 아래와 같다:
	1. **API 엔드포인트를 생성할 때**, 데이터베이스와 상호 작용하는 로직을 작성해야 한다.
	2. **React Server Components**(RSC)를 사용하는 경우(서버에서 데이터를 가져오는 경우), API Layer를 건너뛸 수 있으며, 데이터베이스의 secrets 데이터를 클라이언트에 노출시키지 않고도 데이터베이스에 직접 쿼리할 수 있다.


#### 3. Using Server Components to fetch Data (서버컴포넌트에서 데이터 가져오기)

- 기본적으로 Next.js 애플리케이션의 모든 컴포넌트는 **React Server Component**(RSC)로 구성된다. 

- **Server Component**를 사용하여, 데이터를 가져오는 것은 Next.js 업데이트에 따른 비교적 새로운 접근 방식임과 동시에, 다음과 같은 몇 가지 사용 이점이 존재한다.
	1. 서버 컴포넌트는 **Promise**를 지원하기 때문에, 데이터 Fetch와 같은 비동기 작업에 대한 간단한 솔루션을 제공한다. **async/await** 구문을 사용하면, **useEffect, useState 또는 Fetch 용도의 각종 라이브러리에** 의존하지 않고 데이터 Fetch를 진행할 수 있다.
	2. 서버 컴포넌트는 서버에서 실행되므로, 비용이 많이 드는 데이터 Fetch 및 로직을 서버에 유지하고 결과를 클라이언트에만 전송할 수 있다.
	3. (앞서 언급했듯) 서버 컴포넌트는 서버에서 실행되기 때문에, **추가적인 API Layer 없이 데이터베이스에 직접 쿼리**할 수 있다.


#### 4. Using SQL (SQL 사용하기)

- 해당 과정에서는, 대시보드 프로젝트에 [Vercel Postgres SDK](https://vercel.com/docs/storage/vercel-postgres/sdk) 와 SQL을 사용하여, 데이터베이스 쿼리를 작성할 것이다.

- SQL을 사용하는 이유에는 아래와 같은 몇 가지 이유가 있다.
	- SQL은 관계형 데이터베이스를 쿼리하는 산업 표준으로 사용된다. (예: ORM은 내부적으로 SQL을 생성한다)
	- SQL에 대한 기본적인 이해는 관계형 데이터베이스의 기본을 이해하는 데 도움이 되며, 이를 통해 다른 도구에도 지식을 적용할 수 있다.
	- SQL은 다양한 데이터를 가져오고 조작할 수 있는 유연성이 있다.
	- Vercel Postgres SDK는 [SQL Injection(삽입 공격)](https://vercel.com/docs/storage/vercel-postgres/sdk#preventing-sql-injections)에 대한 보호 기능을 제공한다.

- `/app/lib/data.ts` 파일을 확인해보면, `@vercel/postgres`에서 [`SQL`](https://vercel.com/docs/storage/vercel-postgres/sdk#sql) 함수를 가져오고 있음을 알 수 있다. 이 함수를 사용하여 데이터베이스를 쿼리할 수 있다.

```ts
import { sql } from "@vercel/postgres";
import {
  CustomerField,
  CustomersTable,
  InvoiceForm,
  InvoicesTable,
  LatestInvoiceRaw,
  User,
  Revenue,
} from "./definitions";
import { formatCurrency } from "./utils";

export async function fetchRevenue() {
  // Add noStore() here prevent the response from being cached.
  // This is equivalent to in fetch(..., {cache: 'no-store'}).

  try {
    // Artificially delay a reponse for demo purposes.
    // Don't do this in real life :)

    // console.log('Fetching revenue data...');
    // await new Promise((resolve) => setTimeout(resolve, 3000));

    const data = await sql<Revenue>`SELECT * FROM revenue`;

    // console.log('Data fetch complete after 3 seconds.');

    return data.rows;
  } catch (error) {
    console.error("Database Error:", error);
    throw new Error("Failed to fetch revenue data.");
  }
}

export async function fetchLatestInvoices() {
  try {
    const data = await sql<LatestInvoiceRaw>`
      SELECT invoices.amount, customers.name, customers.image_url, customers.email, invoices.id
      FROM invoices
      JOIN customers ON invoices.customer_id = customers.id
      ORDER BY invoices.date DESC
      LIMIT 5`;

    const latestInvoices = data.rows.map((invoice) => ({
      ...invoice,
      amount: formatCurrency(invoice.amount),
    }));
    return latestInvoices;
  } catch (error) {
    console.error("Database Error:", error);
    throw new Error("Failed to fetch the latest invoices.");
  }
}

export async function fetchCardData() {
  try {
    // You can probably combine these into a single SQL query
    // However, we are intentionally splitting them to demonstrate
    // how to initialize multiple queries in parallel with JS.
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;

    const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);

    const numberOfInvoices = Number(data[0].rows[0].count ?? "0");
    const numberOfCustomers = Number(data[1].rows[0].count ?? "0");
    const totalPaidInvoices = formatCurrency(data[2].rows[0].paid ?? "0");
    const totalPendingInvoices = formatCurrency(data[2].rows[0].pending ?? "0");

    return {
      numberOfCustomers,
      numberOfInvoices,
      totalPaidInvoices,
      totalPendingInvoices,
    };
  } catch (error) {
    console.error("Database Error:", error);
    throw new Error("Failed to card data.");
  }
}

const ITEMS_PER_PAGE = 6;
export async function fetchFilteredInvoices(
  query: string,
  currentPage: number
) {
  const offset = (currentPage - 1) * ITEMS_PER_PAGE;

  try {
    const invoices = await sql<InvoicesTable>`
      SELECT
        invoices.id,
        invoices.amount,
        invoices.date,
        invoices.status,
        customers.name,
        customers.email,
        customers.image_url
      FROM invoices
      JOIN customers ON invoices.customer_id = customers.id
      WHERE
        customers.name ILIKE ${`%${query}%`} OR
        customers.email ILIKE ${`%${query}%`} OR
        invoices.amount::text ILIKE ${`%${query}%`} OR
        invoices.date::text ILIKE ${`%${query}%`} OR
        invoices.status ILIKE ${`%${query}%`}
      ORDER BY invoices.date DESC
      LIMIT ${ITEMS_PER_PAGE} OFFSET ${offset}
    `;

    return invoices.rows;
  } catch (error) {
    console.error("Database Error:", error);
    throw new Error("Failed to fetch invoices.");
  }
}

export async function fetchInvoicesPages(query: string) {
  try {
    const count = await sql`SELECT COUNT(*)
    FROM invoices
    JOIN customers ON invoices.customer_id = customers.id
    WHERE
      customers.name ILIKE ${`%${query}%`} OR
      customers.email ILIKE ${`%${query}%`} OR
      invoices.amount::text ILIKE ${`%${query}%`} OR
      invoices.date::text ILIKE ${`%${query}%`} OR
      invoices.status ILIKE ${`%${query}%`}
  `;

    const totalPages = Math.ceil(Number(count.rows[0].count) / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error("Database Error:", error);
    throw new Error("Failed to fetch total number of invoices.");
  }
}

export async function fetchInvoiceById(id: string) {
  try {
    const data = await sql<InvoiceForm>`
      SELECT
        invoices.id,
        invoices.customer_id,
        invoices.amount,
        invoices.status
      FROM invoices
      WHERE invoices.id = ${id};
    `;

    const invoice = data.rows.map((invoice) => ({
      ...invoice,
      // Convert amount from cents to dollars
      amount: invoice.amount / 100,
    }));

    return invoice[0];
  } catch (error) {
    console.error("Database Error:", error);
  }
}

export async function fetchCustomers() {
  try {
    const data = await sql<CustomerField>`
      SELECT
        id,
        name
      FROM customers
      ORDER BY name ASC
    `;

    const customers = data.rows;
    return customers;
  } catch (err) {
    console.error("Database Error:", err);
    throw new Error("Failed to fetch all customers.");
  }
}

export async function fetchFilteredCustomers(query: string) {
  try {
    const data = await sql<CustomersTable>`
		SELECT
		  customers.id,
		  customers.name,
		  customers.email,
		  customers.image_url,
		  COUNT(invoices.id) AS total_invoices,
		  SUM(CASE WHEN invoices.status = 'pending' THEN invoices.amount ELSE 0 END) AS total_pending,
		  SUM(CASE WHEN invoices.status = 'paid' THEN invoices.amount ELSE 0 END) AS total_paid
		FROM customers
		LEFT JOIN invoices ON customers.id = invoices.customer_id
		WHERE
		  customers.name ILIKE ${`%${query}%`} OR
        customers.email ILIKE ${`%${query}%`}
		GROUP BY customers.id, customers.name, customers.email, customers.image_url
		ORDER BY customers.name ASC
	  `;

    const customers = data.rows.map((customer) => ({
      ...customer,
      total_pending: formatCurrency(customer.total_pending),
      total_paid: formatCurrency(customer.total_paid),
    }));

    return customers;
  } catch (err) {
    console.error("Database Error:", err);
    throw new Error("Failed to fetch customer table.");
  }
}

export async function getUser(email: string) {
  try {
    const user = await sql`SELECT * from USERS where email=${email}`;
    return user.rows[0] as User;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    throw new Error("Failed to fetch user.");
  }
}
```


#### 5. Fetching data for the dashboard overview page