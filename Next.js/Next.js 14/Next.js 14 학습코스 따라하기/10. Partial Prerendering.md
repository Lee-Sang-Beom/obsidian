
- 지금까지, 빌드 및 revalidation 시간에 데이터 fetch 및 렌더링을 진행하는 **정적 렌더링**과 사용자 요청 등이 발생할 때 렌더링을 진행하는 **동적 렌더링**에 대해 알아보았다.

- 이번 Chapter에서는, **PPR(Partial Prerendering)** 이라는 것을 사용하여, 정적 렌더링, 동적 렌더링, 스트리밍을 동일한 경로로 결합하는 방법을 알아볼 것이다.


#### 1. Static vs. Dynamic Routes

- 오늘날 대부분의 웹 애플리케이션에서는 전체 애플리케이션 또는 특정 경로(route)에 한해, 정적 렌더링과 동적 렌더링 중 하나를 선택한다.
	- Next.js에서는, 특정 경로(route)에서 동적 함수를 호출하면, (예: `noStore()`, `cookies()` 등) 해당 경로 전체가 동적으로 변화한다.

- 근데, 보통 대부분의 경로는 완전히 정적이거나 동적이지가 않다.
	- 예를 들어, 전자상거래 사이트를 생각해보자. 제품 정보 페이지의 대부분을 정적으로 렌더링하고 싶을 수 있지만, 사용자의 장바구니와 추천 제품 등은 동적으로 가져와야 하지 않겠는가?

- 지금까지 만들어 본 대시보드 페이지를 생각해보자.
	- 페이지 사이드에 위치한 `<SideNav/>`는 `fetch`해오는 데이터에 의존하지 않기 때문에 정적으로 개발할 수 있다.
	- 그러나, 실질적으로 `fetch`해오는 데이터를 기반으로 화면을 구성하는 `<Page/>`내의 컴포넌트들은 동적으로 개발해야 한다.

>`<SideNav/>
```tsx
import Link from 'next/link';
import NavLinks from '@/app/ui/dashboard/nav-links';
import AcmeLogo from '@/app/ui/acme-logo';
import { PowerIcon } from '@heroicons/react/24/outline';

export default function SideNav() {
  return (
    <div className="flex h-full flex-col px-3 py-4 md:px-2">
      <Link
        className="mb-2 flex h-20 items-end justify-start rounded-md bg-blue-600 p-4 md:h-40"
        href="/"
      >
        <div className="w-32 text-white md:w-40">
          <AcmeLogo />
        </div>
      </Link>
      <div className="flex grow flex-row justify-between space-x-2 md:flex-col md:space-x-0 md:space-y-2">
        <NavLinks />
        <div className="hidden h-auto w-full grow rounded-md bg-gray-50 md:block"></div>
        <form>
          <button className="flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3">
            <PowerIcon className="w-6" />
            <div className="hidden md:block">Sign Out</div>
          </button>
        </form>
      </div>
    </div>
  );
}
```

> `page.tsx` 내의 `cards.tsx`
```tsx
import {
  BanknotesIcon,
  ClockIcon,
  UserGroupIcon,
  InboxIcon,
} from "@heroicons/react/24/outline";
import { lusitana } from "../font";
import { fetchCardData } from "@/app/lib/data";

const iconMap = {
  collected: BanknotesIcon,
  customers: UserGroupIcon,
  pending: ClockIcon,
  invoices: InboxIcon,
};

export default async function CardWrapper() {
  // 추가
  const {
    numberOfCustomers,
    numberOfInvoices,
    totalPaidInvoices,
    totalPendingInvoices,
  } = await fetchCardData();

  return (
    <>
      {/* NOTE: comment in this code when you get to this point in the course */}
      <Card title="Collected" value={totalPaidInvoices} type="collected" />
      <Card title="Pending" value={totalPendingInvoices} type="pending" />
      <Card title="Total Invoices" value={numberOfInvoices} type="invoices" />
      <Card
        title="Total Customers"
        value={numberOfCustomers}
        type="customers"
      />
    </>
  );
}

export function Card({
  title,
  value,
  type,
}: {
  title: string;
  value: number | string;
  type: "invoices" | "customers" | "pending" | "collected";
}) {
  const Icon = iconMap[type];

  return (
    <div className="rounded-xl bg-gray-50 p-2 shadow-sm">
      <div className="flex p-4">
        {Icon ? <Icon className="h-5 w-5 text-gray-700" /> : null}
        <h3 className="ml-2 text-sm font-medium">{title}</h3>
      </div>
      <p
        className={`${lusitana.className}
          truncate rounded-xl bg-white px-4 py-8 text-center text-2xl`}
      >
        {value}
      </p>
    </div>
  );
}

```


#### 2. What is Partial Prerendering?

- 공식 문서에서는, 동일한 경로에서 정적 렌더링과 동적 렌더링의 장점을 결합할 수 있는 새로운 렌더링 모델로써 Partial Prerendering을 소개하고 있다. 
	- 이 모델은 빠른 초기 로드를 보장하면서도 개인화되고 자주 업데이트되는 콘텐츠를 제공하여 성능과 사용자 만족도를 모두 향상시킬 수 있다고 한다.

- 사용자가 경로를 방문할 때 아래의 효과를 낸다고 한다.
	- **빠른 초기 로드**: 사전 렌더링된 정적 셸을 제공함으로써 사용자는 빠른 초기 로드 시간을 경험할 수 있다.
	- **향상된 사용자 경험**: 동적 콘텐츠가 비동기적으로 병렬 로드되기 때문에, 사용자는 대기 시간 없이 정적 부분과 상호작용할 수 있으며, 동적 데이터는 준비되자마자 표시된다.
	- **SEO 최적화**: 페이지의 주요 부분이 사전 렌더링되므로, 검색 엔진이 정적 콘텐츠를 효과적으로 인덱싱(indexing)할 수 있어 SEO가 향상된다.

- 여기서, 인덱싱이란, 데이터베이스 또는 검색 엔진에서 데이터 검색 속도를 높이기 위해 사용하는 기술을 의미한다.
	- 데이터베이스나 검색 엔진에서 인덱스는 특정 키를 기준으로 데이터의 위치를 저장한 구조체로, 대량의 데이터를 효율적으로 조회할 수 있도록 돕는다.