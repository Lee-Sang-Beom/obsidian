
-  이전 코스에서는 대시보드 페이지를 동적으로 만드는 데 성공했지만, 데이터 Fetch 속도가 느린 경우, 애플리케이션의 성능에 어떤 영향을 미칠 수 있는가에 대해 논의했다.

- 이번 코스에서는, **느린 데이터 요청이 있을 때 사용자 경험을 어떻게 개선**할 수 있는지에 대해 살펴보도록 하자.


#### 1. 기존 SSR

- 기존 SSR의 flow를 생각해보면 아래와 같다.
	1. 서버(API)로부터 Data를 가져온다.
	2. 서버(Next.js)에서 HTML을 렌더링한다.
	3. 클라이언트(브라우저)에서 HTML를 받는다.
	4. 클라이언트(브라우저)는 자바스크립트(bundle.js)를 다운로드 한 후, **상호작용성**있는 웹을 만든다.
![[ssr.png]]

- 이는, 위의 과정이 모두 끝나기 전까지는, 사용자는 페이지와 상호작용을 할 수 없다는 뜻이다.
	- Next.js에서는, 이 문제를 해결하기 위해 어떠한 기술을 도입했는데, 그것이 **Streaming**이다.


#### 2. Streaming

- Next.js에서는 **Streaming**을 **경로를 더 작은 "청크"로 나누어 서버에서 클라이언트로 점진적으로 스트리밍하는 데이터 전송 기술**이라고 소개하고 있다.

- 좀 더 쉽게 말하면, HTML을 이미지처럼 작게 나누어, 모든 데이터가 로드되기 전에 준비된 컴포넌트는 미리 완성해 상호작용할 수 있게 해주는 기술을 Streaming이라고 한다.
	- 이 기술을 사용해 **우선순위가 높은 컴포넌트를 먼저 작동**하게 해 줄 수 있다.
![[server-rendering-with-streaming 1.avif]]

- 정리하면, **Streaming**은 느린 데이터의 요청이 **전체 페이지를 차단하는 것을 방지**할 수 있도록 고안된 기술이다. 이를 통해 사용자는 모든 데이터가 로드될 때 까지 기다리지 않고, **페이지의 일부를 보고 상호작용**할 수 있게 된다.

	- 아래는 각 컴포넌트가 **Hydrating**되기까지의 시간(TTL: 페이지 요청 후, 페이지 상호작용이 가능해지기까지 걸린 시간)을 한 눈에 확인할 수 있도록 제시된 이미지이다. 

	- Next.js에서 제공하는 **Streaming**은 각 컴포넌트에서 필요로 하는 **TTL**이 지나고 나면, 컴포넌트 별로 상호작용이 가능하도록 한다. 
		- **Hydrating**: Next.js 서버는 **Pre-Rendering**된 웹 페이지를 클라이언트에게 보낸 뒤, 바로 React가 bundling된 Javascript 코드들을 chunk 단위로 클라이언트에게 전송한다. 그리고 이러한 Javascript 코드들이 이전에 전송된 HTML DOM 요소 위로 리렌더링 되는 과정 속에서 자기 자리를 찾아 매칭되는 과정이 **Hydrating**이다.
		- Hydrating을 통해 초기 로딩 시 클라이언트에서 **즉시 상호작용이 가능**하고, 이후에는 일반적인 React 애플리케이션처럼 동작할 수 있다.
![[server-rendering-with-streaming-chart.avif]]

- Next.js에서 스트리밍을 구현하는 방법에는 두 가지가 있다.
	1. 페이지 수준에서 `loading.tsx`파일 사용
	2. 특정 컴포넌트에서 `<Suspense>` 사용


#### 3. Streaming a whole page with `loading.tsx`

- `/app/dashboard` 디렉터리 경로에, 새 파일인 `loading.tsx`를 만들어보자.
	- `<Loading/>`컴포넌트는 간단한 로딩 화면을 렌더링하며, 페이지가 로딩될 때 표시된다.
```tsx
export default function Loading() {
  return <div>Loading...</div>;
}
```

- 해당 파일을 생성한 후, http://localhost:3000/dashboard 페이지로 이동하거나, 새로고침하면 로딩 화면이 표시될 것이다.
![[Pasted image 20240315131209.png]]

- 여기서는 몇 가지 사항이 이루어지고 있다.
	- `loading.tsx`는 Suspense를 기반으로 한 Next.js의 특수 파일로, 페이지 콘텐츠가 로드되는 동안 대체 UI를 보여줄 수 있게 한다.
	- `<SideNav>`컴포넌트는 정적이므로 즉시 표시되며, 사용자는 동적 콘텐츠가 로드되는 동안 `<SideNav>`와 상호 작용할 수 있다.
		- 사용자는 **페이지가 완전히 로드되기를 기다릴 필요**가 없으며, 페이지를 떠나기 위해서도 기다릴 필요가 없다. (이를 **interruptable navigation**이라고 부른다.)
		- 이는 사용자 경험을 개선하기 위해 더 많은 작업을 수행할 수 있도록 하며, **"Loading..."** 텍스트 대신 **Loading Skeleton**을 쉽게 표시할 수 있도록 한다.


#### 4. Adding loading skeletons

- 지금부터 만들 `<LoadingSkeleton/>` 컴포넌트는 UI의 간소화된 버전을 표현해준다. 많은 웹사이트가 사용자에게 콘텐츠를 로딩 중임을 나타내기 위해 사용되는 대체 UI이다.
	- 만약, 사용자가 콘텐츠의 로딩을 기다리면서 하얀 백지 화면만 보게 된다면 어떻게 될까? 페이지 동작이 아예 멈춘 것인지, 혹은 로딩이 오래 걸리는 것인지에 대한 판단을 하기 힘들 것이다. (UX 문제 발생)
	- **Skeleton UI**를 사용하면, 별도 UI인 스켈레톤 컴포넌트를 보여줌으로써 사용자에게 서비스가 원활히 작동중임을 알릴 수 있고, 이탈을 방지하는 효과 또한 얻을 수 있다.

- `/app/dashboard/loading.tsx` 파일을 사전에 구성된 `<DashboardSkeleton/>` 컴포넌트를 호출하는 방식으로, 아래와 같이 코드를 변경해주면 된다.
```tsx
import DashboardSkeleton from "../ui/skeletons";

export default function Loading() {
  return <DashboardSkeleton />;
}
```

- 로딩 중일 때 표시되는 Skeleton UI 표시 결과는 아래 이미지와 같다
![[Pasted image 20240316215612.png]]

