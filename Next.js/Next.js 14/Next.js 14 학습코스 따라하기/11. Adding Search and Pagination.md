
- 이전 Chapter에서는 Partial Prerendering을 통해, Next.js에서 경로의 정적 부분을 미리 렌더링하고, 동적 부분은 사용자가 요청할 때까지 지연시키는 방법에 대해 알아보았다.

- 이번 Chapter에서는 URL 검색 매개변수를 사용하여 검색 및 페이징을 구현하는 방법에 대해 알아볼 것이다.


#### 1. Starting Code (경로 및 파일 만든 후, 코드 붙여넣기)

- 본격적으로 시작하기 앞서, `/app/dashboard/invoices/page.tsx` 경로에 파일을 추가하 아래 코드를 붙여넣어주자.
	- `<Search/>`: 사용자가 특정 송장을 검색할 수 있도록 하는 컴포넌트
	- `<Pagination/>`: 사용자가 송장의 페이지 간을 탐색할 수 있게 하는 컴포넌트
	- `<Table/>`: 송장을 표시하는 컴포넌트
```tsx
import Pagination from "@/app/ui/invoices/pagination";
import Search from "@/app/ui/search";
import Table from "@/app/ui/invoices/table";
import { CreateInvoice } from "@/app/ui/invoices/buttons";
import { InvoicesTableSkeleton } from "@/app/ui/skeletons";
import { Suspense } from "react";
import { lusitana } from "../ui/font";

export default async function Page() {
  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      {/*  <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense> */}
      <div className="mt-5 flex w-full justify-center">
        {/* <Pagination totalPages={totalPages} /> */}
      </div>
    </div>
  );
}
```

- 검색 기능은 클라이언트와 서버 두 곳에 걸쳐 작동한다. 대체적인 과정은 아래와 같다
	1. 사용자가 클라이언트에서 송장을 검색하면 URL 매개변수가 업데이트된다,
	2. 업데이트된 매개변수를 통해 서버에서 데이터를 불러온다.
	3. 테이블 컴포넌트는 새로운 데이터를 기반으로 서버에서 다시 렌더링된다.


###### ※ 참고: 왜 URL 검색 매개변수를 사용할까?

- 앞서 언급한 내용 중, 검색 상태를 관리하기 위해 URL 검색 매개변수를 사용한다고 했었다. 
	- 클라이언트 측 상태로 검색 상태를 관리하는 것에 익숙하다면, 이 패턴이 새로울 수 있다.

- URL 매개변수를 통해 검색 상태를 관리하는 방법은 아래와 같은 몇 가지 이점이 있다
	1. **북마크 가능 및 공유 가능한 URL**: 검색 매개변수가 URL에 포함되어 있기 때문에 사용자는 검색 쿼리와 필터를 포함한 현재 애플리케이션 상태를 북마크하거나 공유할 수 있다.
	
	2. **서버 사이드 렌더링 및 초기 로드**: URL 매개변수는 서버에서 초기 상태를 렌더링하는 데 직접 사용될 수 있다.
		- 그래서, SSR(서버 사이드 렌더링)을 처리하기가 더 쉬워진다.
	
	3. **분석 및 추적**: 검색 쿼리와 필터가 URL에 직접 포함되어 있기 때문에, 추가 클라이언트 측의 로직을 구현할 필요 없이, 사용자 행동을 추적하기가 더 쉽다.


#### 2. 검색 기능 추가하기 

- 다음은 검색 기능을 구현하기 위해 사용할, Next.js 클라이언트 **hook**이다.
	- `useSearchParams`: 현재 **URL의 매개변수에 접근**할 수 있게 해준다. 
	를 들어, URL `/dashboard/invoices?page=1&query=pending`의 검색 매개변수는 `{page: '1', query: 'pending'}`이다.

	- `usePathname`: 현재 URL의 경로명을 읽을 수 있게 해준다.
		- 예를 들어, 경로 `/dashboard/invoices`의 경우 `usePathname`은 `'/dashboard/invoices'`를 반환합니다.

	- `useRouter`: 클라이언트 컴포넌트 내에서 프로그래밍 방식으로 경로 간 이동을 가능하게 합니다. 사용할 수 있는 여러 메서드가 있습니다.