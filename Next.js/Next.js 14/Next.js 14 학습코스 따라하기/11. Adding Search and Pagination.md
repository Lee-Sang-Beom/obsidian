
- 이전 Chapter에서는 Partial Prerendering을 통해, Next.js에서 경로의 정적 부분을 미리 렌더링하고, 동적 부분은 사용자가 요청할 때까지 지연시키는 방법에 대해 알아보았다.

- 이번 Chapter에서는 URL 검색 매개변수를 사용하여 검색 및 페이징을 구현하는 방법에 대해 알아볼 것이다.


#### 1. Starting Code (경로 및 파일 만든 후, 코드 붙여넣기)

- 본격적으로 시작하기 앞서, `/app/dashboard/invoices/page.tsx` 경로에 파일을 추가하 아래 코드를 붙여넣어주자.
	- `<Search/>`: 사용자가 특정 송장을 검색할 수 있도록 하는 컴포넌트
	- `<Pagination/>`: 사용자가 송장의 페이지 간을 탐색할 수 있게 하는 컴포넌트
	- `<Table/>`: 송장을 표시하는 컴포넌트
```tsx
import Pagination from "@/app/ui/invoices/pagination";
import Search from "@/app/ui/search";
import Table from "@/app/ui/invoices/table";
import { CreateInvoice } from "@/app/ui/invoices/buttons";
import { InvoicesTableSkeleton } from "@/app/ui/skeletons";
import { Suspense } from "react";
import { lusitana } from "../ui/font";

export default async function Page() {
  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      {/*  <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense> */}
      <div className="mt-5 flex w-full justify-center">
        {/* <Pagination totalPages={totalPages} /> */}
      </div>
    </div>
  );
}
```

- 검색 기능은 클라이언트와 서버 두 곳에 걸쳐 작동한다. 대체적인 과정은 아래와 같다
	1. 사용자가 클라이언트에서 송장을 검색하면 URL 매개변수가 업데이트된다,
	2. 업데이트된 매개변수를 통해 서버에서 데이터를 불러온다.
	3. 테이블 컴포넌트는 새로운 데이터를 기반으로 서버에서 다시 렌더링된다.

- 개발을 위한 **구현 단계 개요**도 비슷하다.
	1. 사용자의 입력을 감지한다.
	2. 검색 매개변수로 URL을 업데이트한다.
	3. 입력 필도와 URL을 동기화한다.
	4. 검색 쿼리에 따라 테이블을 업데이트한다.

###### ※ 참고: 왜 URL 검색 매개변수를 사용할까?

- 앞서 언급한 내용 중, 검색 상태를 관리하기 위해 URL 검색 매개변수를 사용한다고 했었다. 
	- 클라이언트 측 상태로 검색 상태를 관리하는 것에 익숙하다면, 이 패턴이 새로울 수 있다.

- URL 매개변수를 통해 검색 상태를 관리하는 방법은 아래와 같은 몇 가지 이점이 있다
	1. **북마크 가능 및 공유 가능한 URL**: 검색 매개변수가 URL에 포함되어 있기 때문에 사용자는 검색 쿼리와 필터를 포함한 현재 애플리케이션 상태를 북마크하거나 공유할 수 있다.
	
	2. **서버 사이드 렌더링 및 초기 로드**: URL 매개변수는 서버에서 초기 상태를 렌더링하는 데 직접 사용될 수 있다.
		- 그래서, SSR(서버 사이드 렌더링)을 처리하기가 더 쉬워진다.
	
	3. **분석 및 추적**: 검색 쿼리와 필터가 URL에 직접 포함되어 있기 때문에, 추가 클라이언트 측의 로직을 구현할 필요 없이, 사용자 행동을 추적하기가 더 쉽다.


#### 2. Adding the search functionally(검색 기능 추가하기) 

- 다음은 검색 기능을 구현하기 위해 사용할, Next.js 클라이언트 **hook**이다.
	- `useSearchParams`: 현재 **URL의 매개변수에 접근**할 수 있게 해준다. 
		- 예를 들어, URL `/dashboard/invoices?page=1&query=pending`의 검색 매개변수는 `{page: '1', query: 'pending'}`이다.
	- `usePathname`: 현재 URL의 경로명을 읽을 수 있게 해준다.
		- 예를 들어, 경로 `/dashboard/invoices`의 경우 `usePathname`은 `'/dashboard/invoices'`를 반환한다.
	- `useRouter`: 클라이언트 컴포넌트 내에서 프로그래밍 방식으로 경로 간 이동을 가능하게 한다. 

- 지금부터는, 위에서 언급한 **구현 단계 개요** 순서대로, 구현 방법에 대해 알아보도록 하자.

##### 2-1. 사용자 입력 감지

- 가장 먼저, `<Search>` 컴포넌트의 내용을 확인해보자.
	- **참고(`"use client"`)** : 클라이언트 컴포넌트(RSC)에서 사용되는 지시어로, 이벤트 리스너 및 hook을 사용하기 위해 사용된다.
```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";

export default function Search({ placeholder }: { placeholder: string }) {
  
  function handleSearch(term: string) {
    console.log(term);
  }

  return (
    <div className="relative flex flex-1 flex-shrink-0">
      <label htmlFor="search" className="sr-only">
        Search
      </label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(e) => {
          handleSearch(e.target.value);
        }}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}
```

- 위의 코드에서는, `<input>` 태그에서 사용자 입력이 발생할 때마다, `handleSearch()` 메소드를 호출할 수 있도록 한다.
	- 여기까지가, **검색을 위한 사용자의 검색어 입력을 감지하는 부분**이다.


##### 2-2. 검색 매개변수로, URL 업데이트

- 이제, `useSearchParams hook`을 import해보자. 
```tsx
"use client";

import { MagnifyingGlassIcon } from "@heroicons/react/24/outline";
import { useSearchParams } from "next/navigation"; // add

export default function Search({ placeholder }: { placeholder: string }) {
  const searchParams = useSearchParams(); // add

  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams); // add
    console.log(searchParams, params); // output console
  }

  return (
    <div className="relative flex flex-1 flex-shrink-0">
      <label htmlFor="search" className="sr-only">
        Search
      </label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(e) => {
          handleSearch(e.target.value);
        }}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}
```

- 당장에는, 경로가 `/invoice`일 뿐, URL의 매개변수는 따로 없기 때문에 아래와 같이 출력되는 모습을 확인할 수 있다.
![[searchParams console.png]]

- `URLSearchParams`는 URL 쿼리 매개변수를 조작하기 위한 유틸리티 메서드를 제공하는 WEB API이다.
	- 복잡한 문자열 리터럴을 만드는 대신 이를 사용하여 `?page=1&query=a`와 같은 매개변수 문자열을 얻을 수 있다.

- 아래는, 사용자가 입력한 검색어(`term`)에 따라 URL의 쿼리 매개변수를 설정하거나 삭제하는 기능을 구현한 코드부분이다.
	- 만약, 사용자가 검색어를 입력하면 `params.set("query", term);`가 실행되어 query 매개변수에 사용자가 입력한 검색어(term)를 설정한다.
	- 사용자가 검색어를 입력하지 않으면 `params.delete("query");` 코드가 실행되어 `query` 매개변수를 삭제한다.
```tsx
// ...

function handleSearch(term: string) {
	const params = new URLSearchParams(searchParams);
	
	if (term) {
	  params.set("query", term);
	} else {
	  params.delete("query");
	}
	
	console.log(searchParams, params);
}

// ...
```

- 사용자가 검색어를 입력하여, `query` 매개변수에 값이 세팅되면, `URLSearchParams`의 size가 늘어난 것을 확인할 수 있다.
![[useSearchParams.png]]

- 이제, 현재 사용자의 경로를 기반으로, 사용자가 입력한 검색어로 URL을 업데이트해보자.
```tsx

  // ...
  const searchParams = useSearchParams();
  const pathname = usePathname(); // add
  const { replace } = useRouter(); // add

  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams);

    if (term) {
      params.set("query", term);
    } else {
      params.delete("query");
    }

    replace(`${pathname}?${params.toString()}`);
  }
  
  // ...
```

- 위 코드의 중요사항 요약은 아래와 같다.
	- `pathname`: 현 프로젝트 기준으로 URL 경로명은 `"/dashboard/invoices"`이다.
	- `replace(${pathname}?${params.toString()})` : 사용자의 검색 데이터를 포함하여 URL을 업데이트한다.
		- 예를 들어, 사용자가 "Lee"를 검색하면 `/dashboard/invoices?query=lee`가 된다.

- 이렇게 하면, Next.js의 클라이언트 측 탐색 기능이 페이지를 새로고침하지 않고도, URL을 업데이트할 수 있다.
	- 이 기능은 SPA(Single Page Application) 방식으로 동작하며, 페이지가 새로고침되지 않기 때문에 더 빠르고 부드러운 사용자 경험을 제공할 수 있다.
	
	- **클라이언트 측 탐색**: 일반적으로 웹 애플리케이션에서 URL을 변경하거나 페이지를 이동하려면 페이지 전체를 새로고침해야 한다. **그러나 Next.js 프레임워크는 클라이언트 측에서 페이지를 전환할 수 있는 기능을 제공한다.** 이는 필요한 부분만 새로고침하고 나머지 페이지는 그대로 유지하여 사용자 경험을 향상시킨다.
    
	- **페이지 새로고침 없이 URL 업데이트**: Next.js에서는 `useRouter` hook을 사용하여 프로그래밍 방식으로 URL을 업데이트할 수 있다. 이를 통해 사용자가 검색어를 입력하면 URL이 즉시 업데이트되지만 페이지는 새로고침되지 않는다. 예를 들어, `/dashboard/invoices?query=lee`와 같이 URL이 변경되지만 페이지는 그대로 유지된다.