
## 1. 자바스크립트와 단일 스레드(Thread)

- 자바스크립트는 싱글 스레드 언어로, 한 번에 하나의 작업만 처리할 수 있다.
	- 그렇기에, 자바스크립트 엔진은 함수 호출 시 실행 컨텍스트가 쌓이는 공간인 콜스택을 하나만 보유하고 있습니다.

- 하지만, 자바스크립트 사용 시, 마치 **멀티 스레드**처럼 동시에 여러 Task를 처리하는 느낌을 받을 때가 많은데, 이는 자바스크립트가 비동기로 작동하는 것이 이유이다.
	- 자바스크립트 자체는 비동기 동작을 지원하지 않으나, 비동기로 동작할 수 있도록 지원을 해주는 곳이 있다.
	- 그 핵심적인 요소가 **브라우저**이다.

> [!note] **자바스크립트는 왜 싱글스레드인가?** 
> 자바스크립트는 1995년에 넷스케이프에서 웹 브라우저에서 동적인 웹 페이지를 만들기 위해 개발된 스크립트 언어이다. 당시에는 멀티 코어 프로세서가 보편화되지 않았고, 자바스크립트는 웹 브라우저에서 간단한 스크립트 동작을 수행하는 데 주로 사용되었기 때문에 복잡한 병렬 처리를 필요로 하지 않아, 메모리 사용량이 적고, 동기화 문제를 피할 수 있는 싱글 스레드로 구현하였다. 그러나 싱글 스레드는 오래 걸리는 작업이 실행되면 다른 작업들이 대기해야 하므로 응답성이 떨어진다. 또한 CPU 코어를 여러 개 사용할 수 없으므로 성능이 제한된다. 이러한 문제들을 해결하기 위해 언어 자체의 설계를 바꾸는 것 보단, 브라우저의 멀티 스레드를 이용하는 자바스크립트의 비동기 프로그래밍을 지원하는 것이다. 그리고 이 비동기 프로그래밍의 핵심이 이벤트 루프인 것이다. (다만 Web worker 최신 기술을 통해 자바스크립트도 멀티 스레드 구현이 가능해졌다)
> 
>※ 출처: [자바스크립트-이벤트-루프-구조-동작-원리](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)

 
---
## 2. 브라우저의 내부 구조

> [이미지 : 브라우저 내부 구조 (출처 : How JavaScript works: an overview of the engine, the runtime, and the call stack)](https://medium.com/sessionstack-blog/how-does-javascript-actually-work-part-1-b0bacc073cf)
![[브라우저 내부 구조.png]]
### 1. 자바스크립트 엔진
#### 1-1. 메모리 힙(Memory Heap)
```js
// 메모리 힙에 저장되는 객체
const obj = { name: "Alice", age: 25 };

// 메모리 힙에 저장되는 배열
const arr = [1, 2, 3, 4, 5];

// 함수도 메모리 힙에 저장
function greet() {
  console.log("Hello!");
}
```
##### ※ 정의
- 자바스크립트 엔진이 동적으로 생성한 객체나 데이터를 저장하고 관리하는 메모리 공간이다.
##### ※ 역할
1. 동적 메모리 할당
	- 객체, 배열, 함수 등 **크기가 가변적인 데이터**를 저장하기 위해 사용된다.
	- 예: 객체 생성, 클로저 등이 필요할 때 메모리 힙을 사용한다.

2. 가비지 컬렉션
	- 메모리 힙에 할당된 데이터 중 더 이상 사용되지 않는 데이터를 정리하여 메모리 누수를 방지한다.
#### 1-2. 콜  스택(Call Stack)
```js
function first() {
  console.log("First function");
  second();
}

function second() {
  console.log("Second function");
  third();
}

function third() {
  console.log("Third function");
}

first();

// first() -> second() -> third() 순 콜스택에 추가
// third() -> second() -> first() 순 콜스택에서 제거
```
##### ※ 정의
- **콜 스택**은 자바스크립트 엔진이 함수 호출을 관리하는 메모리 구조이다.
- 스택(stack) 자료구조를 사용하며, **LIFO(Last In, First Out)** 방식으로 동작한다.
##### ※ 역할
1. 함수 호출 관리
    - 실행 중인 함수와 호출된 함수 정보를 추적한다.

2.  실행 컨텍스트 저장
    - 함수 실행 시 필요한 정보(변수, 객체, this 등)를 저장하고 관리한다.

3. 실행 순서 유지
    - 함수 호출이 끝나면 스택에서 제거하며, 이전 함수로 돌아간다.


### 2. Web APIs

- 자바스크립트 코드에서 비동기 작업(예: HTTP 요청, 타이머 설정, 파일 읽기 등)은 브라우저나 런타임 환경(Node.js)의 **Web API**에 위임하여 처리된다.
	- 각 자바스크립트 코드에 해당하는 실행 컨텍스트는 콜 스택에 올라갔다가 비동기 작업 구문이 발견되면 Web API에 해당 작업들이 위임된다.

- Web API는 브라우저나 런타임 환경이 제공하는 **네이티브 기능의 인터페이스**로, 비동기 작업(예: 타이머, 네트워크 요청 등)을 처리하기 위한 별도의 시스템을 통해 동작한다. 간단히 말해 브라우저에서 제공하는 API 모음이다.
	- 네이티브 기능의 인터페이스란, 웹 브라우저나 운영 체제에서 제공하는 **기본적인 기능이나 내장된 API**를 **자바스크립트와 같은 고급 언어**에서 접근할 수 있도록 하는 **인터페이스**를 의미한다.
	- 브라우저 내부에서 비동기 작업은 필요에 따라 멀티 스레드를 사용할 수 있다.
#### 2-1. DOM
```js
// DOM을 사용해 HTML 요소를 변경
document.getElementById("myElement").innerText = "Hello, world!";
```
- **DOM**은 웹 페이지의 구조를 객체로 표현한 것으로, HTML 문서의 모든 요소와 속성, 텍스트 등을 객체 형태로 나타내어 자바스크립트에서 이를 동적으로 수정하고 조작할 수 있게 해준다.
- 또한, DOM은 HTML/XML 문서의 프로그래밍 `interface`라고도 정의되기도 한다. 이는 HTML 문서의 요소를 자바스크립트로 동적으로 조작할 수 있도록 지원되는 API라고 이해할 수 있다.
- 자바스크립트는 DOM을 통해 HTML 요소에 접근하고, 수정하고, 삭제하거나 새로 추가하는 등의 작업을 할 수 있다.
#### 2-2. AJAX(Asynchronous JavaScript and XML)
```js
// AJAX 요청 예시 (XMLHttpRequest 사용)
const xhr = new XMLHttpRequest();
xhr.open("GET", "/api/data", true);
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
```
- **AJAX**는 자바스크립트에서 서버와 비동기적으로 데이터를 주고받을 수 있게 해주는 기술이다. 페이지를 새로 고침하지 않고도 서버에서 데이터를 가져와서 웹 페이지의 일부를 동적으로 업데이트할 수 있다.
- AJAX는 **XMLHttpRequest** 객체를 통해 서버와의 비동기 통신을 처리하는데, 최근에는 **Fetch API**를 사용하는 경우가 많다.
#### 2-3. Timeout(setTimeout)
```js
// 3초 후에 "Hello"를 출력하는 예시
setTimeout(() => {
  console.log("Hello");
}, 3000);
```
- **setTimeout**은 지정된 시간 후에 특정 함수가 실행되도록 설정하는 Web API로, 비동기적으로 함수 실행을 지연시키는 데 사용된다.
- 지정된 시간(밀리초)이 지나면 첫 번째 인자로 전달한 콜백 함수가 호출된다. 

### 3. Callback Queue

##### ※ 정의
- **Callback Queue**는 자바스크립트의 **이벤트 루프(Event Loop)** 와 관련된 개념으로, 비동기 작업이 완료된 이후 실행될 콜백 함수들이 대기하는 **FIFO(First In, First Out)** 방식의 대기열이다.
##### ※ 역할
1. **비동기 작업 완료 후 실행 대기:**  
    - 비동기 작업(예: `setTimeout`, HTTP 요청, DOM 이벤트 등)이 완료되면 해당 작업에 연결된 콜백 함수가 **Callback Queue**에 추가된다.

2. **콜 스택과의 상호작용:**  
    - 이벤트 루프는 **콜 스택(Call Stack)** 이 비어 있는지 확인하고, 비어 있다면 **Callback Queue**에서 대기 중인 콜백 함수를 꺼내 **콜 스택**으로 전달하여 실행시킨다.
##### ※ 작동 원리
1. 자바스크립트 엔진은 **콜 스택**에서 동기 코드를 실행한다.
2. **비동기 함수**(`setTimeout`, `fetch` 등)가 호출되면 관련 작업이 브라우저의 **Web API** 또는 Node.js 런타임으로 위임된다.
3. 비동기 함수 작업이 완료되면, 연결된 **콜백 함수**가 **Callback Queue**에 추가된다.
4. 이벤트 루프는 콜 스택이 비었는지 확인한 뒤, **Callback Queue**에서 콜백 함수를 꺼내 콜 스택으로 넘겨 실행시킨다.

##### ※ 예제 코드 및 설명
```js
console.log("Start");

setTimeout(() => {
  console.log("Callback executed");
}, 1000);

console.log("End");
```


1. `"Start"`가 출력된다.
2. 자바스크립트 코드에서 `setTimeout(callback, delay)`가 호출된다.
	1. `setTimeout`이 호출되면, **콜 스택(Call Stack)** 에 해당 실행 컨텍스트가 올라간다. 이때 `callback` 함수는 아직 실행되지 않고, `setTimeout` 함수는 브라우저(또는 런타임 환경, Node.js 등)에 타이머 설정 요청을 전달한다.
	2. `setTimeout` 내부의 동작으로 인해 **Web API**(브라우저의 타이머 관리 시스템)에 "지정된 시간(초 단위)을 관리하라"는 요청이 전달된다.
		- 이 때 타이머와 함꼐 `callback`함수도 Web API에 전달된다.
	3. `setTimeout`의 역할은 타이머 설정 요청을 전달하는 것뿐이므로, Web API로 "지정된 시간(초 단위)을 관리하라"라는 요청을 진행하면, **콜 스택에서 사라진다.**

3. `"End"`가 출력된다.
4. 1초 후, `setTimeout`의 콜백 함수가 **Callback Queue**에 추가된다.
	- Web API는 설정된 타이머를 **비동기적으로 관리**한다고 했다. `delay` 시간(예: 1000ms)이 지나면 Web API는 타이머가 끝났음을 감지하고, `callback` 함수를 **콜백 큐(Callback Queue)** 에 추가한다.
5. 콜 스택이 비어 있으면 이벤트 루프가 콜백을 콜 스택에 넣어 실행하여 `"Callback executed"`가 출력된다.

> 처음 상태
```yaml
Call Stack: [ setTimeout ]
Web API: (빈 상태)
Callback Queue: (빈 상태)
```

> 타이머 설정 요청
```yaml
Call Stack: (빈 상태)
Web API: [ 타이머 (1000ms) ]
Callback Queue: (빈 상태)
```

> 타이머 만료 후
```yaml
Call Stack: (빈 상태)
Web API: (빈 상태)
Callback Queue: [ callback ]
```

> 콜백함수 실행
```yaml
Call Stack: [ callback ]
Web API: (빈 상태)
Callback Queue: (빈 상태)
```

### 4. Event Loop
