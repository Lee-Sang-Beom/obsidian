> https://nextjs-and-notion-vercel.vercel.app/web_basic/hoisting

#### 1. 호이스팅의 정의

- 호이스팅의 의미 자체는 **코드에 선언된 변수 및 함수를 코드의 상단으로 끌어올려, 해당 변수 및 함수 유효범위의 최상단에 선언하는 것**으로 정의되고 있다.

- 자바스크립트에서 소스 코드를 실행하는 과정은 **생성 단계**, **실행 단계**로 구분할 수 있다.
	- **생성 단계** : 코드를 순차적으로 실행하기 전, 실행 컨텍스트를 생성하면서 여러 식별자들을 스캔하며 준비하는 단계
	- **실행 단계** : 스캔 후, 선언문 외의 나머지 코드를 순차적으로 실행하는 단계

- **자바스크립트 엔진**은 코드를 실행하기 전에 함수 안을 훑으면서, 실행 가능한 코드를 형상화하고 구분하는 과정을 거친다. 이것은 실행 컨텍스트를 위한 과정이다.
	- 이 실행 컨텍스트를 위한 과정에서 발생하는 것이 **호이스팅**이다. 
	- 즉, 위에서 언급한 **생성 단계**에서 스코프 안에 존재하는 **선언된 식별자들에 대한 정보**를 기억하기 위해, 아래쪽에 존재하는 내용 중 필요한 변수와 함수의 선언을 스코프 범위의 최상단으로 **내부적으로 끌어올려 처리**하는 것이 바로 **호이스팅**이라고 볼 수 있다는 것이다.

- 스코프 상단에 선언부들이 내부적으로 끌어올려지는 것이기 때문에, 자바스크립트의 모든 선언에는 호이스팅이 일어난다고 볼 수 있다.

- **var 변수 선언**의 경우호이스팅이 정상적으로 동작하는 것으로 보이지만, **let, const, class를 이용한 선언문**은 호이스팅이 발생하지 않는 것처럼 동작한다. 이것들을 이제 천천히 살펴보도록 하자.


#### 2. 변수 호이스팅 (`var`) 

- 변수 선언(`var`)이 코드의 맨 위로 끌어올려지지만, **초기화는 끌어올려지지 않기 때문에** 변수 선언 전에 해당 변수를 사용하면 `undefined` 값이 할당된다.
	- 선언과 초기화가 함께 이루어져, `undefined`로 변수를 초기화해 메모리에 저장된다.
	- 즉, 변수 할당문을 만나기 전에 해당 변수에 접근하면 `undefined`를 출력한다.

- 아래는 `var` 키워드로 선언된 변수의 **생성단계**에 대한 내용이다. 읽어보고 넘어가도록 하자.
	1. **선언 단계**
	    - 변수를 실행 컨텍스트에 등록해, 자바스크립트 엔진에 변수의 존재를 알리는 단계
	    - 이 변수 객체는 스코프가 참조하는 대상이 된다.
	
	2. **초기화 단계**
	    - 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보하는 단계
	    - 이 단계에서 변수는 `undefined`로 초기화된다.
	
	3. **할당 단계**
	    - `undefined`로 초기화된 변수에 실제 값을 할당하는 단계

```javascript
console.log(myVar); // undefined
var myVar = 5;
console.log(myVar); // 5
```

- 위 코드는 내부적으로 아래와 같이 동작한다.
```javascript
var myVar; // 선언과 초기화가 함께 이루어져 myVar = undefined로 초기화됨
console.log(myVar); // undefined
myVar = 5;
console.log(myVar); // 5
```


#### 3. 변수 호이스팅 (`let`, `const`)

- **`let`, `const` 키워드를 통해 선언한 변수** 또한 선언문이 코드의 최상단으로 끌어올려진다.
	- **즉, 코드 실행 이전에 변수 생성 과정에서 메모리에 저장되는 과정은 맞다**. 다만 선언과 함께 초기화 과정이 이루어지지 않아, **값이 할당되지 않은 변수만 메모리에 저장**되기 때문에 변수 초기화(할당)문을 만나기 전까지는 접근할 수 없다. 
		- `let`, `const` 키워드로 선언된 변수의 경우, `var` 키워드로 선언된 변수와는 다르게 **선언 단계와 초기화 단계가 분리되어 실행된다.**
		- 자바스크립트 엔진이 식별자를 기록하긴 하지만 값을 초기화하지 않기 때문에 호이스팅이 발생하지 않는 것처럼 보이는 것이다.

    - 이렇게 `let`, `const` 키워드로 선언되는 변수의 경우, 스코프의 최상단 지점으로 끌어올려진 선언부 지점이 아니라, **변수를 실질적으로 선언하는 라인을 실행하기 이전에는** 식별자를 참조할 수 없다는 특징이 있다.
	    - 이 참조 불가능한 구역을 **일시적 사각지대(TDZ : Temporal Dead Zone)** 라고 한다.
	    - 이 영역에서 식별자를 참조하려 한다면, `ReferenceError`가 발생한다

```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = 10;
```


#### 4. 함수 호이스팅 (함수 표현식)

- 함수를 표현하는 방법 중, 변수에 함수를 담아 함수를 선언하는 방식이 있는데, 이를 **함수 표현식**이라고 한다.
	- 이 함수 표현식은, 함수를 변수에 담고있기에, **변수 호이스팅**과 똑같이 동작한다.

- `var` 키워드로 선언한 함수를 선언문 이전에 실행하려 하면, 이 함수에는 `undefined`가 저장되어 있으므로, 이 데이터 타입은 호출될 수 없다. 따라서 **Type Error**가 발생한다.
```js
sayHello(); // TypeError: sayHello is not a function

var sayHello = function() {
  console.log("Hello, World!");
};
```

- `let`, `const` 키워드로 선언한 함수를 선언문 이전에 실행하려 하면, 초기화 단계를 거치지 않았으므로, **Reference Error**가 발생한다.
```js
sayHello(); // ReferenceError: Cannot access 'sayHello' before initialization
const sayHello = function() {
  console.log("Hello, World!");
};
```


#### 5. 함수 호이스팅 (함수 선언문)

- 함수 표현식과 달리, `function` 키워드로 함수를 선언하는 **함수 선언문**은 동작방식과 그 결과가 조금 다르다.
	- 함수 선언문 방식으로 함수를 선언하는 경우의 호이스팅은, 자바스크립트 엔진이 함수 선언과 동시에, 완성된 함수객체를 생성해 환경 레코드에 기록하는 방식으로 이루어진다.

- 즉, **함수의 선언 자체가 코드의 최상단으로 끌어올려진다는 뜻**이다. 
	- 이러한 함수 선언문 방식은 선언과 동시에 함수가 생성된다는 특징을 가지기 때문에 **에러없이 정상실행**된다.
```javascript
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```