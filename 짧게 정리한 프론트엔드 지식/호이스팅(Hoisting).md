> https://nextjs-and-notion-vercel.vercel.app/web_basic/hoisting

### 1. 호이스팅의 정의

- 호이스팅의 의미 자체는 **코드에 선언된 변수 및 함수를 코드의 상단으로 끌어올려, 해당 변수 및 함수 유효범위의 최상단에 선언하는 것**으로 정의되고 있다.

- 자바스크립트에서 소스 코드를 실행하는 과정은 **생성 단계**, **실행 단계**로 구분할 수 있다.
	- **생성 단계 (Creation Phase)**: 코드 실행 전에, **변수와 함수 선언을 스캔**하여 준비한다. 이 때, 변수와 함수 선언이 메모리로 끌어올려지는 **호이스팅**이 발생한다.
	- **실행 단계 (Execution Phase)**: 코드가 실제로 실행되며, 변수에 값을 할당하고 함수가 호출된다.

- **자바스크립트 엔진**은 코드를 실행하기 전에 함수 안을 훑으면서, 실행 가능한 코드를 형상화하고 구분하는 과정을 거친다. 이것은 실행 컨텍스트를 위한 과정이다.
	- 이 실행 컨텍스트를 위한 과정에서 발생하는 것이 **호이스팅**이다. 
	- 즉, 위에서 언급한 **생성 단계**에서 스코프 내에 **선언된 식별자들에 대한 정보**를 기억하기 위해, 아래쪽에 존재하는 내용 중 필요한 변수와 함수의 선언을 스코프 범위의 최상단으로 **내부적으로 끌어올려 처리**하는 것이 바로 **호이스팅**이라고 볼 수 있다는 것이다.

- 스코프 상단에 선언부들이 내부적으로 끌어올려지는 것이기 때문에, 자바스크립트의 모든 선언에는 호이스팅이 일어난다고 볼 수 있다.

- **var 변수 선언**의 경우, 호이스팅이 정상적으로 동작하는 것으로 보이지만, **let, const, class를 이용한 선언문**은 호이스팅이 발생하지 않는 것처럼 동작한다. 이것들을 이제 천천히 살펴보도록 하자.


### 2. 변수 호이스팅 (`var`) 

- 변수 선언(`var`)이 코드의 맨 위로 끌어올려지지만, **초기화는 함께 진행되지 않기 때문에** 변수 선언 전에 해당 변수를 사용하면 `undefined` 값이 할당된다.
	- 생성단계에서, 선언과 초기화가 함께 이루어져, `undefined`로 변수를 초기화해 메모리에 저장된다.
	- 즉, 변수 할당문을 만나기 전에 해당 변수에 접근하면 `undefined`를 출력한다.

- 아래는 `var` 키워드로 선언된 변수의 **생성단계**에 대한 내용이다. 읽어보고 넘어가도록 하자.
	1. **선언 단계**
	    - 변수를 실행 컨텍스트에 등록해, 자바스크립트 엔진에 변수의 존재를 알리는 단계
	    - 이 변수 객체는 스코프가 참조하는 대상이 된다.
	
	2. **초기화 단계**
	    - 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보하는 단계
	    - 이 단계에서 변수는 `undefined`로 초기화된다.
	
	3. **할당 단계**
	    - `undefined`로 초기화된 변수에 실제 값을 할당하는 단계

- 	- **변수 선언을 메모리에 등록**:
		    - 변수는 **호이스팅**되어 메모리 상에서 선언만 처리된다. 이때 `var` 키워드로 선언된 변수는 **`undefined`** 로 초기화되고, `let`,`const`로 선언된 변수는 메모리 상에 "선언"만 처리된다.
		- **함수 선언을 메모리에 등록**:
		    - 함수 선언문은 **전체 함수**가 메모리에 올라간다. 즉, 함수 선언 자체가 **호이스팅**되어, 호출하기 전에 함수의 **전체 내용**을 사용할 수 있다.
	
```javascript
console.log(myVar); // undefined
var myVar = 5;
console.log(myVar); // 5
```

- 위 코드는 내부적으로 아래와 같이 동작한다.
```javascript
var myVar; // 선언과 초기화가 함께 이루어져 myVar = undefined로 초기화됨
console.log(myVar); // undefined
myVar = 5;
console.log(myVar); // 5
```


### 3. 변수 호이스팅 (`let`, `const`)

- **`let`, `const` 키워드를 통해 선언한 변수** 또한 선언문이 코드의 최상단으로 끌어올려진다.
	- **즉, 코드 실행 이전에 변수 생성 과정에서 메모리에 저장되는 과정은 맞다**. 다만 선언과 함께 초기화 과정이 이루어지지 않아, **값이 할당되지 않은 변수만 메모리에 저장**되기 때문에 변수 초기화(할당)문을 만나기 전까지는 접근할 수 없다. 
		- `let`, `const` 키워드로 선언된 변수의 경우, `var` 키워드로 선언된 변수와는 다르게 **선언 단계와 초기화 단계가 분리되어 실행된다.**
		- 자바스크립트 엔진이 식별자를 기록하긴 하지만 값을 초기화하지 않기 때문에 호이스팅이 발생하지 않는 것처럼 보이는 것이다.
	
	- 결론은, 생성단계에서 선언만 메모리에 올라가고 값은 할당되지 않는다.

    - 이렇게 `let`, `const` 키워드로 선언되는 변수의 경우, 스코프의 최상단 지점으로 끌어올려진 선언부 지점이 아니라, **변수를 실질적으로 선언하는 라인을 실행하기 이전에는** 식별자를 참조할 수 없다는 특징이 있다.
	    - 이 참조 불가능한 구역을 **일시적 사각지대(TDZ : Temporal Dead Zone)** 라고 한다.
	    - 이 영역에서 식별자를 참조하려 한다면, `ReferenceError`가 발생한다

```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = 10;
```


### 4. 함수 호이스팅 (함수 표현식)

- 함수를 표현하는 방법 중, 변수에 함수를 담아 함수를 선언하는 방식이 있는데, 이를 **함수 표현식**이라고 한다.
	- 이 함수 표현식은, 함수를 변수에 담고있기에, **변수 호이스팅**과 똑같이 동작한다.

- `var` 키워드로 선언한 함수를 선언문 이전에 실행하려 하면, 이 함수에는 `undefined`가 저장되어 있으므로, 이 데이터 타입은 호출될 수 없다. 따라서 **Type Error**가 발생한다.
```js
sayHello(); // TypeError: sayHello is not a function

var sayHello = function() {
  console.log("Hello, World!");
};
```

- `let`, `const` 키워드로 선언한 함수를 선언문 이전에 실행하려 하면, 초기화 단계를 거치지 않았으므로, **Reference Error**가 발생한다.
```js
sayHello(); // ReferenceError: Cannot access 'sayHello' before initialization
const sayHello = function() {
  console.log("Hello, World!");
};
```

- 메모리에 올라가는 내용은 변수 선언문과 동일하게 동작한다.


### 5. 함수 호이스팅 (함수 선언문)

- 함수 표현식과 달리, `function` 키워드로 함수를 선언하는 **함수 선언문**은 동작방식과 그 결과가 조금 다르다.
	- 함수 선언문 방식으로 함수를 선언하는 경우의 호이스팅은, 자바스크립트 엔진이 함수 선언과 동시에, 완성된 함수객체를 생성해 환경 레코드에 기록하는 방식으로 이루어진다.

- 즉, **함수의 선언 자체가 코드의 최상단으로 끌어올려진다는 뜻**이다. 
	- 이러한 함수 선언문 방식은 선언과 동시에 함수가 생성된다는 특징을 가지기 때문에 **에러없이 정상실행**된다.
	- 함수의 경우, 
```javascript
sayHello(); // "Hello, World!"

function sayHello() {
  console.log("Hello, World!");
}
```

- 함수 선언문은 호이스팅 발생 시, 함수 전체가 메모리로 올라가기 때문에 함수를 바로 호출할 수 있게 된다.


### 6. 호이스팅이 필요한 이유

##### 1. 실행 컨텍스트와 호이스팅

```js
function example() {
    console.log(a); // undefined
    var a = 10;
    console.log(a); // 10
}

example();
```
###### 1. 생성 단계 (실행 컨텍스트 생성) (Creation Phase)
- `example` 함수가 호출되면서 자바스크립트 엔진은 새로운 **실행 컨텍스트**를 생성한다.
- **생성 단계**에서는 두 가지 일이 발생한다:
    - 변수 호이스팅(`var a = 10`)이 발생한다.
	    - `a`는 호이스팅되어 메모리 상에 등록되지만, 값은 아직 할당되지 않았다. 그래서 `a`는 `undefined`로 초기화된다.
    - **함수 선언문**이 호이스팅되어. `example` 함수 전체가 메모리로 올라간다. 그래서, 함수를 바로 호출할 수 있게 된다.

###### 2. 실행 단계 (Execution Phase)
- 자바스크립트 엔진은 코드가 작성된 순서대로 실행된다.
    - **첫 번째 `console.log(a)`** 가 호출되면, `a`는 이미 메모리에 존재하지만 값은 **아직 할당되지 않았기 때문에 `undefined`가 출력**된다.
    - `a = 10`이 실행되어 `a`에 값이 할당된다.
    - **두 번째 `console.log(a)`** 는 이제 `a`의 값이 `10`이기 때문에, `10`이 출력된다.


##### 2. 예제 실행에서 호이스팅이 필요한 이유
- 자바스크립트 엔진은 **실행 컨텍스트의 생성 단계**에서 변수와 함수 선언을 미리 처리해야 하기 때문에, **호이스팅이 필요**하다. 
	- 호이스팅이 없었다면, 변수나 함수가 호출되기 전에 선언되지 않으면 **참조 오류**가 발생했을 것이다.
```js
function example() {
    console.log(a); // ReferenceError: a is not defined
    var a = 10;
}

example(); // 호이스팅이 없으면, 변수 `a`가 선언되기 전에 `console.log(a)`를 호출할 수 없으므로, 참조 오류 (ReferenceError)가 발생
```

##### 3. 호이스팅이 실행 컨텍스트에 미치는 영향 및 요약

###### ※ 영향
- 실행 컨텍스트는 자바스크립트 코드가 **정상적으로 실행되도록 보장**해야 한다. 
	- 특히나 자바스크립트는 코드를 한 줄씩 순차적으로 읽고 실행하는 인터프리터 언어임과 함께 변수와 함수의 선언문이 작성된 위치와 이를 실행하는 코드 위치가 분리되어 있다.
	- 이 때 **호이스팅**은 변수나 함수 선언을 **실행 전 준비**해 놓음으로써 코드 실행 중 오류를 방지하고, **예상대로 동작하도록 돕는 역할**을 한다.

###### ※ 요약
- **실행 컨텍스트**는 자바스크립트 코드가 실행될 때, 코드 실행에 필요한 정보를 관리하는 환경이다.
- 실행 컨텍스트의 **생성 단계**에서 **호이스팅**이 발생하여 변수와 함수 선언이 메모리로 끌어올려진다.
- **호이스팅** 덕분에 **변수와 함수 선언을 실행 전에 메모리로 끌어올려** 코드가 어디에서든 **예상대로 동작**할 수 있도록 보장된다.
- **호이스팅이 없었다면**, 코드 실행 전 변수나 함수가 선언되지 않으면 **참조 오류**가 발생했을 것이다.

즉, 호이스팅은 코드 실행 전에, 자바스크립트 엔진이 **실행 컨텍스트 내에서 선언된 변수와 함수**를 스코프 범위의 최상단으로 내부적으로 끌어올려 처리하는 방식으로 미리 준비하여 코드가 **일관되게 실행되도록 돕는 중요한 메커니즘**입니다.
