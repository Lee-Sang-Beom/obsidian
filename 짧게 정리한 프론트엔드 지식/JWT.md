> [참고자료: 김츄의 개발일지](https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token)

#### 1. JWT 토큰이란?

- JWT(Json Web Token)는 **JSON 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰**이다.
- **JSON** 포맷을 이용하여 사용자에 대한 속성을 저장하는 **Claim** 기반의 Web 토큰으로, JWT는 필요한 정보를 자체적으로 지니는 **Self-Contained** 방식으로 정보를 안정성 있게 전달한다.

- 사용자가 JWT 를 서버로 전송하면, 서버는 **서명**이라는 것을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다.


#### 2. JWT 프로세스

 >로그인 전
1. 사용자가 ID/PW 혹은 소셜 로그인을 이용하여 서버에 **로그인 요청**을 보낸다.
2. 서버는 **비밀키**를 사용하여, JSON 객체를 암호화한 JWT 토큰을 발급한다.
3. JWT를 Header에 담아 클라이언트에 보낸다.

> 로그인 후
1. 클라이언트는 JWT를 **로컬**에 저장해놓는다.
2. API 호출을 할 때마다 header에 JWT를 포함하여 전달한다.
3. 서버는 header를 매번 확인하여 사용자가 신뢰할만한지 체크하고, 인증이 완료되면 API에 대한 응답을 보낸다.


#### 3. JWT 구조

- JWT는 아래의 요소들로 구성되어 있다.
	1. **Header**
	2. **Payload**
	3. **Signature**

- JSON으로 포맷된 각 부분은 **Base64**로 인코딩되어 표현되며, 각각의 구성 요소는 **.(점)** 으로 구분한다.

> [!note] Base64
> - 데이터를 효율적으로 전송하거나 저장하기 위해 사용되는 인코딩 방식 중 하나이다.
> - 주로, 이진 데이터를 텍스트 형식으로 변환하는 데에 사용된다.
> - 64개의 고유한 문자로 구성되어 있으며, 이진 데이터를 ASCII 문자 집합으로만 이루어진 형태로 변환하여, 다양한 시스템 간에 데이터를 전송하거나 저장할 때 호환성을 보장한다.
> - 데이터를 암호화하기보다는, 다른 형식으로 변환한다고 보아야 한다. (보안 기능이 없다.)

![[JWT structure.png]]

> **1️⃣ Header(헤더)**
- 토큰의 헤더는 **alg**, **typ**로 구성된다.
	- `alg`: 해싱 알고리즘으로, 서명(Signature) 및 토큰 검증에 사용된다.
		- *Signature*에서 사용하는 알고리즘은 대표적으로 **RS256(공개키/비대칭키/개인키)** 와 **HS256(비밀키/대칭키)** 가 있다.
	- `typ`: 토큰의 타입

> **2️⃣ Payload(페이로드)**
- 토큰의 Payload에는 토큰에서 사용할 정보의 조각들을 일컫는 **클레임(Claim)** 이 포함되어 있다.
	- 클레임(Claim)은 **등록된 클레임(Registered Claim)**, **공개 클레임(Public Claim)**, **비공개 클레임(Private Claim)** 으로 나뉘어진다.
	- 클레임(Claim)은 `key-value` 형태로 존재한다.

- 실질적으로 JWT를 통해서 알 수 있는 데이터가 이 부분에 포함되어 있다.
	- 즉, 서버와 클라이언트가 주고받는 시스템에서 실제로 **사용될 정보에 대한 내용**을 담고 있는 영역이라 볼 수 있다.

> [!note] 등록된 클레임(Registered Claim)
> - 토큰 정보를 표현하기 위하여 이미 정해진 종류의 데이터들이다. (사용 권장됨)
> 	- iss: 토큰 발급자(issuer)
> 	- sub: 토큰 제목(subject)으로, 유니크한 값을 사용한다. (주로 유저 이메일 사용)
> 	- aud: 토큰 대상자(audience)
> 	- exp: 토큰 만료시간(expiration)으로, NumbericDate 형식(ex: YYYYMMDD)으로 되어 있어야 한다.
> 	- nbf: 토큰 활성날짜(not before)
> 	- iat: 토큰 발급시간(issued at)으로, 토믄 발급 이후의 경과 시간
> 	- jti: JWT 토큰 식별자(JWT ID)로, 중복 방지를 위하여 일회용 토큰(Access Token) 등에 사용된다.

> [!note] 공개 클레임(Public Claim)
> - 사용자 정의 클레임으로, **공개용 정보**를 위해 사용된다.
> - 충돌 방지를 위하여, URI 포맷을 이용한다.

> [!note] 비공개 클레임(Private Claim)
> - 사용자 정의 클레임으로, **서버와 클라이언트 사이에 임의로 지정한 정보**를 저장한다.
> - 특정 당사자 간들끼리 정보를 공유하기 위해 만들어진 사용자 지정 클레임이며, 외부에 공개되어도 상관없지만 해당 유저를 특정할 수 있는 정보들을 담는다

> [!note] **주의**
> - JWT는 Base64로 암호화를 하기 때문에 디버거를 사용해서 인코딩된 JWT를 1초만에 복호화할 수 있다.
> - 이는 복호화 시, 사용자의 데이터를 담은 Payload 부분이 그대로 노출되어 버린다는 것을 의미한다.
> 	- 그래서 페이로드에는 비밀번호와 같은 민감한 정보는 넣지 말아야 한다.

> **3️⃣ Signature(서명)**
- 서명(Signature)은 **토큰을 인코딩**하거나 **유효성 검증**을 할 때 사용하는 고유한 암호화 코드이다.
	- 서명(Signature)은 Header(헤더)와 Payload(페이로드), 그리고 비밀 키(서버가 갖고 있는 유일한 key값)을 기반으로 생성된다.
	- Header(헤더)에서 정의한 알고리즘(`alg`)으로 암호화를 진행한다.

- Header와 Payload는 단순히 Base64로 인코딩되어 있을 뿐이라 누구나 쉽게 복호화가 가능하지만,  서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다
	- 이를 통해 Signature는 **보안상 안전하다**는 특성을 가진다고 말할 수 있다.

 - Signature(서명)는 **해당 토큰이 위조/변조되지 않았음을 확인**하는 데에 사용되는 **매커니즘**이다.

 **※ 서명 생성 과정**
1. 헤더(Header)와 페이로드(Payload)의 값을 각각 **Base64**로 인코딩
2. 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 **해싱(Hashing)**
3. 해싱한 값을 다시 **Base64**로 인코딩하여 생성

- 서버는 **해당 토큰이 위조된 토큰인지 아니면 유효한 토큰인지 검증하는 것을 중요시한다.**
	- 클라이언트로부터 받은 JWT의 Header, Payload를 서버의 key(비대칭키 혹은 대칭키)값을 이용하여 Sigature(서명)를 만들고, 이를 비교하여 **일치했을 경우에만 인증을 통과**시킨다.
	- Sigature(서명) 생성에 사용된 비밀키가 노출되지 않는 이상, 데이터를 위조해도 Sigature(서명) 부분에서 바로 위조 여부를 검증할 수 있다.

> [!note] JWT = A(Header) + B(Payload) + C(Signature) 위조 시나리오
> 1. 타 유저가 Payload를 임의로 수정 : `JWT = A+B'+C`
> 2. 수정한 토큰을 request header에 담아 서버로 전달 : `JWT = A+B'+C`
> 3. 서버는 클라이언트로부터 받은 Token의 유효성 검사를 시작 : `JWT=A+B'+C'`
> 4. `A`와 `B'`를 기반으로 하고, 비밀키인 key값을 이용하여 서버는 Sigature(서명) `C'`를 생성
> 	- 이 때, 유저는 `JWT = A+B'+C`를 전달했고, 서버는 `JWT=A+B'+C'`를 받아야 하므로, 대조결과가 불일치
> 	- 왜냐하면, 변조 이전의 JWT에 대한 정보는 서버가 알고있고, 변조된 payload로 인해 생성된 signature를 이용해 만든 JWT는 변조 이전의 JWT와 다른 값이기 때문
> 
> 5. 사용자 인증이 실패함


#### 4. JWT 암호화 방법

- JWT의 생성은 Header와 Payload 정보를 인코딩하고, 이들을 합친 문자열에 대해 비밀 키로 **Sigature(서명)** 을 생성하는 방식을 사용한다.
	- 이 때, Header에서 선언한 알고리즘에 따라 key는 **비대칭키**가 될 수도 있고 **대칭키**가 될 수도 있다. 
		- `alg: RS256`(공개키/비대칭키/개인키)
		- `alg: HS256`(비밀키/대칭키)

> [!note] 비대칭키(공개키/개인키)
> - 암호화/복호화 키가 다른 방식
> - 다른 키를 사용하여 암호화 및 복호화를 수행하므로, 속도가 느리지만 안전하다.
> - 공개키는 공개적으로 제공하며, 어떠한 서버든 이 공개키를 통해 JWT를 복호화할 수 있다.

> 비대칭키 동작 과정 [(이미지 출처: liveyourit tistory)](https://liveyourit.tistory.com/183)
![[비대칭키 동작.png]]


> [!note] 대칭키(비밀키)
> - 암호화/복호화 키가 같은 방식
> - 같은 키를 사용하여 암호화 및 복호화를 수행하므로, 속도가 빠르다.
> - 비밀키를 알고있는 서버만 Signature 유효성 검증을 통해 JWT를 복호화할 수 있다.
> - 안전한 키 교환 방식이 요구된다. (사람이 많을수록 키 관리가 어려워진다.)

> 대칭키 동작 과정 [(이미지 출처: 하루한방울님의 포스트)](https://gunjoon.tistory.com/149)
![[대칭키 동작.png]]


#### 5. 동작 과정 (JWT Process)

> JWT 동작과정 [(이미지 출처: opennaru 블로그)](http://www.opennaru.com/opennaru-blog/jwt-json-web-token/)

![[jwt process.webp]]

> [!note] JWT 동작 과정
> 1. 사용자가 ID/PW를 입력하여 로그인 요청
> 2. 서버는 요청을 확인한 후, 비밀키를 이용하여 JWT를 만든다.
> 	- JWT는 Access Token의 한 유형이다.
> 3. 서버는 클라이언트에게 JWT를 전달한다.
> 4. 이후, 클라이언트(사용자)는 서비스 이용과 같은 이유로 서버에게 JWT 전달
> 	- 이 때, `fetch, ajax, axios`등의 API를 사용할 수 있으며, API를 요청할 때 `Authorization: Access token`을 담아 보낸다.
> 5. 서버는 전달받은 JWT의 Sigature를 체크(체크 과정은 위조 시나리오 참고)한 다음 , Payload로부터 사용자 정보를 확인한다
> 6. 서버는 클라이언트 요청에 대한 적절한 응답을 반환한다.

- 추가적으로 API 사용 시, `Authorization header`에 Access-token을 담아 보내는 예제는 아래와 같다.
```js
fetch(
      `https://dapi.kakao.com/v2/local/search/address.json?query=${address}`,
      {
        headers: {
          Authorization: `KakaoAK ${ACCESS_TOKEN}`,
        },
      }
    )
      .then((result) => result.json())
      .then((jsonResult) => {
        if (jsonResult.documents.length !== 0) {
          // 추후 x, y 좌표가 백엔드  request에 요구될 경우
          setValue("lot", jsonResult.documents[0].x.toString());
          setValue("lat", jsonResult.documents[0].y.toString());
          setValue("roadNmAddr", address);

          // setValue("zipCode", zoneCode);
          // setValue("addr", address);
          // setTimeout(async () => {
          //   trigger("addr");
          // }, 10);
        } else {
          alert("유효한 주소가 아닙니다.");
        }
      });
```


#### 6. 장점 및 단점

> **장점**
- **사용자 인증에 필요한 모든 정보가 토큰 자체에 포함되어 있다.**
	- 서버를 대상으로 한, API 요청마다 request header(Authorization)에 토큰을 포함하여 보내는 것이 JWT 사용 인증방식의 특징이다.
	- 이는, 인증 서버와 데이터베이스에 의존하지 않아도 되게끔 한다.

- 위와 비슷한 내용이지만, 조금 다른 게 있다. 
	- JWT는 토큰 자체에 사용자의 정보가 저장되기 때문에, 서버 입장에서는 **토큰을 검증**해주기만 하면 된다.
	- JWT를 사용하지 않고, 쿠키(Cookies)와 세션(Session)을 사용하는 경우에는 서버 측에 로그인한 **모든 사용자의 세션을 데이터베이스나 캐시에 저장**해놓고, 쿠키로 넘어온 Session ID로 사용자 데이터를 매번 조회해야만 한다.

- HTTP 헤더를 통해, 간단하게 전송할 수 있으므로 네트워크 부하가 적다.


> **단점**
- 서버로부터 받은 토큰은 **쿠키 혹은 로컬 스토리지 및 세션 스토리지**에 저장되기 때문에, 탈취당할 위험이 있으므로 token에 중요 정보를 넣지 않아야 한다.
	- 위에서, **Header, Payload**는 Base64로 인코딩된다고만 했지, 보안 기능은 존재하지 않는다고 짚고 넘어갔다. 그 이야기이다.

- 토큰에 넣는 데이터가 많아질수록, 토큰은 길어진다. (데이터 트래픽 크기에 영향)
	- 이전에, API를 호출할 때마다 header에 JWT를 포함하여 서버에 전달해야 한다고 했다.
	- 이 때, **토큰이 길어지는 만큼, 그리고 API 요청 빈도수가 늘어나는 만큼 네트워크 대역폭 낭비가 심해질 수 있다는 문제**가 있다.

- 한번 발급된 token은 만료 기간 변경이 불가능하기 때문에 **토큰 만료 처리**를 구현해야 한다.
	- 또한, 서버 측에서 직접 클라이언트에 저장된 token을 변경해줄 수도 없다.