> [참고자료: 김츄의 개발일지](https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token)

#### 1. JWT 토큰이란?

- JWT(Json Web Token)는 **JSON 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰**이다.
- **JSON** 포맷을 이용하여 사용자에 대한 속성을 저장하는 **Claim** 기반의 Web 토큰으로, JWT는 필요한 정보를 자체적으로 지니는 **Self-Contained** 방식으로 정보를 안정성 있게 전달한다.


#### 2. JWT 프로세스

 >로그인 전
1. 사용자가 ID/PW 혹은 소셜 로그인을 이용하여 서버에 **로그인 요청**을 보낸다.
2. 서버는 **비밀키**를 사용하여, JSON 객체를 암호화한 JWT 토큰을 발급한다.
3. JWT를 Header에 담아 클라이언트에 보낸다.

> 로그인 후
1. 클라이언트는 JWT를 **로컬**에 저장해놓는다.
2. API 호출을 할 때마다 header에 JWT를 포함하여 전달한다.
3. 서버는 header를 매번 확인하여 사용자가 신뢰할만한지 체크하고, 인증이 완료되면 API에 대한 응답을 보낸다.


#### 3. JWT 구조

- JWT는 아래의 요소들로 구성되어 있다.
	1. **Header**
	2. **Payload**
	3. **Signature**

- JSON으로 포맷된 각 부분은 **Base64**로 인코딩되어 표현되며, 각각의 구성 요소는 **.(점)** 으로 구분한다.

> [!note] Base64
> - 데이터를 효율적으로 전송하거나 저장하기 위해 사용되는 인코딩 방식 중 하나이다.
> - 주로, 이진 데이터를 텍스트 형식으로 변환하는 데에 사용된다.
> - 64개의 고유한 문자로 구성되어 있으며, 이진 데이터를 ASCII 문자 집합으로만 이루어진 형태로 변환하여, 다양한 시스템 간에 데이터를 전송하거나 저장할 때 호환성을 보장한다.
> - 데이터를 암호화하기보다는, 다른 형식으로 변환한다고 보아야 한다. (보안 기능이 없다.)

![[JWT structure.png]]

> **1️⃣ Header(헤더)**
- 토큰의 헤더는 **alg**, **typ**로 구성된다.
	- `alg`: 해싱 알고리즘으로, 서명(Signature) 및 토큰 검증에 사용된다.
		- *Signature*에서 사용하는 알고리즘은 대표적으로 **RS256(공개키/비대칭키/개인키)** 와 **HS256(비밀키/대칭키)** 가 있다.
	- `typ`: 토큰의 타입

> **2️⃣ Payload(페이로드)**
- 토큰의 Payload에는 토큰에서 사용할 정보의 조각들을 일컫는 **클레임(Claim)** 이 포함되어 있다.
	- 클레임은 **등록된 클레임(Registered Claim)**, **공개 클레임(Public Claim)**, **비공개 클레임(Private Claim)** 으로 나뉘어진다.
	- 클레임은 `key-value` 형태로 존재한다.

> [!note] 등록된 클레임(Registered Claim)
> - 토큰 정보를 표현하기 위하여 이미 정해진 종류의 데이터들이다. (사용 권장됨)
> 	- iss: 토큰 발급자(issuer)
> 	- sub: 토큰 제목(subject)으로, 유니크한 값을 사용한다. (주로 유저 이메일 사용)
> 	- aud: 토큰 대상자(audience)
> 	- exp: 토큰 만료시간(expiration)으로, NumbericDate 형식으로 되어 있어야 한다.
> 	- nbf: 토큰 활성날짜(not before)
> 	- iat: 토큰 발급시간(issued at)으로, 토믄 발급 이후의 경과 시간
> 	- jti: JWT 토큰 식별자(JWT ID)로, 중복 방지를 위하여 일회용 토큰(Access Token) 등에 사용된다.

> [!note] 공개 클레임(Public Claim)
> - 사용자 정의 클레임으로, 공개용 정보를 위해 사용된다.
> - 충돌 방지를 위하여, URI 포맷을 이용한다.

> [!note] 비공개 클레임(Private Claim)
> - 사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장한다.

> **3️⃣ Signature(서명)**
- 서명(Signature)은 **토큰을 인코딩**하거나 **유효성 검증**을 할 때 사용하는 고유한 암호화 코드이다.
	- Header(헤더)와 Payload(페이로드), 그리고 비밀 키를 기반으로 생성되며 **해당 토큰이 변조되지 않았음을 확인**하기 위한 메커니즘이다.

- 정리하면, Header와 Payload는 단순히 Base64로 인코딩되어 있을 뿐이라 누구나 쉽게 복호화가 가능하지만, Signature는 key가 없으면 복호화할 수 없다.
	- 이를 통해 Signature는 **보안상 안전하다**는 특성을 가진다고 말할 수 있다.

 **※ 서명 생성 과정**
1. 헤더(Header)와 페이로드(Payload)의 값을 각각 **Base64**로 인코딩
2. 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 **해싱(Hashing)**
3. 해싱한 값을 다시 **Base64**로 인코딩하여 생성


#### 4. JWT 암호화 방법

- JWT의 생성은 Header와 Payload 정보를 인코딩하고, 이들을 합친 문자열에 대해 비밀 키로 서명을 생성하는 방식을 사용한다.
	- 이 때, Header에서 선언한 알고리즘에 따라 key는 **비대칭키**가 될 수도 있고 **대칭키**가 될 수도 있다. 
		- `alg: RS256`(공개키/비대칭키/개인키)
		- `alg: HS256`(비밀키/대칭키)

> [!note] 비대칭키(공개키/개인키)
> - 암호화/복호화 키가 다른 방식
> - 다른 키를 사용하여 암호화 및 복호화를 수행하므로, 속도가 느리지만 안전하다.
> - 공개키는 공개적으로 제공하며, 어떠한 서버든 이 공개키를 통해 JWT를 복호화할 수 있다.

> [!note] 대칭키(비밀키)
> - 암호화/복호화 키가 같은 방식
> - 같은 키를 사용하여 암호화 및 복호화를 수행하므로, 속도가 빠르다.
> - 비밀키를 알고있는 서버만 Signature 유효성 검증을 통해 JWT를 복호화할 수 있다.
> - 안전한 키 교환 방식이 요구된다. (사람이 많을수록 키 관리가 어려워진다.)

> https://liveyourit.tistory.com/183


#### 5. 장점 및 단점

> 장점
- auth0을 이용하면 아이디를 카카오, 네이버처럼 다른 사이트에서 이용할 수 있음
- 서버측 부하를 낮출 수 있고 독립적이기 때문에 능률적으로 접근 권한 관리를 할 수 있고 분산/클라우드 기반 인프라 스트럭처에 잘 대응할 수 있음
- 별도의 인증 저장소가 필요하지 않아서 인증서버와 db에 의존하지 않아도 됨

> 단점
- 서버로부터 받은 토큰이 쿠키 또는 로컬스토리지, 세션스토리지에 저장이 되므로 탈취당할 위험이 있으므로 token에 중요 정보를 넣지 않아야 함
- 토큰에 넣는 데이터가 많아질수록 토큰이 길어지는데 API를 호출할 때마다 토큰 데이터를 서버에 전달해야하므로 그만큼 네트워크 대역폭 낭비가 심할 수 있음
- 한번 발급된 token은 수정, 폐기가 불가 **➡︎** **Access token**, **Refresh token** 사용