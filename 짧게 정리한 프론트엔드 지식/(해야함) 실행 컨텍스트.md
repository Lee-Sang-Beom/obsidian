https://www.nextree.io/execution-context/

### 1. 실행 컨텍스트의 정의

- 자바스크립트의 **실행 컨텍스트**는 코드가 실행되는 환경을 정의하는 기본 개념이다.
	- 일단 추상적으로만 말해보면, **자바스크립트가 코드를 실행할 때 필요한 모든 정보를 담고 있는 박스**라고 생각하면 된다.
	- 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다.

- 실행 컨텍스트는 동일한 환경에 있는 **코드들을 실행할 때 필요한** **환경 정보**들을 모아 구성된 객체이다.
	- 코드를 실행하기 위해 객체로서 모인 이 환경 정보들은, **콜 스택**에 쌓아올려지고, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 **전체 코드의 환경과 순서가 보장**된다.

---
### 2. 실행 컨텍스트의 역할

##### 1. 변수 관리
###### ※ 변수 선언 및 초기화 관리
- 실행 컨텍스트는 함수나 전역에서 선언된 변수들을 메모리에 등록하고 초기화한다.
- 선언 단계에서 변수는 `undefined`로 초기화된다. (`var`기준)
- 함수 선언은 실행 전에 메모리에 저장된다.
    - **호이스팅**: 선언된 변수와 함수가 코드의 상단으로 끌어올려지는 것처럼 동작한다.

```js
console.log(a); // undefined
var a = 10;
function foo() { return "Hello"; }
```

##### 2. 스코프 관리
###### ※ 스코프 체인 생성
- 실행 컨텍스트는 현재 코드에서 접근할 수 있는 변수와 함수의 유효 범위를 결정한다.
- 내부 함수는 외부 함수의 스코프에 접근할 수 있으며, 이를 **스코프 체인**이라 한다.
###### ※ Lexical Environment (어휘적 환경) 관리
- 실행 중인 코드의 스코프와 관련된 정보를 저장한다.
    - **전역 환경**: 전역 변수와 함수
    - **함수 환경**: 함수 내부의 지역 변수와 매개변수

```js
function outer() {
    let a = 1;
    function inner() {
        console.log(a); // outer의 스코프에 접근 가능
    }
    inner();
}
outer();
```

##### 3. `this` 바인딩
- 실행 컨텍스트는 **`this` 키워드**의 값을 결정한다.
	- **전역 컨텍스트**: 전역 객체(`window` 또는 `global`)
	- **함수 컨텍스트**: 함수 호출 방식에 따라 결정
	    - 일반 함수 호출: `undefined`(strict 모드) 또는 전역 객체
	    - 객체의 메서드 호출: 메서드를 호출한 객체
	    - 화살표 함수: 선언 시점의 상위 스코프에서 `this`를 결정

```js
const obj = {
    a: 10,
    method() {
        console.log(this.a); // obj의 a
    }
};
obj.method();
```

##### 4. 코드 실행 흐름 제어
- 실행 컨텍스트는 자바스크립트 코드의 **실행 순서**를 가리킨다.
	- 콜 스택에 쌓이고, 실행이 끝나면 콜 스택에서 제거된다.
	- 비동기 작업의 경우, 이벤트 루프와 호출 스택이 협력하여 실행 흐름을 제어한다.

```js
function first() {
    console.log("First");
}
function second() {
    console.log("Second");
}
first();
second(); // 호출 순서대로 실행: first() => second() 실행 순서가 보장된다.
```

##### 5. 클로저와 메모리 관리
- 실행 컨텍스트는 함수 종료 이후에도 변수나 함수가 계속 참조되고 있다면, 이를 유지한다.
- 이를 통해 **클로저**가 가능하며, 스코프 외부에서도 변수에 접근할 수 있다.
	- 클로저 : 반환된 내부함수와 내부함수가 선언되었던 렉시컬 환경의 조합

```js
function makeCounter() {
    let count = 0;
    return function() {
        return ++count; // 클로저를 통해 count 유지
    };
}
const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

##### 6. 호출 스택 관리
- 실행 컨텍스트는 **콜 스택**에 쌓이고, 실행이 끝나면 콜 스택에서 제거된다.
	- **전역 실행 컨텍스트**는 프로그램이 종료될 때까지 콜 스택에 유지된다.
	- 함수 호출 시마다, 새로운 실행 컨텍스트가 생성되어 **콜 스택**에 추가된다.

```js
function a() {
    b();
}
function b() {
    console.log("b");
}
a(); // 호출 스택: global → a → b
```

##### 7. 환경 정보 관리
- 실행 컨텍스트는 현재 실행 중인 코드와 관련된 모든 환경 정보를 저장한다.
	- 변수
	- 함수 선언
	- 외부 스코프 정보 : 스코프 체인
	- `this` 값

---
### 3. 실행 컨텍스트의 구성
![[실행 컨텍스트의 구성.png]]
###### 1. Lexical Environment (렉시컬 환경)
- `let`, `const` 변수와 함수 선언 뿐 아니라 **코드의 스코프와 관련된 정보를** 관리한다. 
	- **Outer Environment Reference**를 통해 상위 스코프를 참조한다.
- 실행 중 변수의 추가, 수정 등 **변경 사항이 실시간으로 반영된다.**
- Lexical Environment는 Variable Environment와 역할이 다르며, 초기화 시에도 독립적으로 생성된다.
###### 2. Variable Environment (변수 환경)
- **현재 컨텍스트 내의 `var`로 선언된 변수와 함수 선언**의 정보를 관리한다.
	- 외부 환경 정보는 **Lexical Environment**의 일부인 **Outer Environment Reference**에 의해 관리된다.
	- 외부 환경  참조는 렉시컬 환경의 역할이다.
- 실행 컨텍스트 생성 시, **Variable Environment는 `var` 변수와 함수 선언만 초기화**하고, `let`과 `const`는 Lexical Environment에서 관리된다.
	- Variable Environment는 **`Lexical Environment`의 스냅샷**이 아니며, 각자 독립적으로 생성되고 관리된다.
###### 3. This Binding (this 값)
- 현재 실행 컨텍스트에서 `this`가 참조하는 객체를 나타낸다.
- 전역 컨텍스트에서는 `window` 또는 `global` 객체를 참조한다.
- 함수 내부에서는 함수 호출 방식에 따라 달라진다.

---
### 4. 렉시컬 환경 (Lexical Environment)

##### 1. 정의
- 렉시컬 환경은 **자바스크립트 엔진**이 변수와 함수 선언, 스코프 체인, 외부 환경 정보를 관리할 수 있도록 하는 **구조적인 방식을 의미**한다.
	- 코드가 실행될 때 **어휘적(Lexical)** 으로 정의된 환경에 따라 변수나 함수에 접근할 수 있다.

##### 2. 렉시컬 환경의 구성
###### ※ 환경 레코드(Environment Record)
- 현재 실행 중인 스코프 내에서 선언된 변수와 함수의 실제 정보를 저장한다.
	- 대상은 **변수의 값, 함수 선언, 매개변수** 등이 있다.
- 예: `{ a: 10, b:function(){} }`
###### ※ 외부 렉시컬 환경 참조 (Outer Lexical Environment Reference)
- 현재 환경의 상위 스코프를 참조한다.
- 이를 통해 스코프 체인이 만들어지고, 변수 검색이 상위 스코프로 이어진다.
	- 변수 환경에는 이게 없다.

##### 3. 렉시컬 환경이 생성되는 시점
###### ※ 전역 실행 컨텍스트
- 프로그램이 시작될 때 생성된다.
- 전역 환경에서는 `window` 객체(브라우저)나 `global` 객체(Node.js)가 환경 레코드 역할을 한다.
###### ※ 함수 실행 컨텍스트
- 함수가 호출될 때마다 새로운 렉시컬 환경이 생성된다.
- 함수 내부에서 선언된 변수와 매개변수가 환경 레코드에 저장된다.
###### ※ 블록 실행 컨텍스트 (ES6 이후)
- `let`, `const`를 사용하는 블록 스코프(`{}`)도 독립적인 렉시컬 환경을 생성한다.
```js
{
    let a = 10;
    const b = 20;
}
```

##### 4. 렉시컬 환경의 동작 과정
- 렉시컬 환경은 **코드가 작성된 어휘적 위치(Lexical position)을 기준으로 스코프를 결정**한다.
- 즉, 코드가 선언된 위치에 따라 변수와 함수에 접근할 수 있는 범위인 스코프가 결정된다는 뜻이다.

```js
function outer() {
    let a = 10; // outer 렉시컬 환경의 변수
    function inner() {
        console.log(a); // 상위 렉시컬 환경(outer)을 참조
    }
    inner();
}
outer();
```
1. **`outer()` 실행 시:**
    - `outer` 함수의 렉시컬 환경 생성
        - 환경 레코드: `{ a: 10 }`
        - 외부 렉시컬 환경 참조: 전역 환경

2. **`inner()` 실행 시:**
    - `inner` 함수의 렉시컬 환경 생성
        - 환경 레코드: `{}` (함수 내부에서 선언된 변수 없음)
        - 외부 렉시컬 환경 참조: `outer` 함수의 렉시컬 환경

##### 5. **렉시컬 환경과 스코프 체인**

- **자바스크립트 엔진**은 식별자를 찾을 때 우선, 일단 자신이 속한 스코프에서 찾는다.
	- 이 때, 해당 스코프에 식별자가 없으면, 해당 스코프를 포함하는 상위 스코프에서 식별자를 다시 찾아 나가는 연결과정을 거치는데, 이를 **스코프 체인**이라 한다.

- 렉시컬 환경은 이 **스코프 체인**을 통해 변수 검색을 수행할 수 있다.
	- 변수를 찾을 때, **현재 렉시컬 환경의 환경 레코드**에서 먼저 검색한다.
	- 찾지 못하면 **외부 렉시컬 환경 참조**로 이동해 검색을 이어간다.
	- **전역 환경**까지 검색했음에도 변수가 없다면, 에러(`ReferenceError`)가 발생한다.

```js
let x = 10;
function foo() {
    let y = 20;
    function bar() {
        let z = 30;
        console.log(x + y + z); // 10 + 20 + 30
    }
    bar();
}
foo();
```

1. `bar` 함수의 렉시컬 환경:
    - 환경 레코드: `{ z: 30 }`
    - 외부 렉시컬 환경 참조: `foo` 함수의 렉시컬 환경

2. `foo` 함수의 렉시컬 환경:
    - 환경 레코드: `{ y: 20 }`
    - 외부 렉시컬 환경 참조: 전역 환경

3. 전역 환경:
    - 환경 레코드: `{ x: 10 }`

##### 6. 렉시컬 환경이 중요한 이유
###### ※ 스코프를 이해하는 핵심
- 렉시컬 환경은 **스코프와 변수 접근**을 관리한다.
- 변수가 어디에서 선언되고 어떻게 참조되는지를 결정한다.
###### ※ 클로저(Closure)를 사용할 수 있도록 하는 기반
- 앞서, 클로저는 반환된 내부함수와 내부함수가 선언되었던 렉시컬 환경의 조합으로 정의할 수 있다.
	- 지금까지의 내용을 잘 이해했다면, 클로저는 반환된 내부함수와 반환된 내부함수가 선언되었던 **렉시컬 환경의 외부 참조**가 유지된 함수라는 것임을 알 수 있을 것이다.
```js
function makeCounter() {
    let count = 0; // 클로저로 참조됨
    return function () {
        count++;
        return count;
    };
}
const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```
###### ※ ES6 이후 블록 스코프 관리를 가능케 함
- 렉시컬 환경은 `let`, `const`로 선언된 변수를 블록 스코프로 관리한다.

---
### 5. 변수 환경 (Variable Environment)

##### 1. 정의
- 변수 환경은 실행 컨텍스트의 구성요소 중 하나로, **변수 선언과 초기화 정보를 관리하는 데에 사용**된다.
- 이 환경은 특히나 `var` 키워드와 관련된 변수의 호이스팅과 스코프를 처리한다.

##### 2. 변수 환경의 구성
###### ※ 환경 레코드(Environment Record)
- 변수와 함수 선언을 저장한다.
- `var` 키워드로 선언된 변수는 환경 레코드의 변수 환경(Variable Environment)에 저장된다.
- 함수 선언문(Function Declaration)은 환경 레코드에 저장되어, 호출 시점에 사용할 수 있
- 게 된다.

 >※ 외부 렉시컬 환경 참조 X
- **변수 환경**은 **외부 렉시컬 환경 참조**를 가지지 않으며, 단지 현재 스코프 내의 변수를 관리한다.

##### 3. **변수 환경과 렉시컬 환경의 공통점과 차이점**
###### ※ 공통점
- **변수 환경**과 **렉시컬 환경**은 모두 **실행 컨텍스트** 내에서 변수와 함수의 **스코프** 및 **선언 정보를 관리**한다.
###### ※ 차이점
1. **변수 환경 (Variable Environment)**
	- **변수 환경**은 **변수의 선언**과 **값**을 관리한다. 하지만, **실행 중에 값이 변경되더라도**, 변수 환경 자체는 변경된 값을 추적하지 않는다.
	- **초기화 단계에서 설정**되며, **실행 중에 변경된 값**은 변수 환경이 아닌, **실행 스택**이나 **스코프 체인**을 통해 처리된다.
		- **주요 역할**: 변수의 **선언 정보**와 **초기 값**을 관리.
		- **변경된 값**은 **실행 스택**과 **스코프 체인**을 통해 관리되며, **변수 환경** 자체는 값의 변화를 추적하지 않는다.

	- **변수 환경**은 **렉시컬 환경**과 다르게 **외부 렉시컬 환경을 참조하지 않는다**. 변수 환경은 **현재 함수의 변수들만 관리**하며, 외부 함수의 변수나 스코프에는 접근하지 않는다.
		- 대신, **렉시컬 환경**은 **상위 함수의 스코프**와 **스코프 체인**을 관리하며, 이를 통해 상위 스코프에 있는 변수들에 접근할 수 있도록 합니다. 즉, **변수 환경**은 단지 **현재 함수 내의 변수**만을 관리하는 역할을 하고, 외부 함수나 환경을 참조하지 않는다.
		- **렉시컬 환경**은 함수가 호출될 때마다 **현재 함수의 스코프**와 **외부 함수의 스코프**를 포함한 **스코프 체인**을 관리하고, 이를 통해 상위 함수의 변수들을 참조할 수 있다.

2. **렉시컬 환경 (Lexical Environment)**
	- **렉시컬 환경(Lexical Environment)** 은 **변수 환경(Variable Environment)** 을 포함하고 있으며, **상위 렉시컬 환경**에 대한 **참조**도 함께 관리한다. 즉, **변수 환경**과 함께 **스코프 체인**을 구성한다.
	- **렉시컬 환경**은 **변수 선언 위치**를 기준으로 **스코프 체인을 설정**하며, **변수 선언과 함수 선언**을 처리한다. **변수 값의 변경**은 렉시컬 환경에서도 마찬가지로 관리하지 않는다.
	    - **주요 역할**: **변수와 함수의 선언**을 추적하고, **상위 스코프**와 연결된 **스코프 체인**을 관리.
	    - **변수 값의 변화**는 **렉시컬 환경**에서 추적하지 않으며, 이 또한 **실행 컨텍스트**의 **실행 스택**과 **스코프 체인**에서 처리된다.
	- 즉, **렉시컬 환경은 실행 중에 변경된 값도 반영**하기 위해, **변수 환경**의 **초기 값**을 저장하는 것 외에도, **콜 스택**에 저장된 최신 값을 참조할 수 있다는 뜻이다.

##### 4. 예시
```js
function outer() {
  var x = 10; // 'x' 변수 선언
  function inner() {
    console.log(x); // 'x'를 참조
  }
  x = 20; // x 값을 변경
  inner(); // x 값을 출력
}

outer();
```
1. **변수 환경 (Variable Environment)**
	- **변수 환경**은 **변수 선언과 초기 값**을 관리한다. `outer` 함수 내에서 `x`는 **변수 환경**에 선언되고, **초기 값**은 `10`으로 설정된다.
	
	- **실행 중에 값이 변경되면**, 변수 환경은 **변경된 값을 추적하지 않는다**.
		- 예를 들어, `x`의 값이 `20`으로 변경되었지만, **변수 환경** 자체는 초기값인 `10`만을 관리하고 **변경된 값을 추적하지 않는다**.
		- 즉, **변수 환경**은 단지 **변수의 선언**과 **초기값**만을 저장하고 **변경된 값**은 **실행 스택**이나 **스코프 체인**을 통해 처리된다.
	    - 이 예시에서 `x`는 **변수 환경**에 `10`으로 설정된 후, 실행 중에 `20`으로 변경된다. **변수 환경**은 여전히 `10`을 관리하지만, `x`의 값은 **실행 스택**에서 `20`으로 변경된다.
		- **변수 환경**에서는 `x` 값의 변경 사항을 추적하지 않기 때문에, `inner` 함수가 호출될 때 **초기 값 10**을 참조할 수 있다.
	
	- 실행 흐름은 아래와 같다.
		1. **`outer()` 함수 실행**:
		    - `var x = 10;`이 실행되며, `x`는 `outer` 함수의 **변수 환경**에 **10**으로 저장된다.
		
		2. **`x = 20;`로 값 변경**:
		    - `x`의 값을 `20`으로 변경하지만, **변수 환경**은 여전히 **10**을 저장하고 있다.
			- 왜냐하면 `var`로 선언된 변수는 함수의 **변수 환경**에서 초기값을 관리하고, 변수의 값 변경은 **변수 환경**에서 추적되지 않기 때문이다.
		
		3. **`inner()` 함수 호출**:
		    - `inner()` 함수가 호출된다. 이때 `inner()` 함수의 **렉시컬 환경**은 `outer()` 함수의 **변수 환경**을 참조한다.
			    - `inner()`함수는 자신의 변수환경에 `x`가 없기 때문에 `outer()`함수의 변수 환경을 참조하게 된다. 
		    
			- **중요 포인트**: `inner()` 함수는 `x`를 참조할 때, **변수 환경**에서 **초기값인 10**을 참조한다.
			    - 이유는 `inner()`가 실행될 때 **변수 환경**에는 `x = 10`만 저장되어 있기 때문이다.
			
		    - 즉, `inner()` 함수에서 `x`는 여전히 `10`을 출력한다.
			    - 왜 자꾸 렉시컬 환경이 언급되는지 헷갈릴 수 있다. **변수 환경**은 단지 **현재 함수 내 변수와 함수 선언**만을 관리하지만, **렉시컬 환경**은 **변수 환경**을 포함하면서 **외부 렉시컬 환경 참조**를 통해 **스코프 체인**을 구성한다.
			    - `inner()` 함수에서 `x`를 참조할 수 있는 이유는 **렉시컬 환경** 덕분인데, **렉시컬 환경**이 **상위 스코프의 변수**를 참조할 수 있기 때문에, `inner()` 함수는 `outer()` 함수의 변수 환경을 참조하여 `x = 10`을 출력하는 것이다.
			    - 결론적으로, **변수 환경**만으로는 해결할 수 없는 변수 참조는 **렉시컬 환경**을 이용해서 상위 스코프에 정의된 변수들을 찾아 내부적을 참조하게 된다.

2. **렉시컬 환경 (Lexical Environment)**
	- **렉시컬 환경**은 **변수 환경**을 포함하고 있으며, **상위 렉시컬 환경**에 대한 **참조**도 관리한다.
		- `inner` 함수는 **렉시컬 환경**을 생성할 때, **상위 렉시컬 환경**으로 `outer` 함수의 스코프를 참조한다.
		- 이로 인해 `inner` 함수는 **렉시컬 환경**을 통해 `outer` 함수의 `x`를 참조할 수 있다.
	
	- **렉시컬 환경**은 **변수의 선언 위치**와 **스코프 체인**을 관리한다. 즉, `inner` 함수는 **렉시컬 환경**을 통해 **상위 함수**인 `outer`의 **스코프 체인**을 참조하여 `x`를 찾을 수 있다.
		- `inner` 함수는 **렉시컬 환경**을 통해 `outer` 함수의 **변수 환경**에 접근하고, `x`의 **변경된 값 20**을 참조합니다. 즉, `x`는 `outer`에서 **실행 중에 변경된 값**인 20을 출력한다.
	
	- **변수 값의 변경**은 **렉시컬 환경**에서 관리되지 않으며, 값의 변화는 **실행 스택**에서 처리된다.
	    - 이 예시에서 `inner` 함수는 **렉시컬 환경**을 통해 `outer`의 **변수 환경**에 접근하여 `x`를 참조한다.
	    - **렉시컬 환경**은 **변수 선언의 위치**를 기준으로 **스코프 체인**을 설정하고, `inner` 함수가 실행될 때 `x`는 **변경된 값**인 `20`으로 출력된다. `inner`는 `outer`의 **스코프 체인**을 참조하여 변경된 값인 `20`을 출력한다.
	
	- 실행 흐름은 아래와 같다.
		1. **`outer()` 함수 실행**:
		    - `outer()` 함수가 실행될 때, 실행 컨텍스트가 생성된다. 이 컨텍스트에는 **변수 환경**과 **렉시컬 환경**이 포함되어 있다.
			    - 이 때, **변수 환경**에는 `x = 10`이 저장되어 있다.
		    - `inner()` 함수는 **`outer()` 함수의 렉시컬 환경** 내에 존재한다. 
			    - 따라서 `inner()` 함수는 **렉시컬 환경**에서 `outer()` 함수의 **변수 환경**을 참조할 수 있다.
		
		2. **`x` 값 변경**:
		    - `x`의 값이 `10`에서 `20`으로 변경된다. **변수 환경**은 **`x`의 초기값**만 저장하고, 값이 변경되면 해당 변경을 추적하지 않는다.
		    - 그러나, 실제로 `x`의 값은 **실행 스택**에서 변경된 `20`이 저장됩니다.
		
		3. **`inner()` 함수 실행**:
		    - `inner()` 함수가 실행될 때, **`inner()`의 실행 컨텍스트**가 생성된다.
		    - **렉시컬 환경** 내에서는 `inner()` 함수가 **`outer()` 함수의 렉시컬 환경**을 참조하게 된다.
			    - 즉, `inner()`는 **`outer()` 함수의 변수 환경**을 참조할 수 있다.
		    - **렉시컬 환경**은 **스코프 체인**을 통해 상위 스코프(즉, `outer()` 함수)의 **변수 환경**을 참조하고, 이때 **변경된 `x` 값인 20**을 출력하게 된다.
			    - 그러니까, 렉시컬 환경은 실행 컨텍스트에서 실제로 사용되고 있는 값 `20`을 콜 스택에서 보고 찾는데, 변수 환경은 콜 스택을 확인하지 않고, 변수 환경에서 최초 초기화된 값만 기억한다는 것이다.
		
		4. **출력**:
		    - `console.log(x)`에서 `x`는 변경된 값인 `20`을 출력한.

3. **결론**
	- **변수 환경**은 단지 **변수의 선언과 초기 값**만을 기억하고, 실행 중에 값이 변경되더라도 변경된 값을 추적하지 않는다.
	- 반면, **렉시컬 환경**은 **스코프 체인**을 관리하여 **실행 시 변경된 값을** 사용할 수 있다.
		- 따라서, **변수 환경**에서는 `x`의 변경된 값 `20`을 추적하지 않지만, **렉시컬 환경**에서는 실행 시 값이 변경된 `x`를 참조하여 **20**을 출력할 수 있다.

---
### 6. this 바인딩

##### 1. 바인딩
- 식별자와 값을 연결하는 **과정**을 의미한다.
- `this` 바인딩은 `this` 식별자 키워드와 `this`가 가리켜야 하는 객체를 연결하는 것을 의미한다.

##### 2. this
- this는 자바스크립트에서 함수가 호출될 때 그 함수가 속한 객체를 참조하는 키워드이다.. 
- 이 this의 값은 함수가 호출되는 방식에 따라 달라질 수 있다.

##### 3. 함수 호출과 this 바인딩
1. 일반 함수 호출
2. 메서드 호출