
- **CRUD**와 **REST**는 웹 개발에서 자주 사용되는 개념으로, 서로 밀접한 관련이 있다.

#### 1. CRUD (Create, Read, Update, Delete)

- CRUD는 데이터 조작을 위한 기본적인 4가지 기능을 의미한다.
	- 데이터베이스에서 정보를 생성(Create)하고, 읽고(Read), 업데이트(Update)하고, 삭제(Delete)하는 작업을 각각 나타낸다.

> **4가지 기능**
- **Create**: 데이터를 새로 생성하는 작업 (예: 새 레코드 추가)
- **Read**: 기존 데이터를 조회하는 작업 (예: 레코드 검색)
- **Update**: 기존 데이터를 수정하는 작업 (예: 레코드 업데이트)
- **Delete**: 데이터를 삭제하는 작업 (예: 레코드 삭제)

- CRUD는 대부분의 데이터 중심 애플리케이션에서 핵심적인 역할을 한다. 
	- 데이터베이스에서 작업을 수행할 때 이 4가지 기능을 사용하여 데이터를 관리한다.


#### 2. REST

- **REST**는 웹 애플리케이션이 클라이언트와 서버 간에 데이터를 주고받는 방법을 정의하는 아키텍처 스타일이다.
	- REST는 HTTP 프로토콜을 기반으로 동작하며, HTTP 메서드를 사용하여 CRUD와 대응되는 작업을 수행한다.

- **REST**의 주요 개념 중 하나는 **리소스**(resource)이다.
	- 웹에 존재하는 자원인 리소스에는 고유한 URL이 부여되어 있으며, 이 URL로 리소스가 식별된다.
	- 그리고 HTTP 메서드를 통해 이 리소스에 대한 작업을 수행할 수 있다.

- 정리하면, REST는 웹 애플리케이션이 클라이언트와 서버 간에 데이터를 주고받는 방법을 정의하는 아키텍처 스타일이다. 그리고 HTTP URL로 리소스를 명시하고, HTTP 메소드를 사용함으로써 해당 리소스에 대한 CRUD Operation을 수행할 수 있도록 한다.

> **HTTP 메서드와 CRUD의 대응**
- **POST**: Create (새 리소스 생성)
- **GET**: Read (리소스 조회)
- **PUT**: Update (리소스 전체 수정)
- **PATCH**: Update (리소스 일부 수정)
- **DELETE**: Delete (리소스 삭제)

> **예시 : 사용자 정보 CRUD 방식 처리**
- **Create** (POST): `POST /users`를 통해 새로운 사용자를 생성
- **Read** (GET): `GET /users/1`을 통해 ID가 1인 사용자의 정보를 조회
- **Update** (PUT/PATCH): `PUT /users/1`을 통해 ID가 1인 사용자의 전체 정보를 수정하거나 `PATCH /users/1`으로 일부 정보를 수정
- **Delete** (DELETE): `DELETE /users/1`을 통해 ID가 1인 사용자를 삭제


#### 3. REST API

- **REST API**는 **REST(Representational State Transfer)** 아키텍처 스타일을 준수하여 설계된 API(Application Programming Interface)를 의미한다. 
	- REST는 웹에서 데이터를 주고받는 방법론을 정의한 아키텍처 스타일이고, REST API는 이를 기반으로 클라이언트와 서버 간의 통신을 처리하는 프로토콜이다.

- REST API는 클라이언트가 서버의 리소스를 접근하고 조작하는 방법을 표준화하는 데에 중요성이 있다.
	- 여기서 중요한 개념은 "**리소스**"로, 서버의 모든 데이터는 하나의 리소스로 간주된다.

> **REST API의 주요 특징**
1. **리소스 기반**: 서버의 데이터는 각기 다른 리소스로 간주되며, 각 리소스는 고유한 URL로 식별된다.
    - 예: `/users/1`는 ID가 1인 사용자에 대한 리소스.

2. **HTTP 메서드 사용**: CRUD 작업을 HTTP 메서드(GET, POST, PUT, DELETE 등)에 매핑하여 사용한다.
    - **GET**: 리소스를 조회
    - **POST**: 리소스를 생성
    - **PUT**: 리소스를 수정
    - **DELETE**: 리소스를 삭제

3. **무상태성**: 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리된다. 즉, 클라이언트의 이전 요청이 서버에 영향을 주지 않는다.

4. **표현(Representation)**: 클라이언트는 리소스 자체가 아니라, 리소스의 표현(예: JSON, XML)을 받는다. 서버는 리소스를 클라이언트가 요청한 형식에 맞춰서 반환한다.

5. **캐시 가능**: 클라이언트는 서버의 응답을 캐싱하여 불필요한 중복 요청을 줄일 수 있다.


#### 4. RESTful

- **RESTful**은 REST의 원칙을 **따르는 시스템**이나 **API**를 설명하는 형용사이다. 
	- 다시 말해, REST 아키텍처 스타일을 제대로 준수하는 API나 웹 서비스는 **"RESTful 하다"** 라고 표현한다.
	- 즉, RESTful API란 REST의 원칙과 가이드라인에 따라 설계된 API이라 할 수 있다.

> **REST API와 RESTful의 차이**
- **REST API**는 REST 아키텍처 스타일을 기반으로 설계된 API 자체를 의미한다.
- **RESTful**은 REST의 원칙을 충실히 따르고 있음을 나타내는 형용사로, RESTful API는 REST의 모든 원칙을 따르는 API를 의미한다.

 >**RESTful하지 않은 경우의 예시**
- 어떤 API가 RESTful하지 않은 사례는 REST의 원칙을 제대로 준수하지 않았을 때 발생한다.
	- **잘못된 HTTP 메서드 사용**: 데이터를 조회해야 할 때 `POST`를 사용하거나, 데이터를 생성할 때 `GET`을 사용하면 RESTful하지 않은 설계가 된다.
	  
	- **URL에 상태 정보 포함**: 클라이언트의 세션 ID 같은 상태 정보를 URL에 포함시켜 요청하는 경우 무상태성 원칙을 위배하게 되어 RESTful하지 않다.
	  
	- **비일관된 리소스 구조**: 동일한 데이터에 대한 URL이 일관되지 않거나, 명확한 리소스 개념 없이 API가 설계되면 RESTful하지 않다.


> **REST API의 예시** (사용자 정보를 처리하는 REST API가 있다고 가정)
1. **리소스**: `/users`
    - `/users/1`: ID가 1인 사용자
    - `/users/1/posts`: ID가 1인 사용자의 게시물

2. **HTTP 메서드 사용**
    - `GET /users`: 모든 사용자 목록 조회
    - `GET /users/1`: ID가 1인 사용자 정보 조회
    - `POST /users`: 새로운 사용자 생성
    - `PUT /users/1`: ID가 1인 사용자 정보 수정
    - `DELETE /users/1`: ID가 1인 사용자 삭제

- 이 API가 REST의 원칙을 따르고 있다면, 이를 **RESTful API**라고 부를 수 있다.

 > **요약**
- **REST API**: REST 아키텍처 스타일을 기반으로 하는 API.
- **RESTful**: REST의 원칙을 제대로 준수하는 API나 시스템.


#### ※ 참고 : 아키텍처 스타일

- **아키텍처 스타일(Architecture Style)** 은 **소프트웨어 시스템을 설계할 때 따르는 고수준의 개념적 패턴 또는 원칙**을 의미한다.
	- 이는 시스템이 어떻게 구조화되고 서로 다른 구성 요소들이 어떻게 상호작용할지를 결정하는 방법을 정의한다.
	- 쉽게 말하면, 아키텍처 스타일은 "시스템의 뼈대와 통신 방식에 대한 규칙과 가이드라인"이라고 할 수 있다.

> **아키텍처 스타일의 역할**
- 아키텍처 스타일은 시스템을 설계할 때 일관된 구조와 방향을 제공하고, 그 시스템이 가진 요구사항을 충족시키면서도 확장 가능하고 유지 보수 가능한 구조를 만드는 데 도움을 준다.
- 각각의 스타일은 특정 문제를 해결하기 위해 최적화된 방식이며, 상황에 맞는 스타일을 선택함으로써 성능, 확장성, 유연성 등을 높일 수 있다.
- **시스템의 전체적인 설계 방식과 그 안에서의 통신 방법을 결정하는 중요한 원칙을 제공**하는 개념이다.

 > **주요 아키텍처 스타일의 예시**
1. **계층형 아키텍처 (Layered Architecture)**
    - 여러 계층으로 시스템을 나누어 각 계층이 독립적으로 동작하도록 설계.
    - 예: 프레젠테이션 계층(UI), 비즈니스 로직 계층, 데이터 접근 계층(DB) 등.

2. **클라이언트-서버 아키텍처 (Client-Server Architecture)**
    - 클라이언트와 서버로 시스템을 나누어 서로 통신하는 구조.
    - 클라이언트는 요청을 하고, 서버는 이를 처리해 응답을 반환.
    - 웹 애플리케이션에서 자주 사용.

3. **마이크로서비스 아키텍처 (Microservices Architecture)**
    - 애플리케이션을 여러 작은 서비스로 나누어 독립적으로 배포하고 운영하는 방식.
    - 각 서비스는 독립적인 데이터베이스와 비즈니스 로직을 가짐.
    - 확장성과 유지 보수성에 강점.

4. **이벤트 기반 아키텍처 (Event-Driven Architecture)**
    - 시스템 간의 통신이 이벤트를 기반으로 이루어짐.
    - 이벤트가 발생하면 해당 이벤트를 처리하는 서비스가 동작하는 방식.
    - 분산 시스템이나 실시간 처리 시스템에 적합.

5. **REST 아키텍처 스타일 (Representational State Transfer)**
    - HTTP를 기반으로 클라이언트-서버 통신을 설계하는 아키텍처 스타일.
    - 리소스를 URL로 나타내고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 통해 데이터를 처리.
    - 웹 API 설계에서 널리 사용.

6. **서비스 지향 아키텍처 (SOA, Service-Oriented Architecture)**
    - 독립된 서비스들이 서로 상호작용하며 기능을 제공하는 구조.
    - 마이크로서비스와 유사하지만 더 큰 범위에서 운영.

> **아키텍처 스타일과 디자인 패턴의 차이**
- **아키텍처 스타일**: 시스템의 전반적인 구조와 상호작용 방식을 정의하는 상위 개념 (예: REST, 클라이언트-서버 등)
- **디자인 패턴**: 아키텍처 스타일을 구현할 때 자주 사용하는 해결책이나 설계 방법론 (예: MVC, 리포지토리 패턴 등)
