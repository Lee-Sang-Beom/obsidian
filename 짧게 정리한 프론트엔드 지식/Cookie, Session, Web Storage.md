
### 1. Cookie, Session을 사용하는 이유

- 간단히 말하면, **HTTP 프로토콜의 특성이자 약점**을 보완하기 위해서 쿠키 또는 세션을 사용한다고 할 수 있다.

- 기본적으로 HTTP 프로토콜 환경은 **connectionless**, **stateless**한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. 이러한 특성을 보완하기 위해서 쿠키와 세션을 사용하는 것이다.
	- **connectionless(비연결성)** : 클라이언트가 요청을 한 후 응답을 받으면, TCP/IP가 그 연결을 끊어버리는 특징
	- **stateless(무상태)** : 통신이 끝나면 상태를 유지하지 않는 특징

##### 1-1. Connectionless (비연결성)
- HTTP는 연결을 유지하지 않는 모델을 기본으로 한다. 이는 클라이언트가 서버에게 **request**를 보내고, 서버가 클라이언트에게 요청에 맞는 **response**를 반환해주면, 해당 접속을 끊는 특징을 가진다는 뜻이다.
	- 클라이언트와 서버가 계속해서 통신 연결을 하지 않기 때문에, 서버의 자원을 효율적으로 관리할 수 있고, 수 많은 클라이언트의 요청에도 대응할 수 있게 된다.
	
- 하지만, 단점으로 새로이 통신을 연결할 때마다 TCP/IP 연결이 이루어져야 한다는 뜻이다.
	- **3-way-handshake** 시간이 추가로 발생한다.
	- **Connectionless에서 3-way handshake**: 3-way handshake는 TCP 연결을 수립하는 데 필요한 과정으로, 매 요청마다 연결이 설정되면 오버헤드가 발생한다. 이를 완화하기 위해 HTTP/2, HTTP/3 같은 프로토콜이 등장했으며, **HTTP Keep-Alive** 옵션이 이러한 비효율을 줄이는 역할을 한다.

- 또한, 로그인하고 페이지를 이동할 때마다 로그인을 수행해주어야 한다.

##### 1-2. stateless (무상태)
- **stateful**의 뜻은 서버가 클라이언트 이전상태를 보존한다는 뜻이다.
```
1. 승객: 서울에서 전주 가는 KTX는 얼마인가요?
2. 직원: 25,000원입니다.
3. 승객: 2장 주세요.직원: 50,000원입니다. 결제는 무엇으로 하시겠습니까? 
		(KTX 노선과 주문 수량에 대한 상태를 유지)
4. 승객: 체크카드입니다.
5. 직원: 결제 완료되었습니다. 
		(KTX 노선과 주문 수량, 결제 수단에 대한 상태를 유지)
```

- **stateless**는, stateful과 상반되는 뜻이라 할 수 있다. 즉, 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특징이라고 해석할 수 있다.
```
1. 승객: 서울에서 전주 가는 KTX는 얼마인가요?
2. 직원: 25,000원입니다.
3. 승객: 2장 주세요.
4. 직원: ??? 무엇을 2장 구매하시는 건가요???
5. 승객: 아까 말했잖아요😳. 서울에서 전주 가는 KTX요!!!
6. 직원: 몇 장인지, 결제 수단은 무엇인지 한 번에 얘기해주세요!
```

- 위와 같이, 기본적으로 HTTP 프로토콜 환경은 **connectionless**, **stateless**한 특징이 있기 때문에, 서버는 클라이언트가 누구인지 매번 확인해 주어야 한다. 

- 이러한 문제를 보완하기 위해서 **쿠키**와 **세션** 이라는 것이 사용된다.

---
### 2. 쿠키(Cookie)

- 쿠키는 클라이언트(브라우저)에  **key-value** 형태로 저장되는 작은 파일이다.
	- 클라이언트 상태 정보를 로컬에 저장했다가 참조할 수 있는 방법이다.
	- 사용자 인증이 유효한 시간을 명시할 수 있다.
		- 유효 시간이 설정된 경우, 브라우저 종료와 관계없이 쿠키가 유지된다. (지속 쿠키)
		- 반대로 **유효 시간 설정이 없는 경우**,브라우저가 종료되면 쿠키도 삭제된다. (세션 쿠키)
	- **Response Header**에 `set-cookie` 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
	- 쿠키는 사용자가 따로 요청하지 않아도, 브라우저가 **request**를 보낼 때 **Request Header**의 `Cookie` 필드에 자동으로 포함하여 서버로 전송한다. 대신 아래의 조건이 맞춰져야 한다.
		- **도메인 조건**: 쿠키의 `Domain` 속성이 현재 요청의 도메인과 일치하거나 하위 도메인에 포함되어야 한다.
		- **경로 조건**: 쿠키의 `Path` 속성이 현재 요청 URL의 경로에 일치하거나 상위 경로여야 한다.
		- **보안 조건**:
		    - `Secure` 속성이 설정된 쿠키는 HTTPS 연결에서만 전송된다.
		    - `HttpOnly` 속성이 설정된 쿠키는 자바스크립트에서 접근할 수 없으며, 브라우저에서만 자동으로 관리된다.
		- **SameSite 조건**:
		    - `SameSite` 속성이 `Strict`인 경우, 동일한 사이트에서의 요청에서만 쿠키가 전송된다.
		    - `Lax`인 경우, 일부 크로스 사이트 요청(GET 같은 안전한 메서드)에서만 전송된다.
		    - `None`인 경우, 크로스 사이트 요청에도 전송되지만, 이때는 `Secure` 속성이 필수가 된다.

- **쿠키(Cookie)의 특징**
	- 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
	- 클라이언트에 총 300개의 쿠키를 저장할 수 있는데, 이는 권장 최대치로 브라우저마다 다를 수 있다.
	- 하나의 도메인 당 50~180개의 쿠키를 허용가능하다.
	- 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다. 이는 브라우저마다 다를 수 있다.

- **쿠키의 동작 방식**
	1. 클라이언트가 페이지를 요청한다 (사용자가 웹 사이트에 접근).
	2. 서버는 **쿠키를 생성한 후**, **HTTP 응답 헤더**에 쿠키를 포함시켜 클라이언트에게 응답한다.
		- 정확하게는 클라이언트가 웹 사이트를 첫 방문하면 서버는 해당 클라이언트를 식별하기 위한 key-value 객체를 만든다.
		- 그리고, **HTTP 헤더의 Set-Cookie** 항목에 쿠키를 담아서 전달한다. 그리고 이를 통해 클라이언트는 Set-Cookie 헤더에 있는 쿠키를 브라우저에 저장할 수 있게 된다.
	
	3. 클라이언트는 서버로부터 받은 쿠키를 **로컬 PC**에 저장하고, 이후 서버에 요청할 때 해당 쿠키를 **HTTP 요청 헤더**의 `Cookie` 필드에 포함하여 전송한다.
	    - 쿠키에는 Domain과 Path라는 속성이 있는데 아래와 같은 역할을 한다.
			- **Domain :** HTTP 요청을 보낼 주소의 도메인이 Domain 속성값과 같은 경우에만 쿠키를 보낸다.
			- **Path** : HTTP 요청을 보낼 주소의 URL 경로가 Path 속성값과 같은 경우에만 쿠키를 보낸다.
	      
	4. 브라우저가 종료되어도 쿠키의 만료 기간이 설정되어 있다면, 쿠키는 클라이언트에서 보관된다.
	5. 만약 서버가 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때, **쿠키를 업데이트**하여 변경된 쿠키를 **HTTP 응답 헤더**에 포함시켜 클라이언트에 응답한다.

- **쿠키의 사용 예**
	- 자동 로그인
	- 다시보기 팝업
	- 쇼핑몰의 장바구니 기능

- **쿠키의 한계**
	- 민감한 정보를 그대로 HTTP 통신에 노출하는 경우 탈취당할 수 있다. ID/PASSWORD 등를 쿠키에 넣어서 모든 요청마다 인증 정보를 포함하게 할 수 있는데, 통신 과정에서 패킷을 가로채가면 패스워드가 유출될 수도 있다.
	- 그래서 세션이라는 게 등장한다.


### 3. 세션(Session)

- 쿠키가 탈취당할 수 있다는 것을 인지하여, 민감한 정보는 서버에만 저장하고 쿠키에는 서버에 저장된 정보를 찾을 수 있는 키만 전달하는 방식을 사용한다.
	- 쿠키를 사용하는 것에는 변함이 없고, 쿠키 값으로 어떤 것을 주느냐가 다르다.

- 사용자 정보를 브라우저에서 저장하는 **쿠키**와 달리, **세션**은 사용자 정보를 서버측에서 관리한다
	- 서버에서는 클라이언트를 구분하기 위해 **세션 ID**라는 것을 부여한다. 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때 까지 인증 상태를 유지한다.
	- 접속 시간에 제한을 두어, 일정 시간 응답이 없으면 정보가 유지되지 않게 처리할 수 있다.
	- 데이터를 서버에 두기 때문에, **쿠키**보다 보안에 좋으나, 사용자가 많아질수록 서버 메모리를 많이 차지한다.

- **세션(Session)의 특징**
	- 웹 서버에 웹 컨테이너 상태 유지를 위한 정보를 저장한다.
	- 각 클라이언트에게 고유 ID를 부여
	- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
	- 보안 면에서 쿠키보다 우수
	- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨.
		- 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버 메모리가 감당할 수 없고 속도가 느려지게 되는 단점이 있음
	- 그래서 토큰기반 인증방식인 JWT라는 게 있음

- **세션의 동작 방식**
	1. 클라이언트가 페이지를 요청한다 (사용자가 웹 사이트 접근)
	2. 서버는 접근한 클라이언트의 **HTTP 요청 헤더**에서 `Cookie` 필드를 확인하여, 클라이언트가 보낸 **세션 ID**가 있는지 확인한다.
		- 첫 요청이면 서버는 이 클라이언트를 식별하기 위한 객체를 만든다.
		- 쿠키에서는 이 객체를 바로 HTTP 헤더에 담아서 보내지만, 세션에서는 이를 서버에 저장한다. 데이터베이스에 저장할 수도 있고, 서버의 파일 시스템에 저장할 수도 있다. 이렇게 세션이 저장되는 공간을 **세션 스토리지**라고 한다.
	   
	3. 만약 **세션 ID**가 존재하지 않으면, 서버는 **세션 ID**를 생성해서 쿠키에 담아 클라이언트에 함께 돌려준다.
		- 서버쪽에서는, 세션 스토리지(세션 저장소)에 해당 **세션 ID**값을 저장하여 차후 구분할 수 있도록 한다.
		- 세션 스토리지가 데이터베이스라고 한다면, 쿠키가 담고 있는 값은 단지 데이터베이스의 어떤 Row를 가리키는 PK일뿐이다. 따라서 쿠키가 탈취당해도 쿠키로부터 얻을 수 있는 정보는 없다.
	
	4. 클라이언트는 **세션 ID**를 받으면, 이걸 쿠키를 사용하여 저장하고 가지고 있는다.
		- 다시 말하지만, 서버가 쿠키에 담아 전달해준 세션 ID는 세션 스토리지에서 특정 row를 가리킬 수 있는 PK일 뿐이다. 
		- 쿠키가 탈취당해도 쿠키로부터 얻을 수 있는 정보는 없다.
	
	5. 클라이언트는 재접속 및 재요청 시, **HTTP 요청 헤더**의 `Cookie` 필드에 **세션 ID**를 포함하여 서버에 전송한다.
		- 클라이언트의 두번째 요청부터는 쿠키가 함께 들어온다.
		- 서버는 쿠키를 받아서 세션 스토리지에서 세션 객체를 찾는다. 세션 객체로부터 사용자정보를 얻고 개인화된 응답을 보내준다.
		- 세션의 핵심은 **HTTP 통신 상에서는 어떠한 민감한 정보도 오가지 않는다는 것**이다. 민감한 정보는 오직 서버와 세션 스토리지에서만 다뤄지고 외부로 노출되지 않는다.
	
	6. 서버는 **세션 ID**를 전달 받고, 세션 스토리지에서 해당 **세션 ID**값을 찾아 클라이언트 정보를 가져와서 클라이언트를 구분한다. 그리고 각 클라이언트의 요구에 맞는 서비스를 제공한다.
		- 서버는 클라이언트 정보를 가지고 요청을 처리한 다음, 클라이언트에게 응답한다.

- **세션의 사용 예**
	- 로그인과 같은 보안상 중요한 작업을 수행할 때 사용한다.

- **세션의 한계**
	- 쿠키에 담긴 정보가 있는 그대로는 의미 없지만, 탈취한 쿠키를 이용해 서버에 요청을 보내면 정보가 유출될 수 있다. (세션 하이재킹)
	- 서버에 정보를 저장해야 하기 때문에 **메모리 공간**을 차지한다.
	- 쿠키로부터 받은 세션 ID로 세션 스토리지를 탐색해야 하는 시간이 든다.
	- 동시 접속자가 많은 서비스의 경우 서버 과부하의 원인이 되어, 서버에 정보를 저장하지 않는 토큰(jwt)을 사용하는 방법을 사용한다. (해당 내용은 jwt 포스트 참고) 


### 4. **정리**

- **데이터 저장위치**
	1. 쿠키 : 클라이언트(브라우저)
	2. 세션 : 서버

- **보안**
	1. 쿠키 : 저장위치 때문에 request에서 스니핑에 당할 우려가 있다.
	2. 세션 : 쿠키를 이용해 **세션ID**만 저장하고 그것으로 클라이언트를 구분하여 서버에서 처리한다.

- **Life Cycle**
	1. 쿠키 : 브라우저를 종료해도 만료기간이 남아있으면 존재한다.
	2. 세션 : 브라우저 종료 시 만료기간에 상관없이 종료한다.

- **속도**
	1. 쿠키 : 브라우저에 정보가 있기 때문에, 세션보다 빠르다.
	2. 세션 : 정보가 서버에 있기 때문에, 쿠키보다 상대적으로 느다다


### 5. Web Storage

- 서버 전송 없이 **클라이언트에 데이터를 저장할 수 있도록, HTML5**부터 추가된 저장소이다.
	- 간단한 `Key-Value` 데이터 저장 형태를 가진다.

- 쿠키와 달리 자동 전송의 위험성이 없으며, 클라이언트에 저장만 할 뿐 서버로 전송되지 않는다.

- 쿠키와 같이 해당 도메인에 대한 데이터를 브라우저에 저장한다.
	- **쿠키**는 서버가 클라이언트에게 전송하는 데이터 파일이며, **이름, 값, 도메인 정보, 경로 정보, 만료 일자와 시간** 등을 저장한다.
	- 모든 브라우저에서 지원되지만, 매번 서버에 전송되고, 저장용량이 작고(4KB), 보안이 취약하다.

- 이러한 쿠키 단점을 보완하기 위해 등장한 것이 Web Storage(웹 스토리지)이다.
	- 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없다.

- 웹 스토리지 객체 조작은 **JavaScript** 내에서만 수행가능하며, 오직 **문자형(string)** 데이터 타입만 지원한다.

- 지속성에 따라 **로컬 스토리지(Local Storage)** 와 **세션 스토리지(Session Storage)로 분류할 수** 있다.
	- 같은 **Storage** 객체를 상속하기 때문에 메서드가 동일하다고 한다.

##### 5-1. 로컬 스토리지(Local Storage)

```js
// 사용자 이름을 저장하고 읽기
localStorage.setItem('username', 'JohnDoe');

const username = localStorage.getItem('username');
console.log(`Hello, ${username}!`); // Hello, JohnDoe!

// 데이터 삭제
localStorage.removeItem('username');
console.log(localStorage.getItem('username')); // null
```
- 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있는 **영구성**이 특징이다.
	- 단, 동일한 브라우저를 사용할 때만 해당한다.

- 정리하면, 브라우저 자체에 **반영구적**으로 데이터를 저장하며, 브라우저를 종료해도 데이터가 유지된다.
	- 다만 **도메인(domain)이 다른 경우** 로컬 스토리지에 접근할 수 없다.
	
- 지속적으로 필요한 데이터를 저장하므로, 자동 로그인 등에서 사용할 수 있다.

##### 5-2. 세션 스토리지(Session Storage)

```js
// 세션에서 쇼핑 카트 데이터 저장
sessionStorage.setItem('cart', JSON.stringify(['item1', 'item2', 'item3']));

const cart = JSON.parse(sessionStorage.getItem('cart'));
console.log(cart); // ["item1", "item2", "item3"]

// 탭을 닫거나 새로고침하면 데이터 유지 여부를 테스트
sessionStorage.removeItem('cart');
console.log(sessionStorage.getItem('cart')); // null
```
- 데이터가 **브라우저 탭**에 종속(탭 윈도우 단위로 생성)되기 때문에, **윈도우나 브라우저 탭을 닫을 경우 제거**된다.
	- 각 세션마다 데이터가 개별 저장되며, 브라우저 탭을 닫을 시 데이터가 제거된다.

- 그래서 일시적으로 필요한 데이터를 저장할 때 사용한다.
	- (일회성 로그인 정보, 비로그인 장바구니, 입력 Form 저장 등)
