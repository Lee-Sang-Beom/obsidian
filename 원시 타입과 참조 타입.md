### 1. 원시 타입(Primitive)

> string, number, boolean, undefined, symbol

- 원시 자료형은 할당할 때, 식별자(변수)에 값 자체**가 담깁니다.
    - 좀 더 정확히 말하면, 할당한 값은 메모리 주소에 할당되고, 식별자(변수)는 이 값을 가리킵니다.
    - 값의 변경이 일어나면, 기존 메모리 주소 내에서 값이 변경되지 않습니다.
    - 왜냐하면 원시 타입은 **불변성(immutable)** 의 특징을 가지고 있기 때문입니다.

```jsx
let a = 1;
let b = a;
a = 3;
console.log(a, b); // 3,1
```

- 위의 예제가 이해되나요?
    - a와 b는 2번째 라인까지는 할당문에 의해 같은 값을 가리킵니다.
    - 3번째 라인에서, 새로운 할당이 일어나면서, ‘3’이라는 값이 메모리 주소에 새로 할당이 되면서, 결과적으로 a, b는 다른 값을 가지게 됩니다.

---
### 2. 참조 타입(Reference)

> Array, Object, function

- 참조 타입의 원시 타입과 가장 큰 차이점은 할당의 주체가 값이 아닌 **주소**라는 점입니다.
    - 참조 타입은 별도의 동적인 데이터 보관함의 특징을 가지는 메모리 영역인 Heap에 저장됩니다.
    - 콜스택에 생성된 식별자(변수)는 Heap에 생성된 Array, Object, function의 메모리주소를 참조합니다.
    - 정리하면, 참조 타입은 원시 타입과 다르게 할당된 값을 복사해서 가지고 있는 게 아니라, 할당된 값이 있는 주소를 참조하여 바라보고 있는 것입니다.

```jsx
let array1 =[1,2,3];
let array2 = array1;
array1[1] = 5;
console.log(array1, array2); // [1,5,3] 
```

- 위의 예제가 이해되나요?
    - 배열 [1,2,3]의 영역이 **Heap**에 생성되고, 콜스택에 **배열 식별자(변수)**인 array1이 생성됩니다.
    - array1, array2는 2번째 라인까지 할당문에 의해 같은 배열을 참조하여 가리킵니다.
    - 3번째 라인에서, 배열의 1번째 Index에 값의 교체가 일어납니다.
    - 동적으로 크기가 변하는 데이터를 보관하기 위한 Heap 메모리에 배열 영역이 있기 때문에, Heap 영역에서 Index의 값이 교체됩니다.
    - 두 식별자는 여전히 동일한 주소를 참조하고 있기 때문에 출력 결과는 서로 동일합니다.