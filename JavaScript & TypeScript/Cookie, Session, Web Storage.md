
#### **1. Cookie, Session을 사용하는 이유**

- 간단히 말하면, **HTTP 프로토콜의 특성이자 약점**을 보완하기 위해서 쿠키 또는 세션을 사용한다고 할 수 있다.

- 기본적으로 HTTP 프로토콜 환경은 **connectionless**, **stateless**한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. 이러한 특성을 보완하기 위해서 쿠키와 세션을 사용하는 것이다.
	- **connectionless(비연결성)** : 클라이언트가 요청을 한 후 응답을 받으면, TCP/IP가 그 연결을 끊어버리는 특징
	-  **stateless(무상태)** : 통신이 끝나면 상태를 유지하지 않는 특징

##### 1-1) Connectionless (비연결성)
- HTTP는 연결을 유지하지 않는 모델을 기본으로 한다. 이는 클라이언트가 서버에게 **request**를 보내고, 서버가 클라이언트에게 요청에 맞는 **response**를 반환해주면, 해당 접속을 끊는 특징을 가진다는 뜻이다.
	- 클라이언트와 서버가 계속해서 통신 연결을 하지 않기 때문에, 서버의 자원을 효율적으로 관리할 수 있고, 수 많은 클라이언트의 요청에도 대응할 수 있게 된다.
	
- 하지만, 단점으로 새로이 통신을 연결할 때마다 TCP/IP 연결이 이루어져야 한다는 뜻이다.
	- **3-way-handshake** 시간이 추가로 발생한다.

- 또한, 로그인하고 페이지를 이동할 때마다 로그인을 수행해주어야 한다.

##### 1-2) stateless (무상태)
- stateful : 서버가 클라이언트 이전상태를 보존한다.
- 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.

> stateful
> 
> 승객: 서울에서 전주 가는 KTX는 얼마인가요?직원: 25,000원입니다.
> 
> 승객: 2장 주세요.직원: 50,000원입니다. 결제는 무엇으로 하시겠습니까? (KTX 노선과 주문 수량에 대한 상태를 유지)
> 
> 승객: 체크카드입니다.직원: 결제과 완료되었습니다. (KTX 노선과 주문 수량, 결제 수단에 대한 상태를 유지)

> stateless
> 
> 승객: 서울에서 전주 가는 KTX는 얼마인가요?직원: 25,000원입니다.
> 
> 승객: 2장 주세요.직원: ??? 무엇을 2장 구매하시는 건가요???
> 
> 승객: 아까 말했잖아요😳. 서울에서 전주 가는 KTX요!!!
> 
> 직원: 몇 장인지, 결제 수단은 무엇인지 한 번에 얘기해주세요!

- 기본적으로 HTTP 프로토콜 환경은 **"connectionless, stateless"**한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. 이 특성을 보완하기 위해서 쿠키와 세션을 사용하게 된다.

- **connectionless : 클라이언트가 요청을 한 후, 응답을 받으면, 그 연결을 끊어버림**
- **stateless : 통신이 끝나면 상태를 유지하지 않는 특징**

### 1) 쿠키(Cookie)

- 클라이언트(브라우저)에 저장되는 키와 같이 들어있는 작은 파일
- 클라이언트 상태 정보를 로컬에 저장했다가 참조한다.
- 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
- 쿠키는 사용자가 따로 요청하지 않아도 **브라우저**가 Request 할 때 Request Header를 자동으로 넣어 서버에 전송한다.

```
쿠키 특징
1. 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
```

- **쿠키의 동작 방식**

- 클라이언트가 페이지를 요청(사용자가 웹 사이트 접근)
- 서버에서 쿠키를 생성
- HTTP 헤더에 쿠키를 포함 시켜 응답
- 넘겨받은 쿠키는 클라이언트가 로컬 pc에서 갖고있다가 다시 서버에 요청할때 요청과 함께 쿠키를 전송
- 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
- 동일 사이트 재방문 등 같은 요청을 할 경우, 클라이언트 pc에 해당 쿠키가 있는경우 요청페이지와 함께 HTTP 헤더에 쿠키를 함께 보냄
- 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답
- **쿠키의 사용 예**

- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능 (로그인 안했을때)
- 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크, 쇼핑몰의 장바구니

===


### 2) 세션(Session)

- 사용자 정보를 브라우저에서 저장하는 **쿠키**와 달리, **세션**은 서버측에서 관리한다

- 서버에서 클라이언트를 구분하기 위해 **세션 ID**라는 것을 부여한다. 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때 까지 인증상태를 유지한다.

- 접속 시간에 제한을 두어, 일정 시간 응답이 없으면 정보가 유지되지 않게 처리할 수 있다.

- 데이터를 서버에 두기 때문에, **쿠키**보다 보안에 좋다. 하지만 사용자가 많아질수록 서버 메모리를 많이 차지한다.

- **세션의 동작 방식**


1. 클라이언트가 페이지를 요청한다 (사용자가 웹 사이트 접근)
2. 서버는 접근한 클라이언트의 request-header필드의 cookie를 확인해, 클라이언트가 해당 세션id를 보냈는지 확인
3. 만약 session-id가 존재하지 않으면, 서버는 session-id를 생성해 클라이언트에 함께 돌려줌
1. 서버쪽에서는, 세션저장소에 해당 session-id값을 저장하여 차후 구분할 수 있도록 함
4. 클라이언트는 세션 ID를 받으면, 이걸 쿠키를 사용해서 저장하고 가지고 있음
5. 클라이언트는 이제 같은 요청 등의 재접속의 목적으로 서버에 요청할 때, http요청에 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
6. 서버는 세션 ID를 전달 받고, 세션저장소에서 해당 session-id 값을 찾아 클라이언트 정보를 가져와서 클라이언트를 구분한다. 그리고 각 클라이언트의 요구에 맞는 서비스를 제공
7. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

- **세션의 특징**

- 웹 서버에 웹 컨테이너 상태 유지를 위한 정보를 저장
- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨.
- 즉, 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버 메모리가 감당할 수 없고 속도가 느려지게 되는 단점이 있음
- 그래서 토큰기반 인증방식인 JWT라는 게 있다고함
- **세션의 사용 예**

- 로그인 같이 보안상 중요한 작업을 수행할 때 사용

★ **정리**

- **데이터 저장위치**
- 쿠키 : 클라이언트(브라우저)
- 세션 : 서버
- **보안**
- 쿠키 : 저장위치 때문에 request에서 스니핑에 당할 우려 o
- 세션 : 쿠키를 이용해 세션 아이디만 저장하고 그것으로 클라이언트를 구분하여 서버에서 처리 함
- 보안성은 **쿠키<세션**
- **Life Cycle**
- 쿠키 : 브라우저를 종료해도 만료기간이 남아있으면 존재
- 세션 : 브라우저 종료 시 만료기간에 상관없이 종료
- **속도**
- 쿠키(브라우저에 정보가 있음 : 빠름)
- 세션(서버에 정보가 있음 : 처리가 요구되어 느림)

===

### 3) Web Storage

- 서버 전송 없이 **클라이언트에 데이터를 저장할 수 있도록, HTML5**부터 추가된 저장소

- 간단한 **Key-Value** 데이터 저장 형태

- 쿠키와 달리 자동 전송의 위험성이 없음. 클라이언트에 저장만 할 뿐 서버로 전송되지 않음

- 쿠키와 같이 해당 도메인에 대한 데이터를 브라우저에 저장

- 쿠키는 서버가 클라이언트에게 전송하는 데이터 파일
- 이름, 값, 도메인 정보, 경로 정보, 만료 일자와 시간 등
- 모든 브라우저에서 지원되지만, 매번 서버에 전송되고, 저장용량 작고, 보안 취약
- HTML에서는 쿠키 단점을 보완해 등장한 웹 스토리지 사용
- 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없음

- 웹 스토리지 객체 조작은 JavaScript 내에서만 수행
- 오직 **문자형(string)** 데이터 타입만 지원

- 지속성에 따라 **로컬 스토리지(Local Storage)**와 **세션 스토리지(Session Storage)로 분류할 수** 있으며, 같은 Storage 객체를 상속하기 때문에 메서드가 동일

### 3.1. 로컬 스토리지(Local Storage)

- 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있음 (**영구성**)
- 단, 동일한 브라우저를 사용할 때만 해당
- 정리하면, 브라우저 자체에 **반영구적**으로 데이터를 저장하며, 브라우저를 종료해도 데이터가 유지됩니다. 다만 **도메인(domain)이 다른 경우** 로컬 스토리지에 접근할 수 없다.
- 지속적으로 필요한 데이터 저장(자동 로그인 등)

### 3.2. 세션 스토리지(Session Storage)

- 데이터가 **브라우저 탭에 종속(탭 윈도우 단위로 생성)**되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거
- 일시적으로 필요한 데이터 저장(일회성 로그인 정보, 입력폼 저장 등)
- 정리하면, 각 세션마다 데이터가 개별 저장되며, 브라우저 탭 닫을 시 데이터가 제거됨

**데이터 사용 예시**

자동로그인 : 로컬 스토리지

입력 폼 정보, 비로그인 장바구니 : 세션 스토리지

다시보기 팝업 : 쿠키