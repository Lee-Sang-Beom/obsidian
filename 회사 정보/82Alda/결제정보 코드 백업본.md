> `use-membership-payment.ts`
```ts
import { useCallback, useEffect, useRef, useState } from 'react'  
import { toast } from 'sonner'  
import { useOpenMembershipDialog } from '@/pages/my-page/hooks/modal/use-open-membership-dialog.ts'  
import { useAuthStore } from '@/store/use-auth-store.ts'  
import type { DeviceType } from '@/pages/auth/types'  
import { useQueryClient } from '@tanstack/react-query'  
import { useGetUserInfo } from '@/hooks/use-get-user-info-query.ts'  
import { usePaymentInitiate } from '@/pages/my-page/hooks/action/use-payment-initiate-action.ts'  
import { useVerifyGoogleAction } from '@/pages/my-page/hooks/action/use-verify-google-action.ts'  
import type {  
  BasePlanTypeEnum,  
  InnerPaymentPlanId,  
  PaymentInitiationRequest,  
  PaymentInitiationResponse,  
  PaymentPlatformEnum,  
  PaymentVerificationGoogleRequest,  
  PaymentVerificationIOSRequest,  
  ProductTypeEnum,  
} from '@/pages/my-page/types'  
import { getCurrentMembershipPlan } from '@/pages/my-page/utils.ts'  
import { useGooglePayment } from '@/pages/my-page/hooks/payment/use-google-payment.ts'  
import { sleep } from '@/lib/utils'  
import { useAppStorePayment } from '@/pages/my-page/hooks/payment/use-app-store-payment.ts'  
import { useVerifyAppleAction } from '@/pages/my-page/hooks/action/use-verify-apple-action.ts'  
  
interface PaymentOption {  
  id: InnerPaymentPlanId  
  membershipType: 'PREMIUM' | 'BASIC'  
  plan: 'monthly' | 'semiannually'  
}  
  
interface PurchaseResult {  
  success: boolean  
  status?: 'success' | 'pending' | 'failed' | 'cancelled' | 'restored'  
  message?: string  
  error?: string  
  errorMessage?: string  
  errorCode?: string  
  debug?: any  
  availableProducts?: string[]  
  availableBasePlans?: string[]  
  platform?: string  
  receiptData?: string  
  productId?: string  
  transactionId?: string  
  secretKey?: string  
  fcmToken?: string  
  basePlanId?: string  
}  
  
type SubscriptionChangeType = 'new' | 'upgrade' | 'downgrade' | 'periodChange' | 'change'  
  
export function useMembershipPayment() {  
  const queryClient = useQueryClient()  
  const { open, onClose: originalOnClose } = useOpenMembershipDialog()  
  
  // State  
  const [deviceType, setDeviceType] = useState<DeviceType>('WEB')  
  const [selectedPaymentOption, setSelectedPaymentOption] = useState<InnerPaymentPlanId | null>(null)  
  const [secretKey, setSecretKey] = useState<string | null>(null)  
  const [resSecretKey, setResSecretKey] = useState<string | null>(null)  
  const [isAuthReady, setIsAuthReady] = useState(false)  
  const [isPaymentProcessing, setIsPaymentProcessing] = useState(false)  
  const [authInitialized, setAuthInitialized] = useState(false)  
  const [paymentInitiationResponse, setPaymentInitiationResponse] = useState<PaymentInitiationResponse | null>(null)  
  
  const [pendingSecondStep, setPendingSecondStep] = useState<{  
    paymentInitiationResponse: PaymentInitiationResponse  
    paymentOption: PaymentOption  
  } | null>(null)  
  
  // Refs for preventing duplicate API calls  
  const paymentProcessingRef = useRef(false)  
  const receiptVerificationRef = useRef(false)  
  const processedReceiptsRef = useRef(new Set<string>())  
  const currentPaymentRequestRef = useRef<string | null>(null)  
  
  // Hooks  
  const { data: user } = useGetUserInfo(open)  
  const paymentInitiateMutation = usePaymentInitiate()  
  const verifyGoogleMutation = useVerifyGoogleAction()  
  const verifyAppleMutation = useVerifyAppleAction()  
  
  // Device-specific payment hooks  
  const isGooglePaymentEnabled = deviceType === 'ANDROID' && !!resSecretKey  
  const isAppStorePaymentEnabled = deviceType === 'IOS' && !!resSecretKey  
  
  const {  
    isProcessing: isGoogleProcessing,  
    processingOptionId: googleProcessingOptionId,  
    purchaseProduct: purchaseGoogleProduct,  
    subscriptionUpgrade,  
    subscriptionDowngrade,  
    subscriptionPeriodChange,  
    resetPaymentState: resetGooglePaymentState,  
  } = useGooglePayment({  
    secretKey: resSecretKey || undefined,  
    enabled: isGooglePaymentEnabled,  
    onPurchaseSuccess: async (result: PurchaseResult) => {  
      await handleSecondStepSuccess(result)  
    },  
    onPurchaseError: (error: string) => {  
      handlePaymentFailure(`Google Play 결제 실패: ${error}`)  
    },  
    onReceiptVerification: async (result: PurchaseResult) => {  
      await handleReceiptVerification(result)  
    },  
  })  
  
  const {  
    isProcessing: isAppStoreProcessing,  
    processingOptionId: appStoreProcessingOptionId,  
    purchaseProduct: purchaseAppStoreProduct,  
    subscriptionUpgrade: subscriptionIOSUpgrade,  
    subscriptionDowngrade: subscriptionIOSDowngrade,  
    subscriptionPeriodChange: subscriptionIOSPeriodChange,  
    resetPaymentState: resetAppStorePaymentState,  
  } = useAppStorePayment({  
    secretKey: resSecretKey || undefined,  
    enabled: isAppStorePaymentEnabled,  
    onPurchaseSuccess: async (result: PurchaseResult) => {  
      await handleSecondStepSuccess(result)  
    },  
    onPurchaseError: (error: string) => {  
      handlePaymentFailure(`App Store 결제 실패: ${error}`)  
    },  
    onReceiptVerification: async (result: PurchaseResult) => {  
      await handleReceiptIOSVerification(result)  
    },  
  })  
  
  // Utility functions  
  const resetAllStates = useCallback(() => {  
    setSelectedPaymentOption(null)  
    setResSecretKey(null)  
    setIsPaymentProcessing(false)  
    setPaymentInitiationResponse(null)  
    setPendingSecondStep(null)  
  
    paymentProcessingRef.current = false  
    receiptVerificationRef.current = false  
    processedReceiptsRef.current.clear()  
    currentPaymentRequestRef.current = null  
  
    resetGooglePaymentState?.()  
    resetAppStorePaymentState?.()  
    paymentInitiateMutation.reset?.()  
    verifyGoogleMutation.reset?.()  
  }, [resetGooglePaymentState, resetAppStorePaymentState, paymentInitiateMutation, verifyGoogleMutation])  
  
  const initializeAuth = useCallback(async () => {  
    try {  
      setIsAuthReady(false)  
      setAuthInitialized(false)  
  
      const [type, token] = await Promise.all([useAuthStore.getDeviceType(), useAuthStore.getToken()])  
  
      setDeviceType(type as DeviceType)  
      setSecretKey(token)  
      setIsAuthReady(true)  
      setAuthInitialized(true)  
    } catch (error) {  
      setDeviceType('WEB')  
      setSecretKey(null)  
      setIsAuthReady(true)  
      setAuthInitialized(true)  
    }  
  }, [])  
  
  const getSubscriptionChangeType = (targetOptionId: InnerPaymentPlanId): SubscriptionChangeType => {  
    if (!user?.membershipType || !user?.subscriptionPlan) {  
      return 'new'  
    }  
  
    const currentPlan = getCurrentMembershipPlan(user.membershipType, user.subscriptionPlan)  
  
    if (!currentPlan) {  
      return 'new'  
    }  
  
    const targetPlan = targetOptionId  
  
    // Upgrade: Basic → Premium (same period)  
    if (  
      (currentPlan === 'basic-monthly' && targetPlan === 'premium-monthly') ||  
      (currentPlan === 'basic-semiannually' && targetPlan === 'premium-semiannually')  
    ) {  
      return 'upgrade'  
    }  
  
    // Downgrade: Premium → Basic (same period)  
    if (currentPlan === 'premium-monthly' && targetPlan === 'basic-monthly') {  
      return 'downgrade'  
    }  
  
    // Period change or plan + period change  
    if (  
      (currentPlan === 'basic-monthly' && targetPlan === 'basic-semiannually') ||  
      (currentPlan === 'premium-monthly' && targetPlan === 'premium-semiannually') ||  
      (currentPlan === 'basic-monthly' && targetPlan === 'premium-semiannually') ||  
      (currentPlan === 'basic-semiannually' && targetPlan === 'premium-monthly')  
    ) {  
      return 'periodChange'  
    }  
  
    return 'change'  
  }  
  
  const convertToPaymentInitiationRequest = (optionId: InnerPaymentPlanId): PaymentInitiationRequest => {  
    const platformMap: Record<DeviceType, PaymentPlatformEnum> = {  
      ANDROID: 'GOOGLE',  
      IOS: 'APPLE',  
      WEB: 'GOOGLE',  
    }  
  
    const productTypeMap: Record<InnerPaymentPlanId, ProductTypeEnum> = {  
      'premium-monthly': 'PREMIUM',  
      'premium-semiannually': 'PREMIUM',  
      'basic-monthly': 'BASIC',  
      'basic-semiannually': 'BASIC',  
    }  
  
    const basePlanTypeMap: Record<InnerPaymentPlanId, BasePlanTypeEnum> = {  
      'premium-monthly': 'PREMIUM_MONTHLY',  
      'premium-semiannually': 'PREMIUM_SIX_MONTHS',  
      'basic-monthly': 'PREMIUM_MONTHLY',  
      'basic-semiannually': 'PREMIUM_SIX_MONTHS',  
    }  
  
    return {  
      platform: platformMap[deviceType],  
      productType: productTypeMap[optionId],  
      basePlanType: basePlanTypeMap[optionId],  
    }  
  }  
  
  const convertToPaymentOption = (optionId: InnerPaymentPlanId): PaymentOption | null => {  
    const optionMap: Record<InnerPaymentPlanId, PaymentOption> = {  
      'premium-monthly': { id: 'premium-monthly', membershipType: 'PREMIUM', plan: 'monthly' },  
      'premium-semiannually': { id: 'premium-semiannually', membershipType: 'PREMIUM', plan: 'semiannually' },  
      'basic-monthly': { id: 'basic-monthly', membershipType: 'BASIC', plan: 'monthly' },  
      'basic-semiannually': { id: 'basic-semiannually', membershipType: 'BASIC', plan: 'semiannually' },  
    }  
    return optionMap[optionId] || null  
  }  
  
  const getCurrentSubscriptionInfo = (): {  
    plan: 'basic' | 'premium' | null  
    period: 'monthly' | 'semiannually' | null  
    fullPlan: string | null  
  } => {  
    if (!user?.membershipType || !user?.subscriptionPlan) {  
      return { plan: null, period: null, fullPlan: null }  
    }  
  
    const currentPlan = getCurrentMembershipPlan(user.membershipType, user.subscriptionPlan)  
  
    if (!currentPlan) {  
      return { plan: null, period: null, fullPlan: null }  
    }  
  
    let plan: 'basic' | 'premium' | null = null  
    let period: 'monthly' | 'semiannually' | null = null  
  
    if (currentPlan.includes('basic')) {  
      plan = 'basic'  
    } else if (currentPlan.includes('premium')) {  
      plan = 'premium'  
    }  
  
    if (currentPlan.includes('semiannually')) {  
      period = 'semiannually'  
    } else if (currentPlan.includes('monthly')) {  
      period = 'monthly'  
    }  
  
    return { plan, period, fullPlan: currentPlan }  
  }  
  
  const getTargetSubscriptionInfo = (  
    optionId: InnerPaymentPlanId,  
  ): {  
    plan: 'basic' | 'premium'  
    period: 'monthly' | 'semiannually'  
  } => {  
    let plan: 'basic' | 'premium'  
    let period: 'monthly' | 'semiannually'  
  
    if (optionId.includes('basic')) {  
      plan = 'basic'  
    } else {  
      plan = 'premium'  
    }  
  
    if (optionId.includes('semiannually')) {  
      period = 'semiannually'  
    } else {  
      period = 'monthly'  
    }  
  
    return { plan, period }  
  }  
  
  const getCurrentSubscriptionPeriod = (): 'monthly' | 'semiannually' | null => {  
    const { period } = getCurrentSubscriptionInfo()  
    return period  
  }  
  
  // Event handlers  
  const handlePaymentFailure = useCallback(  
    (errorMessage: string) => {  
      console.error('Payment failed:', errorMessage)  
      resetAllStates()  
    },  
    [resetAllStates],  
  )  
  
  const onClose = () => {  
    originalOnClose(() => {  
      resetAllStates()  
    })  
  }  
  
  const executeSecondStep = async (  
    paymentInitiationResponse: PaymentInitiationResponse,  
    paymentOption: PaymentOption,  
  ) => {  
    try {  
      const changeType = getSubscriptionChangeType(paymentOption.id)  
      const purchaseToken = paymentInitiationResponse.receiptData  
  
      switch (deviceType) {  
        case 'ANDROID':  
          if (changeType === 'new' || !purchaseToken) {  
            await purchaseGoogleProduct(paymentOption)  
          } else {  
            switch (changeType) {  
              case 'upgrade': {  
                const currentPeriod = getCurrentSubscriptionPeriod()  
                await subscriptionUpgrade(purchaseToken, currentPeriod || 'monthly')  
                break  
              }  
              case 'downgrade':  
                await subscriptionDowngrade(purchaseToken)  
                break  
              case 'periodChange': {  
                const currentInfo = getCurrentSubscriptionInfo()  
                const targetInfo = getTargetSubscriptionInfo(paymentOption.id)  
  
                if (!currentInfo.plan || !currentInfo.period) {  
                  throw new Error('현재 구독 정보를 확인할 수 없습니다.')  
                }  
  
                await subscriptionPeriodChange(  
                  purchaseToken,  
                  currentInfo.plan,  
                  targetInfo.plan,  
                  currentInfo.period,  
                  targetInfo.period,  
                )  
                break  
              }  
              default:  
                await purchaseGoogleProduct(paymentOption)  
                break  
            }  
          }  
          break  
  
        case 'IOS':  
          if (changeType === 'new' || !purchaseToken) {  
            await purchaseAppStoreProduct(paymentOption)  
          } else {  
            switch (changeType) {  
              case 'upgrade': {  
                const currentPeriod = getCurrentSubscriptionPeriod()  
                await subscriptionIOSUpgrade(purchaseToken, currentPeriod || 'monthly')  
                break  
              }  
              case 'downgrade':  
                await subscriptionIOSDowngrade(purchaseToken)  
                break  
              case 'periodChange': {  
                const currentInfo = getCurrentSubscriptionInfo()  
                const targetInfo = getTargetSubscriptionInfo(paymentOption.id)  
  
                if (!currentInfo.plan || !currentInfo.period) {  
                  throw new Error('현재 구독 정보를 확인할 수 없습니다.')  
                }  
  
                await subscriptionIOSPeriodChange(  
                  purchaseToken,  
                  currentInfo.plan,  
                  targetInfo.plan,  
                  currentInfo.period,  
                  targetInfo.period,  
                )  
                break  
              }  
              default:  
                await purchaseAppStoreProduct(paymentOption)  
                break  
            }  
          }  
  
          break  
  
        case 'WEB':  
          throw new Error('웹에서는 다른 결제 방식을 이용해주세요.')  
  
        default:  
          throw new Error('올바르지 않은 디바이스 타입입니다.')  
      }  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '2단계 결제 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  const handleFirstStepSuccess = async (  
    paymentInitiationResponse: PaymentInitiationResponse,  
    paymentOption: PaymentOption,  
  ) => {  
    try {  
      setPaymentInitiationResponse(paymentInitiationResponse)  
  
      if (paymentInitiationResponse.secretKey) {  
        setResSecretKey(paymentInitiationResponse.secretKey)  
        setPendingSecondStep({ paymentInitiationResponse, paymentOption })  
      } else {  
        throw new Error('1단계 결제에서 secretKey를 받지 못했습니다.')  
      }  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '1단계 결제 완료 후 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  const handleSecondStepSuccess = async (_result: PurchaseResult) => {  
    // Step 2 success handled automatically by payment hooks  
  }  
  
  const handleReceiptVerification = async (result: PurchaseResult) => {  
    if (receiptVerificationRef.current) {  
      return  
    }  
  
    const receiptKey = result.transactionId || result.receiptData || 'unknown'  
    if (processedReceiptsRef.current.has(receiptKey)) {  
      return  
    }  
  
    try {  
      receiptVerificationRef.current = true  
      processedReceiptsRef.current.add(receiptKey)  
  
      if (!paymentInitiationResponse) {  
        throw new Error('결제 초기화 정보가 없습니다.')  
      }  
  
      // Validate required receipt data  
      if (  
        !result.receiptData ||  
        !result.productId ||  
        !result.basePlanId ||  
        !result.transactionId ||  
        !result.secretKey ||  
        !result.fcmToken  
      ) {  
        throw new Error('필수 영수증 데이터가 누락되었습니다.')  
      }  
  
      const verificationRequest: PaymentVerificationGoogleRequest = {  
        platform: result.platform as PaymentPlatformEnum,  
        receiptData: result.receiptData,  
        productId: result.productId,  
        basePlanId: result.basePlanId,  
        transactionId: result.transactionId,  
        secretKey: result.secretKey,  
        fcmToken: result.fcmToken,  
      }  
  
      if (verifyGoogleMutation.isPending) {  
        return  
      }  
  
      await sleep(2000)  
      await verifyGoogleMutation.mutateAsync(verificationRequest)  
  
      // Update user info after successful verification  
      await queryClient.invalidateQueries({  
        queryKey: ['useGetUserInfo'],  
      })  
  
      const changeType = selectedPaymentOption ? getSubscriptionChangeType(selectedPaymentOption) : 'new'  
      const successMessage = changeType === 'new' ? '결제가 완료되었습니다!' : '구독 변경이 완료되었습니다!'  
  
      toast.success(successMessage)  
      resetAllStates()  
      onClose()  
    } catch (error) {  
      processedReceiptsRef.current.delete(receiptKey)  
      const errorMessage = error instanceof Error ? error.message : '3단계 결제 처리 중 오류가 발생했습니다.'  
      console.error('Receipt verification failed:', error)  
      handlePaymentFailure(errorMessage)  
    } finally {  
      receiptVerificationRef.current = false  
    }  
  }  
  const handleReceiptIOSVerification = async (result: PurchaseResult) => {  
    if (receiptVerificationRef.current) {  
      return  
    }  
  
    const receiptKey = result.transactionId || result.receiptData || 'unknown'  
    if (processedReceiptsRef.current.has(receiptKey)) {  
      return  
    }  
  
    try {  
      receiptVerificationRef.current = true  
      processedReceiptsRef.current.add(receiptKey)  
  
      if (!paymentInitiationResponse) {  
        throw new Error('결제 초기화 정보가 없습니다.')  
      }  
  
      // Validate required receipt data  
      if (!result.receiptData || !result.productId || !result.transactionId || !result.secretKey || !result.fcmToken) {  
        throw new Error('필수 영수증 데이터가 누락되었습니다.')  
      }  
  
      const verificationRequest: PaymentVerificationIOSRequest = {  
        platform: result.platform as PaymentPlatformEnum,  
        receiptData: result.receiptData,  
        productId: result.productId,  
        transactionId: result.transactionId,  
        secretKey: result.secretKey,  
        fcmToken: result.fcmToken,  
      }  
  
      if (verifyAppleMutation.isPending) {  
        return  
      }  
  
      await sleep(2000)  
      await verifyAppleMutation.mutateAsync(verificationRequest)  
  
      // Update user info after successful verification  
      await queryClient.invalidateQueries({  
        queryKey: ['useGetUserInfo'],  
      })  
  
      const changeType = selectedPaymentOption ? getSubscriptionChangeType(selectedPaymentOption) : 'new'  
      const successMessage = changeType === 'new' ? '결제가 완료되었습니다!' : '구독 변경이 완료되었습니다!'  
  
      toast.success(successMessage)  
      resetAllStates()  
      onClose()  
    } catch (error) {  
      processedReceiptsRef.current.delete(receiptKey)  
      const errorMessage = error instanceof Error ? error.message : '3단계 결제 처리 중 오류가 발생했습니다.'  
      console.error('Receipt verification failed:', error)  
      handlePaymentFailure(errorMessage)  
    } finally {  
      receiptVerificationRef.current = false  
    }  
  }  
  
  const handlePayment = async () => {  
    if (paymentProcessingRef.current) {  
      return  
    }  
  
    if (!selectedPaymentOption) {  
      toast.error('결제 옵션을 선택해주세요.')  
      return  
    }  
  
    if (!isAuthReady) {  
      toast.error('사용자 정보를 불러오고 있습니다. 잠시 후 다시 시도해주세요.')  
      return  
    }  
  
    if (!secretKey) {  
      toast.error('사용자 정보를 불러올 수 없습니다. 다시 로그인해주세요.')  
      return  
    }  
  
    const paymentOption = convertToPaymentOption(selectedPaymentOption)  
    if (!paymentOption) {  
      toast.error('잘못된 결제 옵션입니다.')  
      return  
    }  
  
    const requestId = `${selectedPaymentOption}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`  
  
    if (currentPaymentRequestRef.current === requestId) {  
      return  
    }  
  
    try {  
      paymentProcessingRef.current = true  
      currentPaymentRequestRef.current = requestId  
      setIsPaymentProcessing(true)  
  
      if (paymentInitiateMutation.isPending) {  
        return  
      }  
      const paymentInitiationRequest = convertToPaymentInitiationRequest(selectedPaymentOption)  
      const response = await paymentInitiateMutation.mutateAsync(paymentInitiationRequest)  
      await handleFirstStepSuccess(response, paymentOption)  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '1단계 결제 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    } finally {  
      paymentProcessingRef.current = false  
      currentPaymentRequestRef.current = null  
      setIsPaymentProcessing(false)  
    }  
  }  
  
  // 버튼 UI Disabled 여부 반환  
  const isPaymentButtonDisabled = () => {  
    return (  
      !selectedPaymentOption ||  
      !authInitialized ||  
      !isAuthReady ||  
      !secretKey ||  
      paymentProcessingRef.current ||  
      receiptVerificationRef.current ||  
      isPaymentProcessing ||  
      isGoogleProcessing ||  
      isAppStoreProcessing ||  
      paymentInitiateMutation.isPending ||  
      verifyGoogleMutation.isPending ||  
      !!pendingSecondStep  
    )  
  }  
  
  // 버튼 텍스트 반환  
  const getPaymentButtonText = () => {  
    if (!authInitialized) return '초기화 중...'  
    if (!isAuthReady) return '사용자 정보 확인 중...'  
    if (!selectedPaymentOption) return '결제 옵션을 선택해주세요'  
    if (!secretKey) return '로그인이 필요합니다'  
    if (paymentInitiateMutation.isPending || paymentProcessingRef.current) return '1단계 처리 중...'  
    if (pendingSecondStep) return '2단계 준비 중...'  
    if (isGoogleProcessing || isAppStoreProcessing) return '2단계 처리 중...'  
    if (verifyGoogleMutation.isPending || receiptVerificationRef.current) return '3단계 처리 중...'  
    if (isPaymentProcessing) return '결제 처리 중...'  
  
    const isCurrentOptionProcessing =  
      selectedPaymentOption === googleProcessingOptionId || selectedPaymentOption === appStoreProcessingOptionId  
  
    if (isCurrentOptionProcessing) return '결제 처리 중...'  
  
    const changeType = selectedPaymentOption ? getSubscriptionChangeType(selectedPaymentOption) : 'new'  
    const actionText = changeType === 'new' ? '결제하기' : '구독 변경하기'  
  
    switch (deviceType) {  
      case 'ANDROID':  
        return `Google Play로 ${actionText}`  
      case 'IOS':  
        return `App Store로 ${actionText}`  
      case 'WEB':  
      default:  
        return actionText  
    }  
  }  
  
  // 전체에 걸친 결제중인지에 대한 여부  
  const isAnyPaymentProcessing = () => {  
    return (  
      paymentProcessingRef.current ||  
      receiptVerificationRef.current ||  
      isPaymentProcessing ||  
      isGoogleProcessing ||  
      isAppStoreProcessing ||  
      paymentInitiateMutation.isPending ||  
      verifyGoogleMutation.isPending ||  
      !!pendingSecondStep  
    )  
  }  
  
  // Effects  
  useEffect(() => {  
    initializeAuth()  
  }, [open, initializeAuth])  
  
  useEffect(() => {  
    if (resSecretKey && pendingSecondStep && !paymentProcessingRef.current) {  
      executeSecondStep(pendingSecondStep.paymentInitiationResponse, pendingSecondStep.paymentOption)  
      setPendingSecondStep(null)  
    }  
  }, [resSecretKey, pendingSecondStep])  
  
  return {  
    isAnyPaymentProcessing,  
    selectedPaymentOption,  
    setSelectedPaymentOption,  
    handlePayment,  
    getPaymentButtonText,  
    isPaymentButtonDisabled,  
    onClose,  
  }  
}
```


> `use-google-payment.ts`
```ts
import { useCallback, useEffect, useRef, useState } from 'react'  
import { toast } from 'sonner'  
import {  
  GOOGLE_6MONTHS_PLAN_ID,  
  GOOGLE_BASIC_PRODUCT_ID,  
  GOOGLE_MONTHLY_PLAN_ID,  
  GOOGLE_PREMIUM_PRODUCT_ID,  
} from '../../data'  
  
interface PaymentInfo {  
  productId: string  
  productType: 'subs'  
  basePlanId: string  
  secretKey: string  
  purchaseToken?: string  
  currentProductId?: string  
  currentBasePlanId?: string  
}  
  
interface PurchaseResult {  
  success: boolean  
  status?: 'success' | 'pending' | 'failed' | 'cancelled' | 'restored'  
  message?: string  
  error?: string  
  errorMessage?: string  
  errorCode?: string  
  debug?: any  
  availableProducts?: string[]  
  availableBasePlans?: string[]  
  platform?: string  
  receiptData?: string  
  productId?: string  
  transactionId?: string  
  secretKey?: string  
  fcmToken?: string  
  basePlanId?: string  
}  
  
interface PaymentOption {  
  id: string  
  membershipType: 'PREMIUM' | 'BASIC'  
  plan: 'monthly' | 'semiannually'  
}  
  
interface SubscriptionChangeConfig {  
  currentProductId: string  
  currentBasePlanId: string  
  targetProductId: string  
  targetBasePlanId: string  
  description: string  
}  
  
interface UseGooglePaymentOptions {  
  onPurchaseSuccess: (result: PurchaseResult) => void  
  onPurchaseError?: (error: string) => void  
  onReceiptVerification: (receiptData: PurchaseResult) => void  
  secretKey?: string  
  enabled?: boolean  
}  
  
interface UseGooglePaymentReturn {  
  isProcessing: boolean  
  processingOptionId: string | null  
  purchaseProduct: (option: PaymentOption) => Promise<void>  
  subscriptionUpgrade: (purchaseToken: string, currentPlan?: 'monthly' | 'semiannually') => Promise<void>  
  subscriptionDowngrade: (purchaseToken: string) => Promise<void>  
  subscriptionPeriodChange: (  
    purchaseToken: string,  
    fromPlan: 'basic' | 'premium',  
    toPlan: 'basic' | 'premium',  
    fromPeriod: 'monthly' | 'semiannually',  
    toPeriod: 'monthly' | 'semiannually',  
  ) => Promise<void>  
  isReady: boolean  
  resetPaymentState: () => void  
}  
  
const getGoogleProductInfo = (option: PaymentOption) => {  
  const basePlanMap = {  
    'premium-monthly': { productId: GOOGLE_PREMIUM_PRODUCT_ID, basePlanId: GOOGLE_MONTHLY_PLAN_ID },  
    'premium-semiannually': { productId: GOOGLE_PREMIUM_PRODUCT_ID, basePlanId: GOOGLE_6MONTHS_PLAN_ID },  
    'basic-monthly': { productId: GOOGLE_BASIC_PRODUCT_ID, basePlanId: GOOGLE_MONTHLY_PLAN_ID },  
    'basic-semiannually': { productId: GOOGLE_BASIC_PRODUCT_ID, basePlanId: GOOGLE_6MONTHS_PLAN_ID },  
  }  
  
  return basePlanMap[option.id as keyof typeof basePlanMap]  
}  
  
export function useGooglePayment({  
  onPurchaseSuccess,  
  onPurchaseError,  
  onReceiptVerification,  
  secretKey: providedSecretKey,  
  enabled = true,  
}: UseGooglePaymentOptions): UseGooglePaymentReturn {  
  // State  
  const [isProcessing, setIsProcessing] = useState(false)  
  const [processingOptionId, setProcessingOptionId] = useState<string | null>(null)  
  
  // Refs  
  const isActiveRef = useRef(enabled)  
  const paymentSecretKey = providedSecretKey  
  
  // Utility functions  
  const resetAllGoogleStates = useCallback(() => {  
    setIsProcessing(false)  
    setProcessingOptionId(null)  
  }, [])  
  
  const purchaseProductWithBasePlan = async (  
    productId: string,  
    productType: 'subs',  
    basePlanId: string,  
    secretKeyForPayment: string,  
    purchaseToken?: string,  
    currentProductId?: string,  
    currentBasePlanId?: string,  
  ): Promise<void> => {  
    const isSubscriptionChange = !!purchaseToken && !!currentProductId  
    const actionType = isSubscriptionChange ? '구독 전환' : '구매'  
  
    const paymentInfo: PaymentInfo = {  
      productId,  
      productType,  
      basePlanId,  
      secretKey: secretKeyForPayment,  
      purchaseToken,  
    }  
  
    if (isSubscriptionChange) {  
      paymentInfo.currentProductId = currentProductId  
      paymentInfo.currentBasePlanId = currentBasePlanId  
    }  
  
    if (!enabled) {  
      const errorMessage = 'Google Payment가 비활성화되어 있습니다.'  
      toast.error(errorMessage)  
      onPurchaseError?.(errorMessage)  
      throw new Error(errorMessage)  
    }  
  
    if (window.flutter_inappwebview?.callHandler) {  
      try {  
        const result: PurchaseResult = await window.flutter_inappwebview.callHandler('requestPayment', paymentInfo)  
  
        if (!result.success) {  
          const errorMessage = result.error || result.errorMessage || `${actionType} 요청에 실패했습니다.`  
          toast.error(`${actionType} 요청 실패: ${errorMessage}`)  
          onPurchaseError?.(errorMessage)  
          throw new Error(errorMessage)  
        }  
      } catch (error) {  
        const errorMessage = error instanceof Error ? error.message : `${actionType} 중 오류가 발생했습니다.`  
        toast.error(`${actionType} 요청 오류: ${errorMessage}`)  
        onPurchaseError?.(errorMessage)  
        throw error  
      }  
    } else {  
      const errorMessage = '앱 환경에서만 Google Play 결제가 가능합니다.'  
      toast.info(errorMessage)  
      onPurchaseError?.(errorMessage)  
      throw new Error(errorMessage)  
    }  
  }  
  
  const executeSubscriptionChange = async (config: SubscriptionChangeConfig, purchaseToken: string): Promise<void> => {  
    if (isProcessing) {  
      toast.warning('이미 결제가 진행 중입니다.')  
      return  
    }  
  
    if (!paymentSecretKey) {  
      toast.error('결제 정보를 불러올 수 없습니다. 다시 시도해주세요.')  
      return  
    }  
  
    if (!purchaseToken) {  
      toast.error('구매 토큰을 입력해주세요.')  
      return  
    }  
  
    setIsProcessing(true)  
    setProcessingOptionId(config.targetProductId)  
  
    try {  
      await purchaseProductWithBasePlan(  
        config.targetProductId,  
        'subs',  
        config.targetBasePlanId,  
        paymentSecretKey,  
        purchaseToken,  
        config.currentProductId,  
        config.currentBasePlanId,  
      )  
    } catch (error) {  
      console.error('Subscription change failed:', error)  
      resetAllGoogleStates()  
    }  
  }  
  
  // Main functions  
  const purchaseProduct = async (option: PaymentOption): Promise<void> => {  
    if (!enabled) {  
      toast.error('Google Payment가 비활성화되어 있습니다.')  
      return  
    }  
  
    if (isProcessing) {  
      toast.warning('이미 결제가 진행 중입니다.')  
      return  
    }  
  
    if (!paymentSecretKey) {  
      toast.error('결제 정보를 불러올 수 없습니다. 다시 시도해주세요.')  
      return  
    }  
  
    const productInfo = getGoogleProductInfo(option)  
    if (!productInfo) {  
      toast.error('지원하지 않는 결제 옵션입니다.')  
      return  
    }  
  
    setIsProcessing(true)  
    setProcessingOptionId(option.id)  
  
    try {  
      await purchaseProductWithBasePlan(productInfo.productId, 'subs', productInfo.basePlanId, paymentSecretKey)  
    } catch (error) {  
      console.error('Purchase failed:', error)  
      resetAllGoogleStates()  
    }  
  }  
  
  const subscriptionUpgrade = async (  
    purchaseToken: string,  
    currentPlan: 'monthly' | 'semiannually' = 'monthly',  
  ): Promise<void> => {  
    let config: SubscriptionChangeConfig  
  
    if (currentPlan === 'monthly') {  
      config = {  
        currentProductId: GOOGLE_BASIC_PRODUCT_ID,  
        currentBasePlanId: GOOGLE_MONTHLY_PLAN_ID,  
        targetProductId: GOOGLE_PREMIUM_PRODUCT_ID,  
        targetBasePlanId: GOOGLE_MONTHLY_PLAN_ID,  
        description: '베이직 월간에서 프리미엄 월간으로 업그레이드',  
      }  
    } else {  
      config = {  
        currentProductId: GOOGLE_BASIC_PRODUCT_ID,  
        currentBasePlanId: GOOGLE_6MONTHS_PLAN_ID,  
        targetProductId: GOOGLE_PREMIUM_PRODUCT_ID,  
        targetBasePlanId: GOOGLE_6MONTHS_PLAN_ID,  
        description: '베이직 6개월에서 프리미엄 6개월로 업그레이드',  
      }  
    }  
  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  const subscriptionDowngrade = async (purchaseToken: string): Promise<void> => {  
    const config: SubscriptionChangeConfig = {  
      currentProductId: GOOGLE_PREMIUM_PRODUCT_ID,  
      currentBasePlanId: GOOGLE_MONTHLY_PLAN_ID,  
      targetProductId: GOOGLE_BASIC_PRODUCT_ID,  
      targetBasePlanId: GOOGLE_MONTHLY_PLAN_ID,  
      description: '프리미엄 월간에서 베이직 월간으로 다운그레이드',  
    }  
  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  const subscriptionPeriodChange = async (  
    purchaseToken: string,  
    fromPlan: 'basic' | 'premium',  
    toPlan: 'basic' | 'premium',  
    fromPeriod: 'monthly' | 'semiannually',  
    toPeriod: 'monthly' | 'semiannually',  
  ): Promise<void> => {  
    const periodIdMap = {  
      monthly: GOOGLE_MONTHLY_PLAN_ID,  
      semiannually: GOOGLE_6MONTHS_PLAN_ID,  
    }  
  
    const productIdMap = {  
      basic: GOOGLE_BASIC_PRODUCT_ID,  
      premium: GOOGLE_PREMIUM_PRODUCT_ID,  
    }  
  
    const config = {  
      currentProductId: productIdMap[fromPlan],  
      currentBasePlanId: periodIdMap[fromPeriod],  
      targetProductId: productIdMap[toPlan],  
      targetBasePlanId: periodIdMap[toPeriod],  
      description: `${fromPlan} ${fromPeriod}에서 ${toPlan} ${toPeriod}로 구독 변경`,  
    }  
  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  // Event handlers  
  const handleReceiptVerification = useCallback(  
    (receiptData: PurchaseResult) => {  
      if (!enabled || !isActiveRef.current || (receiptData.platform && receiptData.platform !== 'GOOGLE')) {  
        return  
      }  
  
      resetAllGoogleStates()  
      onReceiptVerification?.(receiptData)  
    },  
    [enabled, onReceiptVerification, resetAllGoogleStates],  
  )  
  
  const handlePurchaseResult = useCallback(  
    (result: PurchaseResult) => {  
      if (!enabled || !isActiveRef.current || (result.platform && result.platform !== 'GOOGLE')) {  
        return  
      }  
  
      switch (result.status) {  
        case 'success':  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
          break  
  
        case 'pending':  
          toast.info(  
            `Google 구매 대기 중: ${result.productId || '상품'} - ${result.message || '결제를 처리하고 있습니다'}`,  
          )  
          onPurchaseSuccess?.(result)  
          break  
  
        case 'failed': {  
          const failMessage = `Google 구매 실패: ${result.productId || '상품'} - ${result.errorMessage || '알 수 없는 오류'} ${result.errorCode ? `(코드: ${result.errorCode})` : ''}`  
          toast.error(failMessage)  
          resetAllGoogleStates()  
          onPurchaseError?.(result.errorMessage || '구매에 실패했습니다.')  
          break  
        }  
  
        case 'cancelled':  
          toast.info(  
            `Google 구매 취소: ${result.productId || '상품'} - ${result.message || '사용자가 결제를 취소했습니다'}`,  
          )  
          resetAllGoogleStates()  
          break  
  
        case 'restored':  
          toast.success(  
            `Google 구매 복원: ${result.productId || '상품'} ${result.transactionId ? `(거래 ID: ${result.transactionId})` : ''}`,  
          )  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
          break  
  
        default:  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
      }  
    },  
    [enabled, onPurchaseSuccess, onPurchaseError, handleReceiptVerification, resetAllGoogleStates],  
  )  
  
  // Effects  
  useEffect(() => {  
    isActiveRef.current = true  
    return () => {  
      isActiveRef.current = false  
      resetAllGoogleStates()  
    }  
  }, [resetAllGoogleStates])  
  
  useEffect(() => {  
    isActiveRef.current = enabled  
  }, [enabled])  
  
  useEffect(() => {  
    if (typeof window === 'undefined' || !enabled) return  
  
    const existingPurchaseHandler = window.handlePurchaseResult  
    const existingReceiptHandler = window.handleReceiptVerification  
  
    window.handlePurchaseResult = (result: PurchaseResult) => {  
      if (existingPurchaseHandler && existingPurchaseHandler !== handlePurchaseResult) {  
        try {  
          existingPurchaseHandler(result)  
        } catch (error) {  
          console.error('기존 handlePurchaseResult 호출 중 오류:', error)  
        }  
      }  
      handlePurchaseResult(result)  
    }  
  
    window.handleReceiptVerification = (receiptData: PurchaseResult) => {  
      if (existingReceiptHandler && existingReceiptHandler !== handleReceiptVerification) {  
        try {  
          existingReceiptHandler(receiptData)  
        } catch (error) {  
          console.error('기존 handleReceiptVerification 호출 중 오류:', error)  
        }  
      }  
      handleReceiptVerification(receiptData)  
    }  
  
    return () => {  
      if (window.handlePurchaseResult) {  
        window.handlePurchaseResult = existingPurchaseHandler  
      }  
      if (window.handleReceiptVerification) {  
        window.handleReceiptVerification = existingReceiptHandler  
      }  
    }  
  }, [handlePurchaseResult, handleReceiptVerification, enabled])  
  
  return {  
    isProcessing: enabled ? isProcessing : false,  
    processingOptionId,  
    purchaseProduct,  
    subscriptionUpgrade,  
    subscriptionDowngrade,  
    subscriptionPeriodChange,  
    isReady: !!paymentSecretKey && enabled,  
    resetPaymentState: resetAllGoogleStates,  
  }  
}  
  
declare global {  
  interface Window {  
    flutter_inappwebview?: {  
      callHandler: (method: string, ...args: any[]) => Promise<any>  
    }  
    handlePurchaseResult?: (result: PurchaseResult) => void  
    handleReceiptVerification?: (result: PurchaseResult) => void  
  }  
}
```

> `use-app-store-payment.ts`
```ts
import { useCallback, useEffect, useRef, useState } from 'react'  
import { toast } from 'sonner'  
import {  
  APPLE_BASIC_MONTHLY_PRODUCT_ID,  
  APPLE_BASIC_6MONTHS_PRODUCT_ID,  
  APPLE_PREMIUM_MONTHLY_PRODUCT_ID,  
  APPLE_PREMIUM_6MONTHS_PRODUCT_ID,  
} from '../../data'  
  
interface PaymentInfo {  
  productId: string  
  productType: 'subs'  
  // basePlanId: string  
  secretKey: string  
  purchaseToken?: string  
  currentProductId?: string  
  currentBasePlanId?: string  
}  
  
interface PurchaseResult {  
  success: boolean  
  status?: 'success' | 'pending' | 'failed' | 'cancelled' | 'restored'  
  message?: string  
  error?: string  
  errorMessage?: string  
  errorCode?: string  
  debug?: any  
  availableProducts?: string[]  
  availableBasePlans?: string[]  
  platform?: string  
  receiptData?: string  
  productId?: string  
  transactionId?: string  
  secretKey?: string  
  fcmToken?: string  
  basePlanId?: string  
}  
  
interface PaymentOption {  
  id: string  
  membershipType: 'PREMIUM' | 'BASIC'  
  plan: 'monthly' | 'semiannually'  
}  
  
interface SubscriptionChangeConfig {  
  currentProductId: string  
  currentBasePlanId: string  
  targetProductId: string  
  targetBasePlanId: string  
  description: string  
}  
  
interface UseAppStorePaymentOptions {  
  onPurchaseSuccess: (result: PurchaseResult) => void  
  onPurchaseError?: (error: string) => void  
  onReceiptVerification: (receiptData: PurchaseResult) => void  
  secretKey?: string  
  enabled?: boolean  
}  
  
interface UseAppStorePaymentReturn {  
  isProcessing: boolean  
  processingOptionId: string | null  
  purchaseProduct: (option: PaymentOption) => Promise<void>  
  subscriptionUpgrade: (purchaseToken: string, currentPlan?: 'monthly' | 'semiannually') => Promise<void>  
  subscriptionDowngrade: (purchaseToken: string) => Promise<void>  
  subscriptionPeriodChange: (  
    purchaseToken: string,  
    fromPlan: 'basic' | 'premium',  
    toPlan: 'basic' | 'premium',  
    fromPeriod: 'monthly' | 'semiannually',  
    toPeriod: 'monthly' | 'semiannually',  
  ) => Promise<void>  
  isReady: boolean  
  resetPaymentState: () => void  
}  
  
const getAppStoreProductInfo = (option: PaymentOption) => {  
  const productIdMap = {  
    'premium-monthly': { productId: APPLE_PREMIUM_MONTHLY_PRODUCT_ID, basePlanId: 'monthly' },  
    'premium-semiannually': { productId: APPLE_PREMIUM_6MONTHS_PRODUCT_ID, basePlanId: 'semiannually' },  
    'basic-monthly': { productId: APPLE_BASIC_MONTHLY_PRODUCT_ID, basePlanId: 'monthly' },  
    'basic-semiannually': { productId: APPLE_BASIC_6MONTHS_PRODUCT_ID, basePlanId: 'semiannually' },  
  }  
  
  return productIdMap[option.id as keyof typeof productIdMap]  
}  
  
export function useAppStorePayment({  
  onPurchaseSuccess,  
  onPurchaseError,  
  onReceiptVerification,  
  secretKey: providedSecretKey,  
  enabled = true,  
}: UseAppStorePaymentOptions): UseAppStorePaymentReturn {  
  // State  
  const [isProcessing, setIsProcessing] = useState(false)  
  const [processingOptionId, setProcessingOptionId] = useState<string | null>(null)  
  
  // Refs  
  const isActiveRef = useRef(enabled)  
  const paymentSecretKey = providedSecretKey  
  
  // Utility functions  
  const resetAllAppStoreStates = useCallback(() => {  
    setIsProcessing(false)  
    setProcessingOptionId(null)  
  }, [])  
  
  const purchaseProductWithBasePlan = async (  
    productId: string,  
    productType: 'subs',  
    basePlanId: string,  
    secretKeyForPayment: string,  
    purchaseToken?: string,  
    currentProductId?: string,  
    currentBasePlanId?: string,  
  ): Promise<void> => {  
    const isSubscriptionChange = !!purchaseToken && !!currentProductId  
    const actionType = isSubscriptionChange ? '구독 전환' : '구매'  
  
    const paymentInfo: PaymentInfo = {  
      productId,  
      productType,  
      // basePlanId,  
      secretKey: secretKeyForPayment,  
      purchaseToken,  
    }  
  
    if (isSubscriptionChange) {  
      paymentInfo.currentProductId = currentProductId  
      paymentInfo.currentBasePlanId = currentBasePlanId  
    }  
  
    if (!enabled) {  
      const errorMessage = 'App Store Payment가 비활성화되어 있습니다.'  
      toast.error(errorMessage)  
      onPurchaseError?.(errorMessage)  
      throw new Error(errorMessage)  
    }  
  
    if (window.flutter_inappwebview?.callHandler) {  
      try {  
        const result: PurchaseResult = await window.flutter_inappwebview.callHandler('requestPayment', paymentInfo)  
  
        if (!result.success) {  
          const errorMessage = result.error || result.errorMessage || `${actionType} 요청에 실패했습니다.`  
          toast.error(`${actionType} 요청 실패: ${errorMessage}`)  
          onPurchaseError?.(errorMessage)  
          throw new Error(errorMessage)  
        }  
      } catch (error) {  
        const errorMessage = error instanceof Error ? error.message : `${actionType} 중 오류가 발생했습니다.`  
        toast.error(`${actionType} 요청 오류: ${errorMessage}`)  
        onPurchaseError?.(errorMessage)  
        throw error  
      }  
    } else {  
      const errorMessage = '앱 환경에서만 App Store 결제가 가능합니다.'  
      toast.info(errorMessage)  
      onPurchaseError?.(errorMessage)  
      throw new Error(errorMessage)  
    }  
  }  
  
  const executeSubscriptionChange = async (config: SubscriptionChangeConfig, purchaseToken: string): Promise<void> => {  
    if (isProcessing) {  
      toast.warning('이미 결제가 진행 중입니다.')  
      return  
    }  
  
    if (!paymentSecretKey) {  
      toast.error('결제 정보를 불러올 수 없습니다. 다시 시도해주세요.')  
      return  
    }  
  
    if (!purchaseToken) {  
      toast.error('구매 토큰을 입력해주세요.')  
      return  
    }  
  
    setIsProcessing(true)  
    setProcessingOptionId(config.targetProductId)  
  
    try {  
      await purchaseProductWithBasePlan(  
        config.targetProductId,  
        'subs',  
        config.targetBasePlanId,  
        paymentSecretKey,  
        purchaseToken,  
        config.currentProductId,  
        config.currentBasePlanId,  
      )  
    } catch (error) {  
      console.error('Subscription change failed:', error)  
      resetAllAppStoreStates()  
    }  
  }  
  
  // Main functions  
  const purchaseProduct = async (option: PaymentOption): Promise<void> => {  
    if (!enabled) {  
      toast.error('App Store Payment가 비활성화되어 있습니다.')  
      return  
    }  
  
    if (isProcessing) {  
      toast.warning('이미 결제가 진행 중입니다.')  
      return  
    }  
  
    if (!paymentSecretKey) {  
      toast.error('결제 정보를 불러올 수 없습니다. 다시 시도해주세요.')  
      return  
    }  
  
    const productInfo = getAppStoreProductInfo(option)  
    if (!productInfo) {  
      toast.error('지원하지 않는 결제 옵션입니다.')  
      return  
    }  
  
    setIsProcessing(true)  
    setProcessingOptionId(option.id)  
  
    try {  
      await purchaseProductWithBasePlan(productInfo.productId, 'subs', productInfo.basePlanId, paymentSecretKey)  
    } catch (error) {  
      console.error('Purchase failed:', error)  
      resetAllAppStoreStates()  
    }  
  }  
  
  const subscriptionUpgrade = async (  
    purchaseToken: string,  
    currentPlan: 'monthly' | 'semiannually' = 'monthly',  
  ): Promise<void> => {  
    let config: SubscriptionChangeConfig  
  
    if (currentPlan === 'monthly') {  
      config = {  
        currentProductId: APPLE_BASIC_MONTHLY_PRODUCT_ID,  
        currentBasePlanId: 'monthly',  
        targetProductId: APPLE_PREMIUM_MONTHLY_PRODUCT_ID,  
        targetBasePlanId: 'monthly',  
        description: '베이직 월간에서 프리미엄 월간으로 업그레이드',  
      }  
    } else {  
      config = {  
        currentProductId: APPLE_BASIC_6MONTHS_PRODUCT_ID,  
        currentBasePlanId: 'semiannually',  
        targetProductId: APPLE_PREMIUM_6MONTHS_PRODUCT_ID,  
        targetBasePlanId: 'semiannually',  
        description: '베이직 6개월에서 프리미엄 6개월로 업그레이드',  
      }  
    }  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  const subscriptionDowngrade = async (purchaseToken: string): Promise<void> => {  
    const config: SubscriptionChangeConfig = {  
      currentProductId: APPLE_PREMIUM_MONTHLY_PRODUCT_ID,  
      currentBasePlanId: 'monthly',  
      targetProductId: APPLE_BASIC_MONTHLY_PRODUCT_ID,  
      targetBasePlanId: 'monthly',  
      description: '프리미엄 월간에서 베이직 월간으로 다운그레이드',  
    }  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  const subscriptionPeriodChange = async (  
    purchaseToken: string,  
    fromPlan: 'basic' | 'premium',  
    toPlan: 'basic' | 'premium',  
    fromPeriod: 'monthly' | 'semiannually',  
    toPeriod: 'monthly' | 'semiannually',  
  ): Promise<void> => {  
    const productIdMap = {  
      'basic-monthly': APPLE_BASIC_MONTHLY_PRODUCT_ID,  
      'basic-semiannually': APPLE_BASIC_6MONTHS_PRODUCT_ID,  
      'premium-monthly': APPLE_PREMIUM_MONTHLY_PRODUCT_ID,  
      'premium-semiannually': APPLE_PREMIUM_6MONTHS_PRODUCT_ID,  
    }  
  
    const basePlanIdMap = {  
      monthly: 'monthly',  
      semiannually: 'semiannually',  
    }  
  
    const fromKey = `${fromPlan}-${fromPeriod}` as keyof typeof productIdMap  
    const toKey = `${toPlan}-${toPeriod}` as keyof typeof productIdMap  
  
    const config = {  
      currentProductId: productIdMap[fromKey],  
      currentBasePlanId: basePlanIdMap[fromPeriod],  
      targetProductId: productIdMap[toKey],  
      targetBasePlanId: basePlanIdMap[toPeriod],  
      description: `${fromPlan} ${fromPeriod}에서 ${toPlan} ${toPeriod}로 구독 변경`,  
    }  
    await executeSubscriptionChange(config, purchaseToken)  
  }  
  
  // Event handlers  
  const handleReceiptVerification = useCallback(  
    (receiptData: PurchaseResult) => {  
      if (!enabled || !isActiveRef.current || (receiptData.platform && receiptData.platform !== 'APPLE')) {  
        return  
      }  
  
      resetAllAppStoreStates()  
      onReceiptVerification?.(receiptData)  
    },  
    [enabled, onReceiptVerification, resetAllAppStoreStates],  
  )  
  
  const handlePurchaseResult = useCallback(  
    (result: PurchaseResult) => {  
      if (!enabled || !isActiveRef.current || (result.platform && result.platform !== 'APPLE')) {  
        return  
      }  
  
      switch (result.status) {  
        case 'success':  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
          break  
  
        case 'pending':  
          toast.info(  
            `App Store 구매 대기 중: ${result.productId || '상품'} - ${result.message || '결제를 처리하고 있습니다'}`,  
          )  
          onPurchaseSuccess?.(result)  
          break  
  
        case 'failed': {  
          const failMessage = `App Store 구매 실패: ${result.productId || '상품'} - ${result.errorMessage || '알 수 없는 오류'} ${result.errorCode ? `(코드: ${result.errorCode})` : ''}`  
          toast.error(failMessage)  
          resetAllAppStoreStates()  
          onPurchaseError?.(result.errorMessage || '구매에 실패했습니다.')  
          break  
        }  
  
        case 'cancelled':  
          toast.info(  
            `App Store 구매 취소: ${result.productId || '상품'} - ${result.message || '사용자가 결제를 취소했습니다'}`,  
          )  
          resetAllAppStoreStates()  
          break  
  
        case 'restored':  
          toast.success(  
            `App Store 구매 복원: ${result.productId || '상품'} ${result.receiptData} ${result.transactionId ? `(거래 ID: ${result.transactionId})` : ''}`,  
          )  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
          break  
  
        default:  
          onPurchaseSuccess?.(result)  
  
          if (result.receiptData && result.transactionId) {  
            handleReceiptVerification(result)  
          }  
      }  
    },  
    [enabled, onPurchaseSuccess, onPurchaseError, handleReceiptVerification, resetAllAppStoreStates],  
  )  
  
  // Effects  
  useEffect(() => {  
    isActiveRef.current = true  
    return () => {  
      isActiveRef.current = false  
      resetAllAppStoreStates()  
    }  
  }, [resetAllAppStoreStates])  
  
  useEffect(() => {  
    isActiveRef.current = enabled  
  }, [enabled])  
  
  useEffect(() => {  
    if (typeof window === 'undefined' || !enabled) return  
  
    const existingPurchaseHandler = window.handlePurchaseResult  
    const existingReceiptHandler = window.handleReceiptVerification  
  
    window.handlePurchaseResult = (result: PurchaseResult) => {  
      if (existingPurchaseHandler && existingPurchaseHandler !== handlePurchaseResult) {  
        try {  
          existingPurchaseHandler(result)  
        } catch (error) {  
          console.error('기존 handlePurchaseResult 호출 중 오류:', error)  
        }  
      }  
      handlePurchaseResult(result)  
    }  
  
    window.handleReceiptVerification = (receiptData: PurchaseResult) => {  
      if (existingReceiptHandler && existingReceiptHandler !== handleReceiptVerification) {  
        try {  
          existingReceiptHandler(receiptData)  
        } catch (error) {  
          console.error('기존 handleReceiptVerification 호출 중 오류:', error)  
        }  
      }  
      handleReceiptVerification(receiptData)  
    }  
  
    return () => {  
      if (window.handlePurchaseResult) {  
        window.handlePurchaseResult = existingPurchaseHandler  
      }  
      if (window.handleReceiptVerification) {  
        window.handleReceiptVerification = existingReceiptHandler  
      }  
    }  
  }, [handlePurchaseResult, handleReceiptVerification, enabled])  
  
  return {  
    isProcessing: enabled ? isProcessing : false,  
    processingOptionId,  
    purchaseProduct,  
    subscriptionUpgrade,  
    subscriptionDowngrade,  
    subscriptionPeriodChange,  
    isReady: !!paymentSecretKey && enabled,  
    resetPaymentState: resetAllAppStoreStates,  
  }  
}  
  
declare global {  
  interface Window {  
    flutter_inappwebview?: {  
      callHandler: (method: string, ...args: any[]) => Promise<any>  
    }  
    handlePurchaseResult?: (result: PurchaseResult) => void  
    handleReceiptVerification?: (result: PurchaseResult) => void  
  }  
}
```