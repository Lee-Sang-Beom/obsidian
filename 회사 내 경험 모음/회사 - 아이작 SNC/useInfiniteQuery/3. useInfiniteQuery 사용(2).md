### 📌 요구사항

- 팟캐스트 타입별로 다른 API 호출
- 페이지 단위 데이터 로딩
- 모든 페이지 데이터를 하나의 배열로 병합
- React key 중복 문제 해결

### 커스텀 훅 구현

```tsx
import { useLocation } from 'react-router-dom'
import { useInfiniteQuery } from '@tanstack/react-query'
import { podcastService } from '@/service/podcast-service.ts'
import { useMemo } from 'react'

interface UseInfinitePodcastsOptions {
  type?: PodcastRequestTypeEnum
  pageSize?: number
  enabled?: boolean
}

export const useInfinitePodcasts = ({
  type = 'domestic',
  pageSize = 10,
  enabled = true,
}: UseInfinitePodcastsOptions = {}) => {
  const location = useLocation()

  const {
    data: podcastData,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
    error,
    refetch,
  } = useInfiniteQuery({
    queryKey: ['useInfinitePodcasts', type, pageSize, location.pathname],
    
    queryFn: async ({ pageParam = 1 }) => {
      // 타입에 따라 다른 API 호출
      if (type === 'speech-output') {
        return await podcastService.getLiveSpeechOutputPodcasts({
          type,
          nowPage: pageParam,
          pageSize,
        })
      } else {
        return await podcastService.getPodcasts({
          type,
          nowPage: pageParam,
          pageSize,
        })
      }
    },
    
    getNextPageParam: (lastPage, allPages) => {
      const currentPage = allPages.length
      const totalPages = lastPage.lastPage
      return currentPage < totalPages ? currentPage + 1 : undefined
    },
    
    initialPageParam: 1,
    enabled,
  })

  // 모든 페이지 데이터를 하나의 배열로 병합
  const flattenedData = useMemo(() => {
    if (!podcastData?.pages) return []
    
    return podcastData.pages.flatMap((page, pageIndex) =>
      page.items.map((item, itemIndex) => {
        const uniqueKeyField = 'lmTitle' in item 
          ? `${item.lmTitle}-${item.lmContent}` 
          : item.title
        
        return {
          ...item,
          _uniqueKey: `${pageIndex}-${itemIndex}-${uniqueKeyField}`,
        }
      }),
    )
  }, [podcastData?.pages])

  return {
    data: flattenedData,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
    error,
    refetch,
  }
}
```

---

## 주요 특징 분석

### 1. **동적 API 선택**

```tsx
queryFn: async ({ pageParam = 1 }) => {
  if (type === 'speech-output') {
    return await podcastService.getLiveSpeechOutputPodcasts(...)
  } else {
    return await podcastService.getPodcasts(...)
  }
}
```

타입에 따라 다른 서비스 함수를 호출하여 유연한 데이터 fetching이 가능합니다.

### 2. **스마트한 QueryKey**

```tsx
queryKey: ['useInfinitePodcasts', type, pageSize, location.pathname]
```

타입, 페이지 크기, 현재 경로까지 포함하여 정확한 캐싱과 리페치를 보장합니다.

### 3. **데이터 병합과 고유 키 생성**

```tsx
const flattenedData = useMemo(() => {
  return podcastData.pages.flatMap((page, pageIndex) =>
    page.items.map((item, itemIndex) => ({
      ...item,
      _uniqueKey: `${pageIndex}-${itemIndex}-${uniqueKeyField}`,
    }))
  )
}, [podcastData?.pages])
```

모든 페이지의 데이터를 하나의 배열로 합치고, React key 중복 문제를 해결하기 위해 고유한 키를 생성합니다.

---

## 컴포넌트에서 사용하기

```tsx
import type { DetailPodcastResponse, PodcastRequestTypeEnum, PodcastResponse } from '../../types'  
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs.tsx'  
import { useCallback, useEffect, useRef, useState } from 'react'  
import { useInfinitePodcasts } from '@/pages/news/hooks/action/use-infinite-podcasts.ts'  
import { useGetPodcastDetail } from '@/pages/news/hooks/action/use-get-podcast-detail.ts'  
import useAppPlayerStore from '@/store/use-app-audio-store.ts'  
import PodcastList from './podcast-list'  
import { logScreenView } from '@/log/use-analytics.ts'  
  
interface NewsBottomSectionProps {  
  onOpenPodcast: (podcast: DetailPodcastResponse, audioSrc: string | null) => void  
}  
  
export default function NewsBottomSection({ onOpenPodcast }: NewsBottomSectionProps) {  
  const [scheduleFilter, setScheduleFilter] = useState<PodcastRequestTypeEnum>('domestic')  
  const [activeTab, setActiveTab] = useState<string>('domestic')  
  const observerRef = useRef<IntersectionObserver | null>(null)  
  const [selectedPodcastId, setSelectedPodcastId] = useState<string | null>(null)  
  const [pendingAudioSrc, setPendingAudioSrc] = useState<string | null>(null)  
  
  // 앱 플레이어 스토어 사용  
  const { isPlaying, currentTrack, currentPlayerType, playAudio, pauseAudio, resumeAudio, stopAudio } =  
    useAppPlayerStore()  
  
  const {  
    data: podcastsData,  
    fetchNextPage,  
    hasNextPage,  
    isFetchingNextPage,  
    isLoading: isPodcastsLoading,  
    isError,  
    error: podcastsError,  
    refetch,  
  } = useInfinitePodcasts({  
    type: scheduleFilter,  
    pageSize: 10,  
    enabled: true,  
  })  
  
  const {  
    data: podcastDetail,  
    isLoading: isDetailLoading,  
    isError: isDetailError,  
  } = useGetPodcastDetail({  
    id: selectedPodcastId || '',  
    enabled: !!selectedPodcastId,  
  })  
  
  const handleRefresh = useCallback(() => {  
    refetch()  
  }, [refetch])  
  
  const lastPodcastElementRef = useCallback(  
    (node: HTMLDivElement | null) => {  
      if (isPodcastsLoading) return  
      if (observerRef.current) observerRef.current.disconnect()  
  
      observerRef.current = new IntersectionObserver(entries => {  
        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {  
          fetchNextPage()  
        }  
      })  
  
      if (node) observerRef.current.observe(node)  
    },  
    [isPodcastsLoading, hasNextPage, isFetchingNextPage, fetchNextPage],  
  )  
  
  const handleTabChange = (value: string) => {  
    setActiveTab(value)  
    setScheduleFilter(value as PodcastRequestTypeEnum)  
  }  
  
  // eslint-disable-next-line react-hooks/exhaustive-deps  
  const getAudioSrc = (podcast: PodcastResponse): string | null => {  
    if (activeTab === 'speech-output' || !podcast.audioUrl) {  
      return null  
    }  
    return podcast.audioUrl  
  }  
  
  // 이미지 클릭 시 오디오 재생/일시정지 처리  
  const handleImageClick = useCallback(  
    async (podcast: PodcastResponse) => {  
      try {  
        const audioSrc = getAudioSrc(podcast)  
        if (!audioSrc) return  
  
        const audioInfo = {  
          url: audioSrc,  
          title: podcast.lmTitle,  
          artist: `팟캐스트 뉴스: ${podcast.newsType === 'DOMESTIC' ? '국내' : '글로벌'}`,  
          albumArt: podcast.thumbnailUrl || undefined,  
        }  
  
        const isSameTrack = currentTrack?.url === audioSrc  
  
        // 같은 트랙이면서 웹 플레이어인 경우 토글  
        if (isSameTrack && currentPlayerType === 'web') {  
          await (isPlaying ? pauseAudio() : resumeAudio())  
          return  
        }  
  
        // 다른 트랙이면서 웹 플레이어가 재생 중인 경우 정지  
        if (!isSameTrack && currentTrack && currentPlayerType === 'web') {  
          await stopAudio()  
        }  
  
        // 새로운 트랙 재생 또는 앱 플레이어에서 같은 트랙 재생  
        await playAudio(audioInfo)  
      } catch (error) {  
        console.error('오디오 재생 중 오류 발생:', error)  
      }  
    },  
    [currentTrack, currentPlayerType, isPlaying, playAudio, pauseAudio, resumeAudio, stopAudio, getAudioSrc],  
  )  
  
  const handlePodcastPlay = useCallback(  
    async (podcast: PodcastResponse, audioSrc: string | null) => {  
      try {  
        // 팟캐스트 상세 페이지로 이동할 때는 항상 오디오 정지  
        if (currentPlayerType === 'web') {  
          await stopAudio()  
        }  
  
        if (selectedPodcastId === podcast.id && isDetailLoading) {  
          return  
        }  
  
        setSelectedPodcastId(podcast.id)  
        setPendingAudioSrc(audioSrc)  
      } catch (error) {  
        console.error('팟캐스트 재생 중 오류 발생:', error)  
      }  
    },  
    [selectedPodcastId, isDetailLoading, stopAudio, currentPlayerType],  
  )  
  
  useEffect(() => {  
    if (podcastDetail && selectedPodcastId && !isDetailLoading && !isDetailError) {  
      onOpenPodcast(podcastDetail, pendingAudioSrc)  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [podcastDetail, selectedPodcastId, isDetailLoading, isDetailError, onOpenPodcast, pendingAudioSrc])  
  
  useEffect(() => {  
    if (isDetailError && selectedPodcastId) {  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [isDetailError, selectedPodcastId])  
  
  useEffect(() => {  
    if (activeTab === 'domestic') {  
      logScreenView('팟캐스트: 국내 뉴스 탭', '팟캐스트 탭')  
    } else if (activeTab === 'overseas-bitcoin') {  
      logScreenView('팟캐스트: 글로벌 & 코인 탭', '팟캐스트 탭')  
    } else if (activeTab === 'speech-output') {  
      logScreenView('팟캐스트: 실시간 발언 탭', '팟캐스트 탭')  
    }  
  }, [activeTab])  
  
  return (  
    <div className="mb-4">  
      <Tabs defaultValue="domestic" value={activeTab} onValueChange={handleTabChange}>  
        <TabsList className="grid w-full grid-cols-3 gap-1 min-[320px]:gap-2">  
          <TabsTrigger value="domestic" className="px-1 text-xs min-[320px]:px-3">  
            <span className="hidden min-[320px]:inline">국내 뉴스</span>  
            <span className="min-[320px]:hidden">국내</span>  
          </TabsTrigger>          <TabsTrigger value="overseas-bitcoin" className="px-1 text-xs min-[320px]:px-3">  
            <span className="hidden min-[360px]:inline">글로벌 & 코인 뉴스</span>  
            <span className="hidden min-[320px]:inline min-[360px]:hidden">글로벌&코인</span>  
            <span className="min-[320px]:hidden">글로벌</span>  
          </TabsTrigger>          <TabsTrigger value="speech-output" className="px-1 text-xs min-[320px]:px-3">  
            <span className="hidden min-[320px]:inline">실시간 발언</span>  
            <span className="min-[320px]:hidden">실시간</span>  
          </TabsTrigger>        </TabsList>  
        <TabsContent value="domestic" className="mt-4">  
          <PodcastList            podcastsData={podcastsData}  
            activeTab={activeTab}  
            hasNextPage={hasNextPage}  
            isFetchingNextPage={isFetchingNextPage}  
            isPodcastsLoading={isPodcastsLoading}  
            isError={isError}  
            podcastsError={podcastsError}  
            lastPodcastElementRef={lastPodcastElementRef}  
            onRefresh={handleRefresh}  
            onPodcastPlay={handlePodcastPlay}  
            onImageClick={handleImageClick}  
          />  
        </TabsContent>  
        <TabsContent value="overseas-bitcoin" className="mt-4">  
          <PodcastList            podcastsData={podcastsData}  
            activeTab={activeTab}  
            hasNextPage={hasNextPage}  
            isFetchingNextPage={isFetchingNextPage}  
            isPodcastsLoading={isPodcastsLoading}  
            isError={isError}  
            podcastsError={podcastsError}  
            lastPodcastElementRef={lastPodcastElementRef}  
            onRefresh={handleRefresh}  
            onPodcastPlay={handlePodcastPlay}  
            onImageClick={handleImageClick}  
          />  
        </TabsContent>  
        <TabsContent value="speech-output" className="mt-4">  
          <PodcastList            podcastsData={podcastsData}  
            activeTab={activeTab}  
            hasNextPage={hasNextPage}  
            isFetchingNextPage={isFetchingNextPage}  
            isPodcastsLoading={isPodcastsLoading}  
            isError={isError}  
            podcastsError={podcastsError}  
            lastPodcastElementRef={lastPodcastElementRef}  
            onRefresh={handleRefresh}  
            onPodcastPlay={handlePodcastPlay}  
            onImageClick={handleImageClick}  
          />  
        </TabsContent>      </Tabs>    </div>  )  
}
```

---

## 핵심 포인트

- **타입별 분기 처리**: 하나의 훅으로 여러 API 엔드포인트 대응
- **데이터 병합**: 페이지별 데이터를 하나의 배열로 통합
- **고유 키 관리**: React 렌더링 최적화를 위한 키 생성
- **캐싱 최적화**: 경로와 파라미터를 모두 고려한 queryKey 설계