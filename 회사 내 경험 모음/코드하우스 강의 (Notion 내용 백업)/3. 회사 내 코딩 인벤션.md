
#### 1. Coding Convention이란?

- 코딩 컨벤션(Coding Convention)은 코드 작성 시 지켜야 하는 규칙과 스타일 가이드를 의미한다
    - 이러한 규칙은 코드의 가독성을 높이고, 유지보수를 용이하게 하며, 팀 내 협업을 원활하게 하는 데 도움이 된다.


#### 2. 전체적인 Convention 템플릿 목록

- 현재, Next.js 프레임워크를 사용하는 프론트엔드 개발팀에서 준수하는 가장 외적인 Convention 템플릿 요소들은 아래와 같다.
- 
###### 📁 기본 Directory
- Next.js 프로젝트에서 회사 내 프론트엔드 개발 시, 전통적으로 추가해주어야 하는 Directory
    - `components`: 공통 컴포넌트 모음
    - `fonts`: 적용할 폰트 모음
    - `hooks`: 커스텀 hook 모음
    - `lib`: 라이브러리 관련 모음
    - `styles`: global style
    - `types`: Interface, type 정의 파일 모음
    - `utils`: 기타 추가 기능 파일 모음

###### ※ 프로덕션(실환경) 동작 및 배포 추가 필요 파일 (별도 생성 필요)
- `.env.development`: 개발 모드시`(npm run dev)` 적용되는 환경변수 파일
- `deploy-build.sh`, `Dockerfile`: 무중단 배포에 사용되는 파일
- `middleware.ts` 모든 요청에 대해 공통으로 적용하는 로직을 구현한 파일 (필요 시 사용)

###### ※ 통신 및 라우팅 용도 추가 필요 파일 (별도 생성 필요)
- `app` > `api` > `[…slug]` >`route.ts`
    - Next.js 내부의 1번째 **라우팅 파일**
    - 프론트엔드는 API 요청시 내부 라우팅을 거쳐 백엔드로 요청을 던진다.
    - 해당 파일은 GET, POST 요청에 대해 사용자의 jwt 토큰 값을 헤더에 담아 던지는 로직이 구현되어 있다.

- `app` > `api` > `auth` > `[…nextauth]` >`route.ts` , `AuthOptions.ts`
    - 로그인, 로그아웃 관리 라이브러리가 기본적으로 필요로 하는 파일이다.
    - 이 경로에 없으면 해당 라이브러리가 파일을 참조하지 못한다.

- `pages` > `api` > `file` > `[…slug].ts`
    - Next.js 내부의 2번째 **라우팅 파일**
    - POST에 `formData`를 포함하는 경우에 작동하는 내부 라우팅 파일

- `utils` > `serverSideFetch.ts`
    - **next-auth**를 사용하게 되면 RSC와 RCC에서 사용자 Session 정보를 가져오는 방식이 달라진다.
    - 또한 RSC에서는 내부 라우팅을 거칠때, Session 정보에 접근할 수 없어, 토큰 정보가 올바르게 담기지 않는 현상이 존재한다.
    - 따라서, 해당 함수는 서버사이드에서 API 요청 시 Session에 저장되어있는 token값을 올바르게 담아 요청 할 수 있도록 구현되어 있다.

###### ※ 기타 필요 파일 (별도 생성 필요)
- `components/*`: `components` Directory 내에서, 공통 컴포넌트로 사용할 것들을 추가한다.
    - `<Input/>`, `<Dialog/>`, `<Select/>` 등

- `styles` > `reset.css`
    - 웹 요소의 **스타일 초기화**를 담당하는 css 파일
        - css적인 요소에서 크로스 브라우징 이슈를 방지하기 위해 사용한다.

- `types` > `nextAuth` > `next-auth.d.ts`
    - next-auth 라이브러리에서 기본 제공하는 User의 Interface을 커스텀하기 위해 사용되는 고정 파일이다.
    - 프로젝트 별로 User에 들어가야하는 정보가 다르며, next-auth 라이브러리를 사용하고 있다면 이 파일을 변경해야 한다.

- `types` > `common`> `commonType.ts`
    - 프론트 자체 로직이나, 백엔드 통신 로직 중 발생하는 데이터의 Type, Interface가 공통적으로 정의되는 파일이다.
    - 해당 파일에서 정의된 Type, Interface를 따르는 데이터는 `components/common`` 디렉터리 하위의 공통 컴포넌트로 전달된다.
        - 따라서, 변동 가능성이 없거나 적은 Type, Interface가 이곳에 정의된다.

- `utils` > `utils.ts`
    - 프로젝트를 진행하는데에 있어서 필요한 **유틸적인** 함수 모음 파일

- `provider` > `RecoilProvider.tsx`, `NextAuthProvider.tsx`, `ReactQueryProvider.tsx`
    - 매 프로젝트마다 공통적으로 사용하는 라이브러리가 Provider 파일
    - 애플리케이션 전체에서, 각 라이브러리의 기능을 사욯할 수 있도록 라이브러리 별 인스턴스를 만드는 데에 사용된다.


#### 3. 미공통화 컴포넌트 Convention

- 모든 페이지가 공통 컴포넌트만 사용하고 간단한 규칙만을 정의하여 구성된다면 좋겠지만, 실질적으로는 그렇지 않다.
    - 특정 페이지에만 필요한 컴포넌트가 있다면 어떻게 할까?
###### ※ 특정 페이지에만 필요한 컴포넌트
- 만약, `/app/ip/pass` 경로에서만 사용하는 컴포넌트가 있다고 하자.
    - 한 파일 안에서 정의하고 사용하기에는 너무 길어서 별도 파일로 빼고 싶은 상황이라 가정하자.
        ![[특정 페이지만 필요한 컴포넌트(1).png]]

- 이러한 경우, 회사 내에서는 2가지 방법으로 컴포넌트를 추가한다.
    1. `app` directory 하위 해당 경로(`/ip/pass`) 위치에 `component` 파일을 만들고, 그 안에 컴포넌트를 추가한다.
        ![[특정 페이지만 필요한 컴포넌트(2).png]]
        
    2. `components` directory 하위에 `app` directory를 시작으로, 동일 경로 directory를 만들어 사용한다.
        - 이 때, 모든 페이지에서 공통으로 사용하는 요소가 아니기 때문에, `components/common` 하위에는 생성하지 않아야 한다.
        ![[특정 페이지만 필요한 컴포넌트(3).png]]

- 이러한 방식은 비단 `components` directory에만 해당하는 것이 아니라, `utils`(유틸리티 함수), `types`(Type, Inferface) 등에도 적용하면 된다.


#### 4. CSS Convention

###### ※ CSS Pre-processor 사용
- 회사 내 프론트엔드 프로젝트에서는 기본적으로 SCSS 파일을 사용한다.
    - **SCSS**의 개념은 간단히 말해 CSS 전처리기(소스 코드의 원시 형태를 다른 형식으로 변환하는 도구)에서 사용하는 문법 중 하나이다.
    - 이해하기 쉽게 말하면, SCSS를 사용하면 CSS의 단점을 보완해 더 빠르고, 효율적으로 스타일을 작성할 수 있도록 하는 별도의 문법이라고 말할 수 있다.

###### ※ 클래스의 고유성 여부에 따른 css 파일 분리
- 그리고, 클래스명의 고유성 유무에 따라 Module 방식을 사용한다.
    - 클래스 이름이 겹치며, 겹친 클래스명을 사용하는 element에는 특정 css가 공통으로 적용되어야 하는 상황 : 일반 scss 파일 (ex: `global.scss`)
    - 특정 페이지에서만 적용되는 css이며, 다른 페이지에서 동일한 이름을 사용한 클래스명이 있어도, css 내용이 공유되면 안되는 상황 : module scss 파일 (ex: `page.module.scss`)

- 보통은 특정 UI 라이브러리가 module scss를 지원하지 않으며, element의 id, class명이 고착화된 경우라면, 일반 `.scss` 파일을 사용하며, 그 외에는 의도치 않은 상황을 방지하기 위해 `.module.scss` 파일을 사용한다.

###### ※ 클래스명 생성
- module.scss 파일이든, 일반 .scss 파일이든 클래스명은 언더스코어(`_`)를 포함한 이름으로 지으면 된다.
    - module.scss 방식을 사용하는 경우, 하이픈(`-`)을 포함하여 클래스명을 지으면 **에러가 발생**한다.

- 그리고, 클래스명은 해당 element의 성격이나 위치를 한 눈에 보고 알 수 있게끔 주석과 함께 명명하는 것이 **권장**된다.
    - 아래 코드는 언더스코어(`_`)를 사용하여 클래스명을 만든 예시이자, 주석과 함께 해당 element가 뭐하는 영역인지를 기술한 예시이다.

```html
<div
	className={`${styles.dtd_section_box} ${isDetailSectionOpen ? styles.open : styles.close}`}
>
	{/* TOP : 제목 영역 */}
	<div className={styles.dtd_section_top}>
	</div>

	{/* MIDDLE : 테이블 영역*/}
	{selectMapDepth3SubMenuState && (
	  <div className={styles.dtd_section_middle}>
	    {/* MIDDLE-TOP */}
	    <div className={styles.dtd_section_middle_top}>
	    </div>
	
	    {/* MIDDLE-CENTER */}
	    <div className={styles.dtd_section_middle_center}>
	    </div>
	
	    {/* MIDDLE-BOTTOM */}
	    <div className={styles.dtd_section_middle_bottom}></div>
	  </div>
	)}

	{/* BOTTOM : 차트 영역*/}
	<div className={styles.dtd_section_bottom}></div>
</div>
```