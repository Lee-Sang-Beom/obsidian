## 📖 개요

### 🎯 무엇인가요?

`useInfiniteSignals`는 **무한 스크롤**과 **스마트 자동 새로고침** 기능을 제공하는 React 커스텀 훅입니다.

### ✨ 주요 기능

- **무한 스크롤**: 스크롤하면 자동으로 새 데이터 로드
- **스마트 자동 새로고침**: 한국 주식 장 시간에만 자동 업데이트
- **멀티 API 지원**: 일반 시그널과 상승률 시그널 동시 지원
- **라우팅 연동**: 페이지 이동 시 캐시 분리로 성능 최적화
- **멤버십 연동**: 사용자 권한에 따른 데이터 차별화
- **완전한 상태 관리**: 로딩, 에러, 빈 데이터 상태 처리

### 🌟 언제 사용하나요?

- 소셜 미디어 피드
- 주식 신호 목록
- 뉴스 목록 (시간순/수익률순)
- 상품 목록
- 무한 스크롤이 필요한 모든 곳

---

## 🏗️ 코드 구조

### 📝 인터페이스 정의

#### 입력 옵션

```typescript
interface UseInfiniteSignalsOptions {
  type?: SignalTypeRequestEnum         // 📊 신호 타입 필터 ('all', 'buy', 'sell' 등)
  seType?: SignalSortTypeEnum          // 📈 정렬 타입 ('LATEST', 'TERM_PROFIT' 등)
  pageSize?: number                    // 📄 페이지당 아이템 수
  enabled?: boolean                    // 🔘 쿼리 활성화 여부
  membershipType?: MembershipType      // 👤 사용자 멤버십 타입
}
```

#### 반환값

```typescript
interface UseInfiniteSignalsResult {
  data: (SignalListResponse | SignalFavoriteListResponse)[] | undefined  // 📋 실제 데이터 배열
  fetchNextPage: () => void            // ▶️ 다음 페이지 로드 함수
  hasNextPage: boolean                 // ❓ 다음 페이지 존재 여부
  isFetchingNextPage: boolean          // ⏳ 다음 페이지 로딩 중
  isLoading: boolean                   // 🔄 첫 로딩 중
  isError: boolean                     // ❌ 에러 발생 여부
  error: Error | null                  // 🚨 에러 상세 정보
  refetch: () => void                  // 🔁 수동 새로고침 함수
}
```

---

## 🧠 핵심 개념

### 🏢 한국 주식 장 시간 기반 자동 새로고침

#### 스마트 새로고침 로직

```typescript
const isMarketOpen = isKoreanMarketOpen()  // 📊 현재 한국 장 오픈 여부

// 장 시간에만 자동 새로고침 활성화
refetchInterval: isMarketOpen ? UPDATE_MS_TIME : false,
refetchIntervalInBackground: isMarketOpen
```

#### 장 시간 vs 장 마감 동작

|상황|자동 새로고침|백그라운드 새로고침|동작 이유|
|---|:-:|:-:|---|
|**장 시간** (09:00-15:00)|✅ 활성|✅ 활성|실시간 데이터 필요|
|**장 마감** (나머지 시간)|❌ 비활성|❌ 비활성|불필요한 API 호출 방지|

### 🔄 멀티 API 시스템

#### API 선택 로직

```typescript
const isTermProfit = seType === 'TERM_PROFIT'

if (isTermProfit) {
  // 📈 상승률 중심 시그널 API
  return await signalService.getProfitSignals({
    type, seType, nowPage: pageParam, pageSize
  })
} else {
  // 📋 일반 시그널 API  
  return await signalService.getSignals({
    type, seType, nowPage: pageParam, pageSize
  })
}
```

#### 두 API의 차이점

|구분|일반 시그널 API|상승률 시그널 API|
|---|---|---|
|**주 정렬 기준**|시간순 (LATEST)|수익률순 (TERM_PROFIT)|
|**데이터 포함**|기본 신호 정보|수익률 정보 추가|
|**사용 케이스**|최신 신호 확인|수익성 높은 신호 확인|

---

## ⚙️ 옵션 설정

### 🔧 기본 설정값

```typescript
const defaultOptions = {
  type: 'all',                         // 🌍 모든 신호 타입
  seType: 'LATEST',                    // ⏰ 최신순 정렬
  pageSize: 10,                        // 📄 한 페이지에 10개
  enabled: true,                       // ✅ 즉시 데이터 요청 시작
  membershipType: undefined            // 👤 멤버십 타입 (선택적)
}
```

### 🎛️ React Query 내부 옵션들

#### 1️⃣ queryKey - 캐시 식별자

```typescript
queryKey: ['useInfiniteSignals', type, seType, pageSize, location.pathname, membershipType, isTermProfit]
```

- **역할**: 캐시의 고유 식별자로 7개 요소 조합
- **동작**: 키 중 하나라도 변경되면 새로운 쿼리로 인식
- **예시**:
    - `seType`이 'LATEST' → 'TERM_PROFIT' 변경 시 새 API 호출
    - `location.pathname` 변경 시 페이지별 캐시 분리
    - `membershipType` 변경 시 권한별 데이터 분리

#### 2️⃣ queryFn - 멀티 API 호출 함수

```typescript
queryFn: async ({ pageParam = 1 }) => {
  if (isTermProfit) {
    // 🏆 상승률 시그널 전용 API
    return await signalService.getProfitSignals({
      type, seType, nowPage: pageParam, pageSize
    })
  } else {
    // 📊 일반 시그널 API
    return await signalService.getSignals({
      type, seType, nowPage: pageParam, pageSize
    })
  }
}
```

#### 3️⃣ getNextPageParam - 다음 페이지 결정

```typescript
getNextPageParam: (lastPage, allPages) => {
  const currentPage = allPages.length           // 📊 현재까지 로드된 페이지 수
  const totalPages = lastPage.lastPage          // 📈 서버에서 제공하는 전체 페이지 수
  
  // 🎯 다음 페이지가 있으면 페이지 번호, 없으면 undefined
  return currentPage < totalPages ? currentPage + 1 : undefined
}
```

**이전 버전과의 차이점**: 전체 페이지 계산을 서버 응답(`lastPage.lastPage`)에 의존하여 더 정확함

#### 4️⃣ 스마트 자동 새로고침 옵션

```typescript
refetchInterval: isMarketOpen ? UPDATE_MS_TIME : false,          // 📊 장 시간에만 새로고침
refetchIntervalInBackground: isMarketOpen,                       // 📱 백그라운드에서도 장 시간에만
```

|옵션|장 시간|장 마감 후|
|---|---|---|
|`refetchInterval`|`UPDATE_MS_TIME`|`false`|
|`refetchIntervalInBackground`|`true`|`false`|

---

## 📤 반환값

### 📋 데이터 관련

- **`data`**: 모든 페이지 데이터를 하나의 배열로 합친 결과
- **`flattenedData`**: 고유 키가 추가된 최종 렌더링용 데이터

### ▶️ 페이지네이션 관련

- **`fetchNextPage()`**: 다음 페이지 데이터 요청 함수
- **`hasNextPage`**: 다음 페이지 존재 여부 (boolean)
- **`isFetchingNextPage`**: 다음 페이지 로딩 중 여부 (boolean)

### 🔄 상태 관리

- **`isLoading`**: 첫 번째 페이지 로딩 중 여부
- **`isError`**: 에러 발생 여부
- **`error`**: 에러 객체 (상세 정보 포함)
- **`refetch()`**: 수동 새로고침 함수

---

## 💻 실제 사용법

### 🎯 기본 사용법 (전체)

```typescript
import { type Dispatch, type SetStateAction, useCallback, useEffect, useState } from 'react'  
import type {  
  SignalFavoriteListResponse,  
  SignalListResponse,  
  SignalSortTypeEnum,  
  SignalTypeRequestEnum,  
} from '@/pages/signal/types'  
import { useInfiniteSignals } from '@/pages/signal/hooks/action/use-infinite-signals.ts'  
import { MobileLoadingState } from '@/components/loading/loading.tsx'  
import { InfiniteScrollLoading } from '@/components/loading/infinite-scroll-loading.tsx'  
import { InfiniteScrollComplete } from '@/components/loading/infinite-scroll-complete.tsx'  
import { useInfiniteScroll } from '@/hooks/use-infinite-scroll.ts'  
import SignalCard from '@/pages/signal/_components/normal-signal/signal-card.tsx'  
import SubSearchFilter from '@/pages/signal/_components/signal-part/sub-search-filter.tsx'  
import SignalProfitCard from '@/pages/signal/_components/normal-signal/signal-profit-card.tsx'  
import type { MembershipType } from '@/pages/auth/types'  
import UpgradeMembershipButton from '@/pages/signal/_components/upgrade-membership-button.tsx'  
import { useOpenMembershipDialog } from '@/pages/my-page/hooks/modal/use-open-membership-dialog.ts'  
import { isAvailableDisplaySignalInfo } from '@/pages/signal/utils.ts'  
import { logScreenView } from '@/log/use-analytics.ts'  
  
interface SignalListProps {  
  signalType: SignalTypeRequestEnum  
  expandedCards: string[]  
  setExpandedCards: Dispatch<SetStateAction<string[]>>  
  onToggleChart: (id: string) => void  
  isActive: boolean  
  membershipType: MembershipType  
}  
  
// 타입 가드 함수  
function isSignalFavoriteListResponse(signal: any): signal is SignalFavoriteListResponse {  
  return signal && signal.signalGroup !== undefined  
}  
  
export default function SignalList({  
  signalType,  
  expandedCards,  
  setExpandedCards,  
  onToggleChart,  
  isActive,  
  membershipType,  
}: SignalListProps) {  
  const { onOpen } = useOpenMembershipDialog()  
  
  // 프리미엄 회원 기본값: 최신순  
  // 베이직 회원 기본값: 최신순  
  // 무료 회원 기본값: 최신순  
  const [seType, setSeType] = useState<SignalSortTypeEnum>('LATEST')  
  const isFreeUser = membershipType === 'FREE'  
  
  // 프리미엄 회원: 사용자 선택에 따라 유동적 조건 변경  
  // 베이직 회원: 항상 최신순. 국내는 단기데이터만 보여야하지만, display에서 스키마처리할거라 그냥 seType으로 조회  
  // 무료회원: 항상 최신순으로 단기 종목만 3개 출력 (국내라고 제한두지 않았으니 전체기준으로)  
  const {  
    data: signals,  
    fetchNextPage,  
    hasNextPage,  
    isFetchingNextPage,  
    isLoading,  
    isError,  
    error,  
    refetch,  
  } = useInfiniteSignals({  
    type: signalType,  
    seType: isFreeUser ? 'SHORT_TERM' : seType,  
    pageSize: isFreeUser ? 3 : 10,  
    enabled: isActive,  
    membershipType,  
  })  
  
  // FREE 유저가 아닌 경우에만 무한 스크롤 적용  
  const { loadMoreRef } = useInfiniteScroll({  
    hasNextPage: !isFreeUser && hasNextPage,  
    isFetchingNextPage,  
    fetchNextPage,  
  })  
  
  // Pull-to-refresh 핸들러 및 데이터 새로 불러오기  
  const handleRefresh = useCallback(() => {  
    refetch()  
    setExpandedCards([])  
  }, [refetch, setExpandedCards])  
  
  // seType 변경 핸들러  
  const handleSeTypeChange = useCallback(  
    (newSeType: SignalSortTypeEnum) => {  
      if (membershipType === 'PREMIUM') {  
        // 프리미엄이면 검색조건 변경  
        setSeType(newSeType)  
      } else {  
        // 프리미엄이 아니면 멤버십 가입  
        onOpen()  
      }  
  
      setExpandedCards([])  
    },  
    [membershipType, setExpandedCards, onOpen],  
  )  
  
  useEffect(() => {  
    if (!isActive) return  
    const currentSignalType: SignalTypeRequestEnum = signalType  
    const currentSeType: SignalSortTypeEnum = seType  
  
    const getScreenName = (  
      signalType: SignalTypeRequestEnum,  
      seType: SignalSortTypeEnum,  
    ): {  
      screenName: string  
      screenClass: string  
    } => {  
      const signalTypeMap = {  
        all: '전체',  
        stock: '국내주식',  
        foreign_crypto: '해외/코인',  
      } as const  
  
      const seTypeMap = {  
        LATEST: '최신발굴',  
        TERM_PROFIT: '상승률 상위',  
        SHORT_TERM: '단기 투자',  
        MEDIUM_LONG_TERM: '중장기 투자',  
      } as const  
  
      return {  
        screenName: `AI 시그널 탭: ${signalTypeMap[signalType]} - ${seTypeMap[seType]}`,  
        screenClass: `AI 시그널 탭`,  
      }  
    }  
  
    const { screenName, screenClass } = getScreenName(currentSignalType, currentSeType)  
    logScreenView(screenName, screenClass)  
  }, [isActive, signalType, seType])  
  // 초기 로딩 상태  
  if (isLoading) {  
    return (  
      <div className="space-y-4">  
        <MobileLoadingState          state="loading"  
          title="시그널 불러오는 중..."  
          description="최신 시그널 데이터를 가져오고 있습니다."  
          size="md"  
          showAnimation={true}  
        />  
      </div>    )  
  }  
  
  // 에러 상태  
  if (isError) {  
    const isNetworkError =  
      error?.message?.toLowerCase().includes('network') || error?.message?.toLowerCase().includes('fetch')  
  
    if (!isNetworkError) {  
      return (  
        <MobileLoadingState  
          state="error"  
          title="데이터 로딩 실패"  
          description="시그널 데이터를 불러오는 중 문제가 발생했습니다."  
          error={error}  
          onRetry={handleRefresh}  
          onRefresh={() => window.location.reload()}  
        />  
      )  
    }  
  }  
  
  // 데이터가 없는 경우  
  if (!signals || signals.length === 0) {  
    return (  
      <MobileLoadingState  
        state="empty"  
        title="시그널이 없습니다"  
        description="표시할 시그널 정보가 없습니다."  
        onRefresh={handleRefresh}  
        size="md"  
      />  
    )  
  }  
  
  // FREE 유저의 경우 1개만 표시하고 나머지는 제한  
  const displayedSignals = isFreeUser ? signals.slice(0, 3) : signals  
  
  return (  
    <div className="relative">  
      <SubSearchFilter seType={seType} onSeTypeChange={handleSeTypeChange} membershipType={membershipType} />  
  
      {/* FREE 유저를 위한 멤버십 업그레이드 버튼 */}  
      {isFreeUser && <UpgradeMembershipButton />}  
  
      {/* 시그널 카드 목록 */}  
      <div className="mt-2 space-y-3">  
        {displayedSignals.map(signal => {  
          const id = `signal_${signal.code}_${signal.codeName}_${signal._uniqueKey}`  
  
          // seType이 TERM_PROFIT인 경우 상승률 카드 컴포넌트 사용  
          if (seType === 'TERM_PROFIT' && isSignalFavoriteListResponse(signal)) {  
            return (  
              <SignalProfitCard  
                id={id}  
                key={id}  
                signal={signal}  
                onToggleChart={() => {  
                  onToggleChart(id)  
                }}  
                membershipType={membershipType}  
              />  
            )  
          }  
  
          // 현재 시그널 정보가 현재 멤버십 타입에서 display 가능한 정보인지 확인  
          const isAvailableSignalInfoDisplay = isAvailableDisplaySignalInfo(  
            membershipType,  
            signal as SignalListResponse,  
            signalType,  
          )  
  
          // 그 외의 경우 일반 시그널 카드 컴포넌트 사용  
          return (  
            <SignalCard  
              id={id}  
              key={id}  
              signal={signal as SignalListResponse}  
              isExpanded={expandedCards.includes(id)}  
              onToggleChart={() => {  
                if (isAvailableSignalInfoDisplay) {  
                  onToggleChart(id)  
                } else {  
                  onOpen()  
                }  
              }}  
              isAvailableSignalInfoDisplay={isAvailableSignalInfoDisplay}  
              membershipType={membershipType}  
            />  
          )  
        })}  
  
        {/* PREMIUM/BASIC 유저를 위한 무한 스크롤 영역 */}  
        {!isFreeUser && hasNextPage && (  
          <div ref={loadMoreRef} className="py-8">  
            <InfiniteScrollLoading isFetchingNextPage={isFetchingNextPage} loadedCount={signals.length} />  
          </div>        )}  
  
        {/* PREMIUM/BASIC 유저: 모든 데이터를 불러온 경우 */}  
        {!isFreeUser && !hasNextPage && signals.length > 0 && (  
          <InfiniteScrollComplete totalCount={signals.length} dataName={'시그널'} />  
        )}  
      </div>  
    </div>  )  
}
```

### 🎛️ 다양한 사용 방법

#### 1️⃣ 상승률 시그널 조회

```typescript
const { data } = useInfiniteSignals({
  type: 'buy',
  seType: 'TERM_PROFIT',  // 🏆 수익률 높은 순서로 정렬
  pageSize: 20
})
```

#### 2️⃣ 멤버십별 차별화

```typescript
const { data } = useInfiniteSignals({
  type: 'all',
  seType: 'LATEST',
  membershipType: 'PREMIUM',  // 👑 프리미엄 사용자 전용 데이터
  pageSize: 50
})
```

#### 3️⃣ 조건부 쿼리 실행

```typescript
const [isActive, setIsActive] = useState(false)

const { data } = useInfiniteSignals({
  type: 'sell',
  seType: 'LATEST',
  enabled: isActive  // 🔘 활성화 상태일 때만 실행
})
```

#### 4️⃣ 완전한 무한 스크롤 구현 (`위 기본 사용법 예제코드에서, use-infinite-scroll.ts`)

```typescript
import { useEffect, useRef } from 'react'  
  
interface UseInfiniteScrollProps {  
  hasNextPage: boolean  
  isFetchingNextPage: boolean  
  fetchNextPage: () => void  
  threshold?: number  
  rootMargin?: string  
}  
  
export function useInfiniteScroll({  
                                    hasNextPage,  
                                    isFetchingNextPage,  
                                    fetchNextPage,  
                                    threshold = 0.1,  
                                    rootMargin = '100px'  
                                  }: UseInfiniteScrollProps) {  
  const loadMoreRef = useRef<HTMLDivElement>(null)  
  
  useEffect(() => {  
    const observer = new IntersectionObserver(  
      (entries) => {  
        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {  
          fetchNextPage()  
        }  
      },  
      {  
        threshold,  
        rootMargin  
      }  
    )  
  
    if (loadMoreRef.current) {  
      observer.observe(loadMoreRef.current)  
    }  
  
    return () => observer.disconnect()  
  }, [hasNextPage, isFetchingNextPage, fetchNextPage, threshold, rootMargin])  
  
  return { loadMoreRef }  
}
```

---

## 🔧 동작 원리

### 📖 1단계: 초기 설정 및 API 결정

```
🚀 useInfiniteSignals 호출
    ↓
🧮 seType === 'TERM_PROFIT' 체크
    ↓
📊 isMarketOpen() 호출로 장 시간 확인
    ↓
🎯 queryKey 생성 (7개 요소 조합)
    ↓
📡 적절한 API 선택 및 호출
```

### ▶️ 2단계: 멀티 API 호출 로직

```
📋 queryFn 실행
    ↓
🤔 isTermProfit 조건 분기
    ↓
📈 TERM_PROFIT → signalService.getProfitSignals()
📊 기타 → signalService.getSignals()
    ↓
💾 응답 데이터 캐싱
```

### 🔄 3단계: 스마트 자동 새로고침

```
⏰ refetchInterval 체크
    ↓
🏢 isMarketOpen === true?
    ✅ 장 시간 → UPDATE_MS_TIME마다 새로고침
    ❌ 장 마감 → 새로고침 비활성화
    ↓
📱 백그라운드 새로고침도 동일 조건 적용
```

### 🏗️ 4단계: 고유 키 생성 시스템

```typescript
// 📊 각 아이템에 고유 키 추가
return signalData.pages.flatMap((page, pageIndex) =>
  page.items.map((item, itemIndex) => ({
    ...item,
    // 🔑 페이지 인덱스 + 아이템 인덱스 조합
    _uniqueKey: `${pageIndex}-${itemIndex}`,
  }))
)
```

**중복 키 문제 해결**: 페이지와 아이템 인덱스를 조합하여 React key 에러 방지

### 👀 5단계: 캐시 분리 전략

```
📄 location.pathname 변경
    ↓
🗂️ 새로운 queryKey 생성
    ↓
💾 페이지별 독립적인 캐시 유지
    ↓
⚡ 빠른 페이지 전환 경험
```

---

## 🎯 고급 기능

### 🏢 한국 주식 시장 최적화

#### 장 시간 감지 로직

```typescript
import { isKoreanMarketOpen } from '@/lib/utils.ts'

const isMarketOpen = isKoreanMarketOpen()
// 평일 09:00-15:00 한국 시간 기준으로 true/false 반환
```

#### 에너지 효율적 동작

- **장 시간**: 실시간 업데이트로 최신 데이터 보장
- **장 마감**: 불필요한 API 호출 중단으로 서버 리소스 절약

### 🎛️ 멀티 API 아키텍처

#### 확장 가능한 구조

```typescript
// 🔮 미래 API 추가 시 확장 방법
if (seType === 'TERM_PROFIT') {
  return await signalService.getProfitSignals(params)
} else if (seType === 'VOLUME_HIGH') {
  return await signalService.getVolumeSignals(params)  // 📈 거래량 기반
} else if (seType === 'AI_RECOMMENDED') {
  return await signalService.getAiSignals(params)      // 🤖 AI 추천
} else {
  return await signalService.getSignals(params)        // 📊 기본
}
```

### 🗂️ 라우팅 기반 캐시 분리

#### 페이지별 독립적 캐시

```typescript
// 📍 /signals/buy 페이지
queryKey: ['useInfiniteSignals', 'buy', 'LATEST', 10, '/signals/buy', ...]

// 📍 /signals/sell 페이지  
queryKey: ['useInfiniteSignals', 'sell', 'LATEST', 10, '/signals/sell', ...]
```

**장점**: 페이지 간 이동 시 각각의 스크롤 위치와 로드된 데이터 유지

### 🔑 고유 키 시스템 개선

#### 이전 버전의 문제점

```typescript
// ❌ ID 기반 중복 제거 (복잡하고 성능 부담)
return allItems.filter((item, index, self) =>
  index === self.findIndex(t => t.id === item.id)
)
```

#### 현재 버전의 해결책

```typescript
// ✅ 페이지-아이템 인덱스 조합 (간단하고 효율적)
_uniqueKey: `${pageIndex}-${itemIndex}`
```

**개선점**:

- 중복 제거 연산 불필요
- 더 빠른 렌더링 성능
- 페이지 구조 유지하면서 고유성 보장

---

## 🚀 성능 최적화

### 📊 메모리 효율성

- **useMemo**: 페이지 데이터 변경 시에만 flattenedData 재계산
- **스마트 새로고침**: 장 마감 후 불필요한 API 호출 방지

### ⚡ 사용자 경험 향상

- **즉시 응답**: 캐시된 데이터로 빠른 초기 렌더링
- **부드러운 스크롤**: Intersection Observer 기반 자동 로드
- **로딩 상태**: 각 단계별 세분화된 로딩 인디케이터

### 🏗️ 확장성

- **모듈화**: 새로운 정렬 타입이나 API 쉽게 추가 가능
- **타입 안정성**: TypeScript로 런타임 에러 방지
- **재사용성**: 다양한 컴포넌트에서 동일 로직 활용