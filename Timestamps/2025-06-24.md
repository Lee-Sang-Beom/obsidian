
#### Day Planner
---
- [ ] 하루 1회 프론트엔드 지식 및 Next.js 관련 기술 정리하기


#### Work
---
- [ ] 팟캐스트 마무리 필요

```plaintext
``` import type { PodcastData, PodcastTypeEnum } from "../types" import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs.tsx" import PodcastListItem from "./podcast-list-item" import { domesticPodcasts, globalPodcasts, livePodcasts } from "../data" import { useState } from "react" interface NewsBottomSectionProps { onOpenPodcast: (podcast: PodcastData, audioSrc: string | null) => void } export default function NewsBottomSection({ onOpenPodcast }: NewsBottomSectionProps) { const [scheduleFilter, setScheduleFilter] = useState("domestic") return (

setScheduleFilter(value as PodcastTypeEnum)} > 국내 뉴스 글로벌 & 코인 뉴스 실시간 뉴스

{domesticPodcasts.map((podcast) => ( onOpenPodcast(podcast, null)} /> ))}

{globalPodcasts.map((podcast) => ( onOpenPodcast(podcast, null)} /> ))}

{livePodcasts.map((podcast) => ( onOpenPodcast(podcast, null)} /> ))}

) } ``` ``` export type PodcastTypeEnum = 'domestic' | 'overseas-bitcoin' | 'speech-output'; ``` 이 코드에서 scheduleFilter가 변경될때마다 아래 훅이 호출되어야해 1. domestic, overseea-bitcoin일 때는 useInfinitePodcasts 2. speech-output일 때는 useSpeechOutputInfinitePodcasts ``` import {useLocation} from "react-router-dom" import type {PodcastLiveFeedResponse, PodcastTypeEnum} from "../../types" import {useInfiniteQuery} from "@tanstack/react-query"; import {podcastService} from "@/service/podcast-service.ts"; import type {PagingResult} from "@/lib/types"; import {useMemo} from "react"; import {UPDATE_MS_TIME} from "@/data/constants.ts"; interface UseInfinitePodcastsOptions { type?: PodcastTypeEnum pageSize?: number enabled?: boolean } interface UseInfinitePodcastsResult { data: PodcastLiveFeedResponse[] | undefined fetchNextPage: () => void hasNextPage: boolean isFetchingNextPage: boolean isLoading: boolean isError: boolean error: Error | null refetch: () => void } /** * 무한 스크롤 팟캐스트 목록을 관리하는 훅 */ export const useSpeechOutputInfinitePodcasts = ({ type = 'speech-output', pageSize = 10, enabled = true }: UseInfinitePodcastsOptions = {}): UseInfinitePodcastsResult => { const location = useLocation() const { data: podcastData, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error, refetch } = useInfiniteQuery({ queryKey: ['useSpeechOutputInfinitePodcasts', type, pageSize, location.pathname], queryFn: async ({ pageParam = 1 }) => { const podcastResponse = await podcastService.getLiveSpeechOutputPodcasts({ type: type as PodcastTypeEnum, nowPage: pageParam, pageSize }) return podcastResponse }, getNextPageParam: (lastPage: PagingResult, allPages) => { const currentPage = allPages.length const totalPages = lastPage.lastPage return currentPage < totalPages ? currentPage + 1 : undefined }, initialPageParam: 1, enabled, retry: 1, refetchIntervalInBackground: true, refetchOnWindowFocus: true, refetchOnReconnect: true, gcTime: UPDATE_MS_TIME // UPDATE_MS_TIME 시간동안 캐시 유지 }) /** * 모든 페이지 데이터를 하나의 배열로 병합 * 각 아이템에 고유한 인덱스를 추가하여 React key 중복 문제 해결 */ const flattenedData = useMemo(() => { if (!podcastData?.pages) return [] return podcastData.pages.flatMap((page, pageIndex) => page.items.map((item, itemIndex) => ({ ...item, // 고유한 키를 위해 페이지 인덱스와 아이템 인덱스 조합 _uniqueKey: `${pageIndex}-${itemIndex}-${item.title}`, })) ) }, [podcastData?.pages]) return { data: flattenedData, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error, refetch } } ``` ``` import {useLocation} from "react-router-dom" import type { PodcastResponse, PodcastTypeEnum} from "../../types" import {useInfiniteQuery} from "@tanstack/react-query"; import {podcastService} from "@/service/podcast-service.ts"; import type {PagingResult} from "@/lib/types"; import {useMemo} from "react"; import {UPDATE_MS_TIME} from "@/data/constants.ts"; interface UseInfinitePodcastsOptions { type?: PodcastTypeEnum pageSize?: number enabled?: boolean } interface UseInfinitePodcastsResult { data: PodcastResponse[] | undefined fetchNextPage: () => void hasNextPage: boolean isFetchingNextPage: boolean isLoading: boolean isError: boolean error: Error | null refetch: () => void } /** * 무한 스크롤 팟캐스트 목록을 관리하는 훅 */ export const useInfinitePodcasts = ({ type = 'domestic', pageSize = 10, enabled = true }: UseInfinitePodcastsOptions = {}): UseInfinitePodcastsResult => { const location = useLocation() const { data: podcastData, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error, refetch } = useInfiniteQuery({ queryKey: ['useInfinitePodcasts', type, pageSize, location.pathname], queryFn: async ({ pageParam = 1 }) => { const podcastResponse = await podcastService.getPodcasts({ type: type as PodcastTypeEnum, nowPage: pageParam, pageSize }) return podcastResponse }, getNextPageParam: (lastPage: PagingResult, allPages) => { const currentPage = allPages.length const totalPages = lastPage.lastPage return currentPage < totalPages ? currentPage + 1 : undefined }, initialPageParam: 1, enabled, retry: 1, refetchIntervalInBackground: true, refetchOnWindowFocus: true, refetchOnReconnect: true, gcTime: UPDATE_MS_TIME // UPDATE_MS_TIME 시간동안 캐시 유지 }) /** * 모든 페이지 데이터를 하나의 배열로 병합 * 각 아이템에 고유한 인덱스를 추가하여 React key 중복 문제 해결 */ const flattenedData = useMemo(() => { if (!podcastData?.pages) return [] return podcastData.pages.flatMap((page, pageIndex) => page.items.map((item, itemIndex) => ({ ...item, // 고유한 키를 위해 페이지 인덱스와 아이템 인덱스 조합 _uniqueKey: `${pageIndex}-${itemIndex}-${item.lmTitle}-${item.lmContent}`, })) ) }, [podcastData?.pages]) return { data: flattenedData, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error, refetch } } ```

```
