
#### Work
---
- [x] AI 시그널 Card 영역 코드분리 및 리팩토링
- [x] 팟캐스트 2일기준 localstorage 삭제로직 구현
- [x] ai 시그널 / 관심 시그널 파트 컴포넌트 통일화
- [x] AI 시그널 멤버십 만료 에러에 따른 ai signal 관리 state 변경로직 확인/테스트
- [x] app-first 만료된 시크릿 키에 대한 clearAuth 적용
- [x] 서비스 이용 중 토큰 만료에 대한 redirect 처리 확인 필요
- [ ] 팟캐스트 팝업 다이얼로그 닫을 때 앱 플레이어 재생정지되는문제해결
- [ ] 팟캐스트 페이지 bottom 영역 코드 리팩토링
 - [ ] 구글 애널리틱스 작업 진행

> news-bottom-section.tsx 백업
```tsx
import type { DetailPodcastResponse, PodcastLiveFeedResponse, PodcastResponse, PodcastTypeEnum } from '../../types'  
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs.tsx'  
import PodcastListItem from './podcast-list-item.tsx'  
import { useCallback, useEffect, useRef, useState } from 'react'  
import LivePodcastListItem from '@/pages/news/_components/bottom-section/live-podcast-list-item.tsx'  
import { useInfinitePodcasts } from '@/pages/news/hooks/action/use-infinite-podcasts.ts'  
import { MobileLoadingState } from '@/components/loading/loading.tsx'  
import { InfiniteScrollLoading } from '@/components/loading/infinite-scroll-loading.tsx'  
import { InfiniteScrollComplete } from '@/components/loading/infinite-scroll-complete.tsx'  
import { useGetPodcastDetail } from '@/pages/news/hooks/action/use-get-podcast-detail.ts'  
import { useNewBadge } from '@/pages/news/hooks/use-new-badge.ts'  
import useAppPlayerStore from '@/store/use-app-audio-store.ts'  
  
interface NewsBottomSectionProps {  
  onOpenPodcast: (podcast: DetailPodcastResponse, audioSrc: string | null) => void  
}  
  
export default function NewsBottomSection({  
                                            onOpenPodcast  
                                          }: NewsBottomSectionProps) {  
  const [scheduleFilter, setScheduleFilter] = useState<PodcastTypeEnum>("domestic")  
  const [activeTab, setActiveTab] = useState<string>("domestic")  
  const observerRef = useRef<IntersectionObserver | null>(null)  
  const [selectedPodcastId, setSelectedPodcastId] = useState<string | null>(null)  
  const [pendingAudioSrc, setPendingAudioSrc] = useState<string | null>(null)  
  
  // New Badge 훅 사용  
  const { isNewPodcast, markAsViewed } = useNewBadge();  
  
  // 앱 플레이어 스토어 사용  
  const {  
    isPlaying,  
    isLoading,  
    currentTrack,  
    error,  
    playlistStarted,  
    currentPlayerType,  
    playAudio,  
    pauseAudio,  
    resumeAudio,  
    stopAudio  
  } = useAppPlayerStore()  
  
  const {  
    data: podcastsData,  
    fetchNextPage,  
    hasNextPage,  
    isFetchingNextPage,  
    isLoading: isPodcastsLoading,  
    isError,  
    error: podcastsError,  
    refetch  
  } = useInfinitePodcasts({  
    type: scheduleFilter,  
    pageSize: 10,  
    enabled: true,  
  })  
  
  const {  
    data: podcastDetail,  
    isLoading: isDetailLoading,  
    isError: isDetailError  
  } = useGetPodcastDetail({  
    id: selectedPodcastId || '',  
    enabled: !!selectedPodcastId  
  })  
  
  useEffect(() => {  
    if (podcastDetail && selectedPodcastId && !isDetailLoading && !isDetailError) {  
      onOpenPodcast(podcastDetail, pendingAudioSrc)  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [podcastDetail, selectedPodcastId, isDetailLoading, isDetailError, onOpenPodcast, pendingAudioSrc])  
  
  useEffect(() => {  
    if (isDetailError && selectedPodcastId) {  
      console.error('팟캐스트 상세 정보 로딩 실패:', selectedPodcastId)  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [isDetailError, selectedPodcastId])  
  
  const handleRefresh = useCallback(() => {  
    refetch()  
  }, [refetch])  
  
  const lastPodcastElementRef = useCallback((node: HTMLDivElement | null) => {  
    if (isPodcastsLoading) return  
    if (observerRef.current) observerRef.current.disconnect()  
  
    observerRef.current = new IntersectionObserver(entries => {  
      if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {  
        fetchNextPage()  
      }  
    })  
  
    if (node) observerRef.current.observe(node)  
  }, [isPodcastsLoading, hasNextPage, isFetchingNextPage, fetchNextPage])  
  
  const handleTabChange = (value: string) => {  
    setActiveTab(value)  
    setScheduleFilter(value as PodcastTypeEnum)  
    window.scrollTo({ top: 0, behavior: 'smooth' })  
  }  
  
  const getAudioSrc = (podcast: PodcastResponse): string | null => {  
    if (activeTab === "speech-output" || !podcast.audioUrl) {  
      return null  
    }  
    return podcast.audioUrl  
  }  
  
  // 이미지 클릭 시 앱 플레이어로 재생 시도 (웹 플레이어 fallback 포함)  
  const handleImageClick = useCallback(async (podcast: PodcastResponse) => {  
    try {  
      const audioSrc = getAudioSrc(podcast)  
      if (!audioSrc) {  
        return  
      }  
  
      // 현재 재생 중인 트랙과 같으면 재생/일시정지 토글  
      if (currentTrack?.url === audioSrc) {  
        if (isPlaying) {  
          await pauseAudio()  
        } else {  
          await resumeAudio()  
        }  
        return  
      }  
  
      // 오디오 정보 구성  
      const audioInfo = {  
        url: audioSrc,  
        title: podcast.lmTitle,  
        artist: `${podcast.newsType === 'domestic' ? '국내' : '해외 비트코인'} 뉴스`,  
        albumArt: podcast.thumbnailUrl || undefined  
      }  
  
      // 앱 플레이어로 재생 시도 (실패 시 자동으로 웹 플레이어로 fallback)      await playAudio(audioInfo)  
  
    } catch (error) {  
      console.error('오디오 재생 중 오류 발생:', error)  
    }  
  }, [currentTrack, isPlaying, playAudio, pauseAudio, resumeAudio, getAudioSrc])  
  
  const handlePodcastPlay = useCallback(async (podcast: PodcastResponse, audioSrc: string | null) => {  
    try {  
      await stopAudio()  
  
      if (podcastDetail && selectedPodcastId === podcast.id && !isDetailLoading) {  
        onOpenPodcast(podcastDetail, audioSrc)  
        return  
      }  
  
      if (selectedPodcastId === podcast.id && isDetailLoading) {  
        return  
      }  
  
      setSelectedPodcastId(podcast.id)  
      setPendingAudioSrc(audioSrc)  
    } catch (error) {  
      console.error('팟캐스트 재생 중 오류 발생:', error)  
    }  
  }, [podcastDetail, selectedPodcastId, isDetailLoading, onOpenPodcast, stopAudio])  
  
  const isCurrentlyPlaying = useCallback((podcast: PodcastResponse) => {  
    const audioSrc = getAudioSrc(podcast)  
    return currentTrack?.url === audioSrc && isPlaying  
  }, [currentTrack, isPlaying, getAudioSrc])  
  
  const isCurrentlyLoading = useCallback((podcast: PodcastResponse) => {  
    const audioSrc = getAudioSrc(podcast)  
    return currentTrack?.url === audioSrc && isLoading  
  }, [currentTrack, isLoading, getAudioSrc])  
  
  const renderPodcastItem = (podcast: PodcastResponse | PodcastLiveFeedResponse, index: number) => {  
    const isLast = index === podcastsData!.length - 1  
    const isLiveFeed = activeTab === "speech-output"  
  
    const commonProps = {  
      key: podcast._uniqueKey,  
      ref: isLast ? lastPodcastElementRef : null,  
    }  
  
    if (isLiveFeed) {  
      return (  
        <div key={commonProps.key} ref={commonProps.ref}>  
          <LivePodcastListItem podcast={podcast as PodcastLiveFeedResponse} />  
        </div>      )  
    }  
  
    const typedPodcast = podcast as PodcastResponse  
    const audioSrc = getAudioSrc(typedPodcast)  
    const isNew = isNewPodcast(typedPodcast.id, typedPodcast.timeDt)  
  
    return (  
      <div key={commonProps.key} ref={commonProps.ref}>  
        <PodcastListItem          podcast={typedPodcast}  
          onOpen={() => handlePodcastPlay(typedPodcast, audioSrc)}  
          onImageClick={() => handleImageClick(typedPodcast)}  
          isPlaying={isCurrentlyPlaying(typedPodcast)}  
          isLoading={isCurrentlyLoading(typedPodcast)}  
          isNew={isNew}  
          onMarkAsViewed={() => markAsViewed(typedPodcast.id)}  
          showWebPlayerControls={true} // 항상 UI 표시 (내부에서 플레이어 타입에 따라 구분)  
          playerType={currentPlayerType} // 현재 플레이어 타입 전달  
        />  
      </div>    )  
  }  
  
  const renderScrollState = () => {  
    if (hasNextPage) {  
      return (  
        <InfiniteScrollLoading  
          isFetchingNextPage={isFetchingNextPage}  
          loadedCount={podcastsData?.length || 0}  
        />  
      )  
    }  
  
    if (podcastsData && podcastsData.length > 0) {  
      return (  
        <InfiniteScrollComplete  
          totalCount={podcastsData.length}  
          dataName="팟캐스트"  
        />  
      )  
    }  
  
    return null  
  }  
  
  if (isPodcastsLoading) {  
    return (  
      <div className="space-y-4">  
        <MobileLoadingState          state="loading"  
          title="팟캐스트 불러오는 중..."  
          description="최신 팟캐스트 데이터를 가져오고 있습니다."  
          size="md"  
          showAnimation={true}  
        />  
      </div>    )  
  }  
  
  if (isError) {  
    return (  
      <MobileLoadingState  
        state="error"  
        title="데이터 로딩 실패"  
        description="팟캐스트 데이터를 불러오는 중 문제가 발생했습니다."  
        error={podcastsError}  
        onRetry={handleRefresh}  
        onRefresh={() => window.location.reload()}  
      />  
    )  
  }  
  
  const renderEmptyState = () => {  
    const getEmptyStateContent = () => {  
      switch (activeTab) {  
        case "domestic":  
          return {  
            title: "국내 뉴스가 없습니다",  
            description: "아직 등록된 국내 뉴스 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        case "overseas-bitcoin":  
          return {  
            title: "글로벌 & 코인 뉴스가 없습니다",  
            description: "아직 등록된 글로벌 & 코인 뉴스 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        case "speech-output":  
          return {  
            title: "실시간 뉴스가 없습니다",  
            description: "현재 실시간으로 진행되는 뉴스가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        default:  
          return {  
            title: "팟캐스트가 없습니다",  
            description: "아직 등록된 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
      }  
    }  
  
    const { title, description } = getEmptyStateContent()  
  
    return (  
      <MobileLoadingState  
        state="empty"  
        title={title}  
        description={description}  
        onRefresh={handleRefresh}  
        size="md"  
      />  
    )  
  }  
  
  const renderPodcastList = () => {  
    if (!podcastsData || podcastsData.length === 0) {  
      return renderEmptyState()  
    }  
  
    return (  
      <div className="space-y-3">  
        {podcastsData.map(renderPodcastItem)}  
        {renderScrollState()}  
      </div>  
    )  
  }  
  
  return (  
    <div className="mb-4">  
      <Tabs        defaultValue="domestic"  
        value={activeTab}  
        onValueChange={handleTabChange}  
      >  
        <TabsList className="grid w-full grid-cols-3 gap-1 min-[320px]:gap-2">  
          <TabsTrigger            value="domestic"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[320px]:inline">국내 뉴스</span>  
            <span className="min-[320px]:hidden">국내</span>  
          </TabsTrigger>          <TabsTrigger            value="overseas-bitcoin"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[360px]:inline">글로벌 & 코인 뉴스</span>  
            <span className="hidden min-[320px]:inline min-[360px]:hidden">글로벌&코인</span>  
            <span className="min-[320px]:hidden">글로벌</span>  
          </TabsTrigger>          <TabsTrigger            value="speech-output"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[320px]:inline">실시간 발언</span>  
            <span className="min-[320px]:hidden">실시간</span>  
          </TabsTrigger>        </TabsList>  
        <TabsContent value="domestic" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
  
        <TabsContent value="overseas-bitcoin" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
  
        <TabsContent value="speech-output" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
      </Tabs>    </div>  )  
}
```

> 팟캐스트 플레이어 백업
```null
import { useCallback, useEffect, useState } from 'react'  
import moment from 'moment'  
import { Pause, Play } from 'lucide-react'  
import MindMapTree from './bottom-section/mind-map-tree.tsx'  
import { Button } from '@/components/ui/button.tsx'  
import { usePodcastPlayer } from '@/pages/news/hooks/modal/use-podcast-player.ts'  
import { ResponsiveModal } from '@/components/response-modal.tsx'  
import type { MindMapNode } from '@/pages/news/types'  
import ReactMarkdown from 'react-markdown'  
import useAppPlayerStore from '@/store/use-app-audio-store.ts'  
  
export default function PodcastPlayer() {  
  const { open, openPodcast: podcast, audioSrc, onClose } = usePodcastPlayer()  
  const [mindMap, setMindMap] = useState<MindMapNode | null>(null)  
  
  // Zustand store 상태와 액션들  
  const {  
    isPlaying,  
    isLoading,  
    currentPlayerType,  
    currentTrack,  
    error,  
    webAudioElement,  
    playAudio,  
    pauseAudio,  
    resumeAudio,  
    stopAudio,  
    getCurrentTime,  
    getDuration,  
  } = useAppPlayerStore()  
  
  // 웹 플레이어 상태 (fallback용)  
  const [webPlayerTime, setWebPlayerTime] = useState(0)  
  const [webPlayerDuration, setWebPlayerDuration] = useState(0)  
  
  // 앱 플레이어가 활성화되어 있는지 확인  
  const isAppPlayerActive = currentPlayerType === 'app' && isPlaying  
  
  // 웹 플레이어 UI를 보여야 하는지 확인  
  const shouldShowWebPlayerUI = !isAppPlayerActive  
  
  // 웹 플레이어가 재생 중인지 확인  
  const isWebPlayerPlaying = currentPlayerType === 'web' && isPlaying  
  
  // 웹 플레이어 재생 핸들러 (재생만 가능)  
  const handleWebPlayerPlay = useCallback(async () => {  
    if (!podcast || !audioSrc) return  
  
    const audioInfo = {  
      url: audioSrc,  
      title: podcast.lmTitle,  
      artist: '82ALDA Podcast',  
      albumArt: podcast.thumbnailUrl || undefined  
    }  
  
    try {  
      await playAudio(audioInfo)  
    } catch (error) {  
      console.error('웹 플레이어 재생 실패:', error)  
    }  
  }, [podcast, audioSrc, playAudio])  
  
  // 웹 플레이어 일시정지 핸들러  
  const handleWebPlayerPause = useCallback(async () => {  
    if (currentPlayerType === 'web') {  
      await pauseAudio()  
    }  
  }, [currentPlayerType, pauseAudio])  
  
  // 웹 플레이어 재개 핸들러  
  const handleWebPlayerResume = useCallback(async () => {  
    if (currentPlayerType === 'web') {  
      await resumeAudio()  
    }  
  }, [currentPlayerType, resumeAudio])  
  
  // 앱 플레이어 제어 핸들러들  
  const handleAppPlayerPause = useCallback(async () => {  
    if (currentPlayerType === 'app') {  
      await pauseAudio()  
    }  
  }, [currentPlayerType, pauseAudio])  
  
  const handleAppPlayerResume = useCallback(async () => {  
    if (currentPlayerType === 'app') {  
      await resumeAudio()  
    }  
  }, [currentPlayerType, resumeAudio])  
  
  // 다이얼로그 닫기 핸들러  
  const handleClose = useCallback(async () => {  
    try {  
      // 재생 중인 오디오 정지  
      await stopAudio()  
    } catch (error) {  
      console.error('오디오 정지 실패:', error)  
    } finally {  
      onClose()  
    }  
  }, [stopAudio, onClose])  
  
  // 웹 플레이어 시간 업데이트 리스너  
  useEffect(() => {  
    if (!webAudioElement) return  
  
    const updateTime = () => {  
      setWebPlayerTime(webAudioElement.currentTime || 0)  
      setWebPlayerDuration(webAudioElement.duration || 0)  
    }  
  
    const handleTimeUpdate = () => updateTime()  
    const handleDurationChange = () => updateTime()  
    const handleLoadedMetadata = () => updateTime()  
  
    webAudioElement.addEventListener('timeupdate', handleTimeUpdate)  
    webAudioElement.addEventListener('durationchange', handleDurationChange)  
    webAudioElement.addEventListener('loadedmetadata', handleLoadedMetadata)  
  
    return () => {  
      webAudioElement.removeEventListener('timeupdate', handleTimeUpdate)  
      webAudioElement.removeEventListener('durationchange', handleDurationChange)  
      webAudioElement.removeEventListener('loadedmetadata', handleLoadedMetadata)  
    }  
  }, [webAudioElement])  
  
  // 마인드맵 데이터 로드  
  useEffect(() => {  
    if (!podcast) return  
    try {  
      const mindMapData = JSON.parse(podcast.lmMindMapJson) as MindMapNode || null  
      setMindMap(mindMapData)  
    } catch (error) {  
      console.error('마인드맵 파싱 오류:', error)  
      setMindMap(null)  
    }  
  }, [podcast])  
  
  
  // 시간 포맷팅  
  const formatTime = useCallback((timeInSeconds: number) => {  
    return moment.utc(timeInSeconds * 1000).format('m:ss')  
  }, [])  
  
  // 현재 시간 가져오기  
  const getCurrentPlayTime = useCallback(() => {  
    if (currentPlayerType === 'app') {  
      return getCurrentTime()  
    } else if (currentPlayerType === 'web') {  
      return webPlayerTime  
    }  
    return 0  
  }, [currentPlayerType, getCurrentTime, webPlayerTime])  
  
  // 전체 시간 가져오기  
  const getTotalPlayTime = useCallback(() => {  
    if (currentPlayerType === 'app') {  
      return getDuration()  
    } else if (currentPlayerType === 'web') {  
      return webPlayerDuration  
    }  
    return 0  
  }, [currentPlayerType, getDuration, webPlayerDuration])  
  
  // 진행률 계산  
  const getProgress = useCallback(() => {  
    const currentTime = getCurrentPlayTime()  
    const totalTime = getTotalPlayTime()  
    return totalTime > 0 ? (currentTime / totalTime) * 100 : 0  
  }, [getCurrentPlayTime, getTotalPlayTime])  
  
  return (  
    <>  
      {podcast && (  
        <ResponsiveModal title={'팟캐스트 상세보기'} open={open} onOpenChange={handleClose}>  
          <>            {/* Scrollable Content */}  
            <div className="flex-1 overflow-y-auto min-h-0">  
              <div className="p-4 space-y-4">  
                {/* 팟캐스트 제목 섹션 */}  
                <div className="rounded-xl bg-card/50 backdrop-blur-sm border border-border/50 p-4 shadow-lg">  
                  <div className="flex items-center gap-2 mb-2">  
                    <div className="w-2 h-2 rounded-full bg-blue-500"></div>  
                    <h4 className="text-sm font-semibold text-foreground">팟캐스트 제목</h4>  
                  </div>                  <div className="h-px bg-border/30 mb-3"></div>  
                  <p className="text-sm leading-tight">  
                    {podcast.lmTitle}  
                  </p>  
                </div>  
                {/* 마인드맵 섹션 */}  
                <div className="rounded-xl bg-card/50 backdrop-blur-sm border border-border/50 p-4 shadow-lg">  
                  <div className="flex items-center gap-2 mb-3">  
                    <div className="w-2 h-2 rounded-full bg-blue-500"></div>  
                    <h4 className="text-sm font-semibold text-foreground">주요 내용 마인드맵</h4>  
                  </div>                  <div className="h-px bg-border/30 mb-3"></div>  
                  {mindMap ? (  
                    <MindMapTree data={mindMap}/>  
                  ) : (  
                    <p className="text-xs leading-tight">마인드맵 정보가 없습니다.</p>  
                  )}  
                </div>  
  
                {/* 에피소드 설명 섹션 */}  
                <div className="rounded-xl bg-card/30 backdrop-blur-sm border border-border/30 p-4">  
                  <div className="prose prose-sm max-w-none">  
                    <ReactMarkdown                      components={{  
                        h1: ({children}) => <h1 className="text-lg font-bold text-foreground mt-4 mb-3">{children}</h1>,  
                        h2: ({children}) => <h2 className="text-base font-bold text-foreground mt-4 mb-2">{children}</h2>,  
                        h3: ({children}) => <h3 className="text-sm font-semibold text-foreground mt-3 mb-2">{children}</h3>,  
                        h4: ({children}) => <h4 className="text-sm font-semibold text-foreground mt-2 mb-1">{children}</h4>,  
                        p: ({children}) => <p className="text-sm leading-relaxed text-muted-foreground mb-2">{children}</p>,  
                        ul: ({children}) => <ul className="list-disc list-outside mb-3 ml-4 pl-2">{children}</ul>,  
                        ol: ({children}) => <ol className="list-decimal list-outside mb-3 ml-4 pl-2">{children}</ol>,  
                        li: ({children}) => <li className="text-sm leading-relaxed text-muted-foreground mb-1">{children}</li>,  
                        strong: ({children}) => <strong className="font-semibold text-foreground">{children}</strong>,  
                        em: ({children}) => <em className="italic text-muted-foreground">{children}</em>,  
                        code: ({children}) => <code className="bg-muted px-1 py-0.5 rounded text-sm font-mono">{children}</code>,  
                        blockquote: ({children}) => <blockquote className="border-l-2 border-muted pl-3 italic text-muted-foreground my-2">{children}</blockquote>,  
                      }}  
                    >  
                      {podcast.lmContent}  
                    </ReactMarkdown>  
                  </div>                </div>              </div>            </div>  
            {/* 플레이어 컨트롤 - 웹 플레이어 UI가 보여야 할 때만 표시 */}  
            {shouldShowWebPlayerUI && (  
              <div className="px-4 py-3 border-t border-border/50 bg-background/95 backdrop-blur-sm flex-shrink-0">  
                {/* 웹 플레이어인 경우에만 진행률 바와 시간 표시 */}  
                {currentPlayerType === 'web' && (  
                  <div className="mb-3">  
                    <div className="h-1.5 w-full overflow-hidden rounded-full bg-muted/50">  
                      <div                        className="h-full rounded-full bg-gradient-to-r from-primary to-primary/80 transition-all duration-100"  
                        style={{width: `${getProgress()}%`}}  
                      />  
                    </div>  
                    {/* 시간 표시 */}  
                    <div className="flex items-center justify-between text-xs text-muted-foreground mt-2">  
                      <span className="font-mono">  
                        {formatTime(getCurrentPlayTime())}  
                      </span>  
                      <span className="font-mono">  
                        {getTotalPlayTime() ? formatTime(getTotalPlayTime()) : ''}  
                      </span>  
                    </div>                  </div>                )}  
  
                {/* 컨트롤 버튼 */}  
                <div className="flex items-center justify-center gap-4">  
                  {/* 웹 플레이어 재생/일시정지 버튼 */}  
                  {isWebPlayerPlaying ? (  
                    <Button  
                      size="icon"  
                      className="h-14 w-14 rounded-full bg-gradient-to-r from-primary to-primary/90 hover:from-primary/90 hover:to-primary shadow-xl hover:shadow-2xl transition-all duration-200 hover:scale-105 disabled:opacity-50"  
                      onClick={handleWebPlayerPause}  
                      disabled={isLoading}  
                    >  
                      {isLoading ? (  
                        <div className="w-6 h-6 border-2 border-primary-foreground/30 border-t-primary-foreground rounded-full animate-spin"/>  
                      ) : (  
                        <Pause className="h-6 w-6 text-primary-foreground fill-current dark:text-gray-50"/>  
                      )}  
                    </Button>  
                  ) : (  
                    <Button  
                      size="icon"  
                      className="h-14 w-14 rounded-full bg-gradient-to-r from-primary to-primary/90 hover:from-primary/90 hover:to-primary shadow-xl hover:shadow-2xl transition-all duration-200 hover:scale-105 disabled:opacity-50"  
                      onClick={currentPlayerType === 'web' ? handleWebPlayerResume : handleWebPlayerPlay}  
                      disabled={!audioSrc || isLoading}  
                    >  
                      {isLoading ? (  
                        <div className="w-6 h-6 border-2 border-primary-foreground/30 border-t-primary-foreground rounded-full animate-spin"/>  
                      ) : (  
                        <Play className="h-6 w-6 text-primary-foreground fill-current ml-1 dark:text-gray-50"/>  
                      )}  
                    </Button>  
                  )}  
                </div>  
  
                {/* 에러 메시지 표시 */}  
                {error && (  
                  <div className="mt-3 text-center">  
                    <p className="text-sm text-red-500">{error}</p>  
                  </div>                )}  
  
                {/* 로딩 상태 */}  
                {!audioSrc && (  
                  <div className="mt-3 text-center">  
                    <div className="inline-flex items-center gap-2 text-sm text-muted-foreground">  
                      <div className="w-4 h-4 border-2 border-primary/30 border-t-primary rounded-full animate-spin"></div>  
                      오디오 로딩 중...  
                    </div>  
                  </div>                )}  
              </div>  
            )}  
  
            {/* 앱 플레이어가 활성화된 경우 간단한 상태 표시 */}  
            {isAppPlayerActive && (  
              <div className="px-4 py-3 border-t border-border/50 bg-background/95 backdrop-blur-sm flex-shrink-0">  
                <div className="text-center">  
                  <div className="inline-flex items-center gap-2 text-sm text-muted-foreground">  
                    <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>  
                    앱 플레이어에서 재생 중  
                  </div>  
                  {currentTrack && (  
                    <p className="text-xs text-muted-foreground mt-1 truncate">  
                      {currentTrack.title}  
                    </p>  
                  )}  
                </div>  
              </div>            )}  
          </>  
        </ResponsiveModal>      )}  
    </>  
  )  
}
```