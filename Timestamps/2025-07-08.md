
#### Work
---
- [ ] 팟캐스트 오디오 에러 수정
- [ ] 팟캐스트 날짜 형식이 2025-07-05 12:30 는 17시간  형태로
- [ ] 팟캐스트 메인 페이지에서 Badge 개수가 글자 수에 연동되도록 변경
- [ ] AI 시그널 차트 api 호출을 클릭하면 불러오도록 변경
- [ ] 소셜 자체에 연결되는 로그아웃 처리
- [ ] 회원 탈퇴

```plaintext

해당환경은 REACT / VITE 환경에서 여러 팟캐스트 리스트들에 대해 각 팟캐스트 아이템을 출력하는 코드이다.
애플리케이션 내에서 보여지는 웹뷰가 있는 것이 특징인 코드로, 앱 플레이어 기능을 구현해야 한다.

PodcastResponse {
  id: string;

  /** 뉴스 타입 (domestic, overseas-bitcoin) */
  newsType: PodcastTypeEnum;

  /** 요약 제목 */
  lmTitle: string;

  /** 요약 내용 */
  lmContent: string;

  /** 관련 태그 목록 */
  tags: string[];

  /** 썸네일 이미지 URL */
  thumbnailUrl: string;

  /** 오디오 파일 URL (nullable) */
  audioUrl?: string | null;

  /** 생성 일시 (yyyy-MM-dd HH:mm:ss) */
  timeDt: string;

  /** 기타: 프론트엔드 별도 등록 키 */
  _uniqueKey: string;
}

import type {DetailPodcastResponse, PodcastLiveFeedResponse, PodcastResponse, PodcastTypeEnum} from "../types"  
import {Tabs, TabsContent, TabsList, TabsTrigger} from "@/components/ui/tabs.tsx"  
import PodcastListItem from "./podcast-list-item"  
import {useCallback, useEffect, useRef, useState} from "react"  
import LivePodcastListItem from "@/pages/news/_components/live-podcast-list-item.tsx";  
import {useInfinitePodcasts} from "@/pages/news/hooks/action/use-infinite-podcasts.ts";  
import {MobileLoadingState} from "@/components/loading/loading.tsx";  
import {InfiniteScrollLoading} from "@/components/loading/infinite-scroll-loading.tsx";  
import {InfiniteScrollComplete} from "@/components/loading/infinite-scroll-complete.tsx";  
import {CONTENTS_URL} from "@/data/constants.ts";  
import {useGetPodcastDetail} from "@/pages/news/hooks/action/use-get-podcast-detail.ts";  
  
interface NewsBottomSectionProps {  
  onOpenPodcast: (podcast: DetailPodcastResponse, audioSrc: string | null) => void  
}  
  
export default function NewsBottomSection({  
                                            onOpenPodcast  
                                          }: NewsBottomSectionProps) {  
  
  const [scheduleFilter, setScheduleFilter] = useState<PodcastTypeEnum>("domestic")  
  const [activeTab, setActiveTab] = useState<string>("domestic")  
  const observerRef = useRef<IntersectionObserver | null>(null)  
  const [selectedPodcastId, setSelectedPodcastId] = useState<string | null>(null)  
  const [pendingAudioSrc, setPendingAudioSrc] = useState<string | null>(null)  
  
  const {  
    data: podcastsData,  
    fetchNextPage,  
    hasNextPage,  
    isFetchingNextPage,  
    isLoading,  
    isError,  
    error,  
    refetch  
  } = useInfinitePodcasts({  
    type: scheduleFilter,  
    pageSize: 10,  
    enabled: true, // 항상 활성화  
  })  
  
  // 팟캐스트 상세 정보 조회  
  const {  
    data: podcastDetail,  
    isLoading: isDetailLoading,  
    isError: isDetailError  
  } = useGetPodcastDetail({  
    id: selectedPodcastId || '',  
    enabled: !!selectedPodcastId  
  })  
  
  // 상세 데이터가 로드되면 onOpenPodcast 호출  
  useEffect(() => {  
    if (podcastDetail && selectedPodcastId && !isDetailLoading && !isDetailError) {  
      onOpenPodcast(podcastDetail, pendingAudioSrc)  
      // 상태 초기화  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [podcastDetail, selectedPodcastId, isDetailLoading, isDetailError, onOpenPodcast, pendingAudioSrc])  
  
  // 상세 데이터 로딩 에러 처리  
  useEffect(() => {  
    if (isDetailError && selectedPodcastId) {  
      console.error('팟캐스트 상세 정보 로딩 실패:', selectedPodcastId)  
      // 에러 발생 시 상태 초기화  
      setSelectedPodcastId(null)  
      setPendingAudioSrc(null)  
    }  
  }, [isDetailError, selectedPodcastId])  
  
  // 재호출  
  const handleRefresh = useCallback(() => {  
    refetch()  
  }, [refetch])  
  
  // 무한 스크롤을 위한 Intersection Observer 설정  
  const lastPodcastElementRef = useCallback((node: HTMLDivElement | null) => {  
    if (isLoading) return  
    if (observerRef.current) observerRef.current.disconnect()  
  
    observerRef.current = new IntersectionObserver(entries => {  
      if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {  
        fetchNextPage()  
      }  
    })  
  
    if (node) observerRef.current.observe(node)  
  }, [isLoading, hasNextPage, isFetchingNextPage, fetchNextPage])  
  
  // 탭 변경 시 스크롤을 맨 위로 이동  
  const handleTabChange = (value: string) => {  
    setActiveTab(value)  
    setScheduleFilter(value as PodcastTypeEnum)  
    window.scrollTo({ top: 0, behavior: 'smooth' })  
  }  
  
  // 오디오 URL 생성 헬퍼 함수  
  const getAudioSrc = (podcast: PodcastResponse): string | null => {  
    if (activeTab === "speech-output" || !podcast.audioUrl) {  
      return null  
    }  
    return `${CONTENTS_URL}${podcast.audioUrl}`  
  }  
  
  // 팟캐스트 플레이 핸들러  
  const handlePodcastPlay = useCallback((podcast: PodcastResponse, audioSrc: string | null) => {  
    // 이미 상세 정보가 로드되어 있고 같은 팟캐스트인 경우  
    if (podcastDetail && selectedPodcastId === podcast.id && !isDetailLoading) {  
      onOpenPodcast(podcastDetail, audioSrc)  
      return  
    }  
  
    // 이미 같은 팟캐스트를 로딩 중인 경우 중복 요청 방지  
    if (selectedPodcastId === podcast.id && isDetailLoading) {  
      return  
    }  
  
    // 새로운 팟캐스트 선택 시 상세 정보 로드  
    setSelectedPodcastId(podcast.id)  
    setPendingAudioSrc(audioSrc)  
  }, [podcastDetail, selectedPodcastId, isDetailLoading, onOpenPodcast])  
  
  // 팟캐스트 아이템 렌더링 헬퍼 함수  
  const renderPodcastItem = (podcast: PodcastResponse | PodcastLiveFeedResponse, index: number) => {  
    const isLast = index === podcastsData!.length - 1  
    const isLiveFeed = activeTab === "speech-output"  
  
    const commonProps = {  
      key: podcast._uniqueKey,  
      ref: isLast ? lastPodcastElementRef : null,  
    }  
  
    // 실시간  
    if (isLiveFeed) {  
      return (  
        <div key={commonProps.key} ref={commonProps.ref}>  
          <LivePodcastListItem            podcast={podcast as PodcastLiveFeedResponse}  
          />  
        </div>      )  
    }  
  
    // 국내 or 글로벌&코인뉴스  
    const typedPodcast = podcast as PodcastResponse  
    const audioSrc = getAudioSrc(typedPodcast)  
  
    return (  
      <div key={commonProps.key} ref={commonProps.ref}>  
        <PodcastListItem          podcast={typedPodcast}  
          onOpen={() => handlePodcastPlay(typedPodcast, audioSrc)}  
        />  
      </div>    )  
  }  
  
  // 무한 스크롤 상태 렌더링 헬퍼 함수  
  const renderScrollState = () => {  
    if (hasNextPage) {  
      return (  
        <InfiniteScrollLoading  
          isFetchingNextPage={isFetchingNextPage}  
          loadedCount={podcastsData?.length || 0}  
        />  
      )  
    }  
  
    if (podcastsData && podcastsData.length > 0) {  
      return (  
        <InfiniteScrollComplete  
          totalCount={podcastsData.length}  
          dataName="팟캐스트"  
        />  
      )  
    }  
  
    return null  
  }  
  
  // 로딩 중이거나 에러가 발생한 경우 처리  
  if (isLoading) {  
    return (  
      <div className="space-y-4">  
        <MobileLoadingState          state="loading"  
          title="팟캐스트 불러오는 중..."  
          description="최신 팟캐스트 데이터를 가져오고 있습니다."  
          size="md"  
          showAnimation={true}  
        />  
      </div>    )  
  }  
  
  if (isError) {  
    return (  
      <MobileLoadingState  
        state="error"  
        title="데이터 로딩 실패"  
        description="팟캐스트 데이터를 불러오는 중 문제가 발생했습니다."  
        error={error}  
        onRetry={handleRefresh}  
        onRefresh={() => window.location.reload()}  
      />  
    )  
  }  
  
  // 빈 상태 렌더링 헬퍼 함수  
  const renderEmptyState = () => {  
    const getEmptyStateContent = () => {  
      switch (activeTab) {  
        case "domestic":  
          return {  
            title: "국내 뉴스가 없습니다",  
            description: "아직 등록된 국내 뉴스 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        case "overseas-bitcoin":  
          return {  
            title: "글로벌 & 코인 뉴스가 없습니다",  
            description: "아직 등록된 글로벌 & 코인 뉴스 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        case "speech-output":  
          return {  
            title: "실시간 뉴스가 없습니다",  
            description: "현재 실시간으로 진행되는 뉴스가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
        default:  
          return {  
            title: "팟캐스트가 없습니다",  
            description: "아직 등록된 팟캐스트가 없습니다.\n잠시 후 다시 확인해주세요."  
          }  
      }  
    }  
  
    const { title, description } = getEmptyStateContent()  
  
    return (  
      <MobileLoadingState  
        state="empty"  
        title={title}  
        description={description}  
        onRefresh={handleRefresh}  
        size="md"  
      />  
    )  
  }  
  
  const renderPodcastList = () => {  
    // 데이터가 없는 경우 빈 상태 렌더링  
    if (!podcastsData || podcastsData.length === 0) {  
      return renderEmptyState()  
    }  
  
    return (  
      <div className="space-y-3">  
        {podcastsData.map(renderPodcastItem)}  
        {renderScrollState()}  
      </div>  
    )  
  }  
  
  return (  
    <div className="mb-4">  
      <Tabs        defaultValue="domestic"  
        value={activeTab}  
        onValueChange={handleTabChange}  
      >  
        <TabsList className="grid w-full grid-cols-3 gap-1 min-[320px]:gap-2">  
          <TabsTrigger            value="domestic"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[320px]:inline">국내 뉴스</span>  
            <span className="min-[320px]:hidden">국내</span>  
          </TabsTrigger>          <TabsTrigger            value="overseas-bitcoin"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[360px]:inline">글로벌 & 코인 뉴스</span>  
            <span className="hidden min-[320px]:inline min-[360px]:hidden">글로벌&코인</span>  
            <span className="min-[320px]:hidden">글로벌</span>  
          </TabsTrigger>          <TabsTrigger            value="speech-output"  
            className="text-xs px-1 min-[320px]:px-3"  
          >  
            <span className="hidden min-[320px]:inline">실시간 뉴스</span>  
            <span className="min-[320px]:hidden">실시간</span>  
          </TabsTrigger>        </TabsList>  
        <TabsContent value="domestic" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
  
        <TabsContent value="overseas-bitcoin" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
  
        <TabsContent value="speech-output" className="mt-4">  
          {renderPodcastList()}  
        </TabsContent>  
      </Tabs>    </div>  )  
}

import {Card, CardContent} from "@/components/ui/card"
import type {PodcastResponse} from "../types"
import {Clock} from "lucide-react"
import {Badge} from "@/components/ui/badge"
import {CONTENTS_URL} from "@/data/constants.ts";
import {useEffect, useState} from "react";
import moment from "moment";
import {checkImageValidity} from "@/lib/utils.ts";

interface PodcastListItemProps {
  podcast: PodcastResponse
  onOpen: () => void
}

export default function PodcastListItem({ podcast, onOpen }: PodcastListItemProps) {
  const isDomestic = podcast.newsType === "domestic"
  const isOverseasBitcoin = podcast.newsType === "overseas-bitcoin"
  const [imgUrl, setImgUrl] = useState<string>("/img/placeholder.svg");
  const [hasValidImage, setHasValidImage] = useState<boolean>(false);
  const [imageLoading, setImageLoading] = useState<boolean>(false);

  const handleImageError = () => {
    setImgUrl("/img/placeholder.svg");
    setHasValidImage(true);
  }

  // 이미지 클릭 시 오디오 재생
  const handleImageClick = async (e: React.MouseEvent) => {
    e.stopPropagation(); // 카드 클릭 이벤트 방지

    if (podcast.audioUrl) {
      const audioUrl = `${CONTENTS_URL}${podcast.audioUrl}`
      // 오디오 재생로직 추가
      console.log('audioUrl is ',audioUrl)
    }
  };

  const handleOnCardClick = async () => {
    onOpen();
  }

  const extractPlainText = (markdownText: string) => {
    if (!markdownText) return '';
    return markdownText
      // 헤더 제거 (### → 빈 문자열)
      .replace(/#{1,6}\s*/g, '')
      // 볼드/이탤릭 제거 (**text** → text)
      .replace(/\*{1,2}([^*]+)\*{1,2}/g, '$1')
      // 링크 제거 ([text](url) → text)
      .replace(/\[([^\]]+)]\([^)]+\)/g, '$1')
      // 리스트 마커 제거 (- item → item)
      .replace(/^\s*[-*+]\s+/gm, '')
      // 번호 리스트 제거 (1. item → item)
      .replace(/^\s*\d+\.\s+/gm, '')
      // 백틱 제거 (`code` → code)
      .replace(/`([^`]+)`/g, '$1')
      // 여러 줄바꿈을 하나로 정리
      .replace(/\n{3,}/g, '\n\n')
      // 앞뒤 공백 제거
      .trim();
  }

  useEffect(() => {
    const loadImage = async () => {
      const isHaveThumbnailUrl = podcast.thumbnailUrl && podcast.thumbnailUrl.length > 0;

      if (isHaveThumbnailUrl) {
        setImageLoading(true);
        const fullImageUrl = `${CONTENTS_URL}${podcast.thumbnailUrl}`;

        // 이미지 유효성 검사
        const isValid = await checkImageValidity(fullImageUrl);

        if (isValid) {
          setImgUrl(fullImageUrl);
          setHasValidImage(true);
        } else {
          setImgUrl("/img/placeholder.svg");
          setHasValidImage(true); // placeholder도 유효한 이미지로 처리
        }
        setImageLoading(false);
      } else {
        setImgUrl("/img/placeholder.svg");
        setHasValidImage(true); // placeholder 사용
      }
    };

    loadImage();
  }, [podcast]);

  return (
    <Card
      className={`overflow-hidden rounded-xl shadow-sm border-l-2 border-l-blue-500 border-blue-100 bg-blue-50/30 dark:border-blue-800 dark:bg-blue-900/20 dark:border-l-blue-400`}
      onClick={podcast.audioUrl ? handleOnCardClick : undefined}
    >
      <CardContent className="p-0">
        <div className={`flex gap-2 md:gap-2.5 p-3 ${!hasValidImage ? 'flex-col' : ''}`}>
          {/* 이미지 영역 - 항상 표시 (placeholder 포함) */}
          {hasValidImage && (
            <div
              className="relative h-14 w-14 md:h-16 md:w-16 flex-shrink-0 overflow-hidden rounded-lg cursor-pointer"
              onClick={handleImageClick}
            >
              {imageLoading ? (
                <div className="h-full w-full bg-gray-200 dark:bg-gray-700 animate-pulse flex items-center justify-center">
                  <div className="w-4 h-4 border-2 border-gray-400 border-t-transparent rounded-full animate-spin"></div>
                </div>
              ) : (
                <img
                  src={imgUrl}
                  alt={podcast.lmTitle}
                  className="h-full w-full object-cover"
                  onError={handleImageError}
                />
              )}

              {/* 오디오 재생 상태 표시 해야 함 */}

            </div>
          )}

          {/* 텍스트 영역 - 이미지가 없으면 전체 너비 사용 */}
          <div className={`flex flex-1 flex-col justify-between ${hasValidImage ? 'min-w-0' : 'w-full'}`}>
            <div>
              {/* 태그 영역 - 한 줄로 제한하고 말줄임표 적용 */}
              <div className="mb-1 flex items-center gap-1 overflow-hidden">
                <div className="flex gap-1 min-w-0 flex-1">
                  <div className="flex gap-1 overflow-hidden">
                    {podcast.tags.slice(0, 2).map((tag, index) => (
                      <Badge key={index} className="bg-blue-500 text-white text-[11px] px-1.5 py-0.5 whitespace-nowrap">
                        {tag}
                      </Badge>
                    ))}
                  </div>
                  <div className="flex gap-1">
                    {isDomestic && (
                      <Badge className="bg-green-500 text-white text-xs px-1.5 py-0.5 whitespace-nowrap">
                        국내
                      </Badge>
                    )}
                    {isOverseasBitcoin && (
                      <Badge className="bg-orange-500 text-white text-xs px-1.5 py-0.5 whitespace-nowrap">
                        해외 비트코인
                      </Badge>
                    )}
                  </div>
                </div>
              </div>

              {/* 제목 - 한 줄로 제한하고 말줄임표 적용 */}
              <h4 className={`mb-1 font-medium text-sm line-clamp-1 text-foreground`}>
                {podcast.lmTitle}
              </h4>

              <p className={`text-xs text-muted-foreground ${hasValidImage ? 'line-clamp-2' : 'line-clamp-3'}`}>
                {extractPlainText(podcast.lmContent)}
              </p>
            </div>
            <div className="flex items-center justify-between mt-1.5">
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <Clock className="h-2.5 w-2.5" />
                <span>{moment(podcast.timeDt).format("YYYY-MM-DD HH:mm")}</span>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}


===

현재 위 코드에서 <Card> 내 이미지를 클릭 시, audioUrl에 대한 오디오가 실행되도록 해야해.
주 요구사항은 아래와 같아.

1. 오디오 재생 시, 기능 구현을 쉽게 할 수 있는 라이브러리를 찾아서 구현해줘
2. 그냥 웹 플레이어로 재생하는 것이 목적이 아니야. 아래 코드를 참조해서 만들어야 해
 - 먼저, 앱 플레이어로 재생해야해. 앱 플레이어 관련 로직은 아래를 참고해
 - 만약, 앱 플레이어 재생을 시도하다가 문제가 생겨서 앱 플레이어로 재생할 수 없을 경우, 웹 플레이어로 재생해야 해.

<body>
  <div class="container">
    <h1>오디오 플레이어</h1>
    
    <div class="player-container">
      <div class="player-info">
        <p class="track-title" id="track-title">트랙을 선택해주세요</p>
        <p class="track-artist" id="track-artist">아티스트</p>
      </div>
      
      <div class="simple-controls">
        <button class="control-button" id="play-button" onclick="requestPlay()">재생</button>
        <button class="control-button" id="pause-button" onclick="requestPause()" disabled>일시정지</button>
        <button class="control-button" id="stop-button" onclick="requestStop()" disabled>정지</button>
      </div>
      
      <div class="status-display">
        <h3>재생 상태</h3>
        <p class="status-text" id="status-text">재생할 트랙을 선택해주세요.</p>
      </div>
    </div>
    
    <h2>재생 목록</h2>
    <div class="playlist" id="playlist">
      <!-- 재생 목록은 JavaScript로 동적 생성됩니다 -->
    </div>
    
    <footer>
      오디오 플레이어
    </footer>
  </div>

  <script>
    let currentTrack = null;
    let isPlaying = false;
    
    // 재생 목록 데이터
    const playlist = [
      {
        title: "에피소드 1: 시작하는 이야기 시작하는 이야기",
        artist: "82ALDA Podcast 에피소드 1",
        url: "http://52.79.86.180:3100/test/assets/audio/sample1.mp3",
        albumArt: "https://kr.memuplay.com/home/Public/img/nusernote3.png"
      },
      {
        title: "에피소드 2: 계속되는 이야기", 
        artist: "82ALDA Podcast 에피소드 2",
        url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3",
        albumArt: "https://kr.memuplay.com/home/Public/img/nusernote2.png"
      },
      {
        title: "에피소드 3: 마무리 이야기",
        artist: "82ALDA Podcast 에피소드 3", 
        url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3",
        albumArt: "https://kr.memuplay.com/home/Public/img/nusernote1.png"
      }
    ];
    
    // DOM 초기화
    document.addEventListener('DOMContentLoaded', function() {
      initializePlaylist();
      updateUI();
    });
    
    // 재생 목록 초기화
    function initializePlaylist() {
      const playlistContainer = document.getElementById('playlist');
      playlistContainer.innerHTML = '';
      
      playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        item.onclick = () => selectTrack(index);
        
        item.innerHTML = `
          <div class="playlist-info">
            <p class="playlist-title">${track.title}</p>
            <p class="playlist-artist">${track.artist}</p>
            <p class="playlist-artist"><img src="${track.albumArt}" style="width: 50px; height: 50px;"></p>
          </div>
        `;
        
        playlistContainer.appendChild(item);
      });
    }
    
    // 트랙 선택
    function selectTrack(index) {
      // 이전 선택 해제
      document.querySelectorAll('.playlist-item').forEach(item => {
        item.classList.remove('active');
      });
      
      // 새 트랙 선택
      document.querySelectorAll('.playlist-item')[index].classList.add('active');
      currentTrack = playlist[index];
      
      // UI 업데이트
      document.getElementById('track-title').textContent = currentTrack.title;
      document.getElementById('track-artist').textContent = currentTrack.artist;
      
      updateUI();
      updateStatus(`"${currentTrack.title}" 트랙이 선택되었습니다.`);
    }
    
    // 재생 요청
    function requestPlay() {
      if (!currentTrack) {
        alert('먼저 재생할 트랙을 선택해주세요.');
        return;
      }
      
      // 네이티브 앱에 재생 요청
      const audioInfo = {
        url: getAbsoluteUrl(currentTrack.url),
        title: currentTrack.title,
        artist: currentTrack.artist,
        albumArt: getAbsoluteUrl(currentTrack.albumArt)
      };
      
      if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onAudioPlay', audioInfo)
          .then(result => {
            if (result.success) {
              isPlaying = true;
              updateUI();
              updateStatus(`"${currentTrack.title}" 재생을 시작했습니다.`);
            } else {
              updateStatus(`재생 실패: ${result.error}`);
            }
          })
          .catch(error => {
            console.error('재생 요청 실패:', error);
            updateStatus(`재생 요청 실패: ${error}`);
          });
      } else {
        updateStatus('앱 환경에서만 사용 가능합니다.');
      }
    }
    
    // 일시정지 요청
    function requestPause() {
      if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onAudioPause')
          .then(result => {
            if (result.success) {
              isPlaying = false;
              updateUI();
              updateStatus('재생이 일시정지되었습니다.');
            } else {
              updateStatus(`일시정지 실패: ${result.error}`);
            }
          })
          .catch(error => {
            console.error('일시정지 요청 실패:', error);
            updateStatus(`일시정지 요청 실패: ${error}`);
          });
      } else {
        updateStatus('앱 환경에서만 사용 가능합니다.');
      }
    }
    
    // 정지 요청
    function requestStop() {
      if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onAudioStop')
          .then(result => {
            if (result.success) {
              isPlaying = false;
              updateUI();
              updateStatus('재생이 정지되었습니다.');
            } else {
              updateStatus(`정지 실패: ${result.error}`);
            }
          })
          .catch(error => {
            console.error('정지 요청 실패:', error);
            updateStatus(`정지 요청 실패: ${error}`);
          });
      } else {
        updateStatus('앱 환경에서만 사용 가능합니다.');
      }
    }
    
    // UI 업데이트
    function updateUI() {
      const playButton = document.getElementById('play-button');
      const pauseButton = document.getElementById('pause-button');
      const stopButton = document.getElementById('stop-button');
      
      if (!currentTrack) {
        playButton.disabled = true;
        pauseButton.disabled = true;
        stopButton.disabled = true;
      } else {
        playButton.disabled = isPlaying;
        pauseButton.disabled = !isPlaying;
        stopButton.disabled = !isPlaying;
      }
    }
    
    // 상태 메시지 업데이트
    function updateStatus(message) {
      document.getElementById('status-text').textContent = message;
    }
    
    // 절대 URL 생성
    function getAbsoluteUrl(relativePath) {
      if (relativePath.startsWith('http')) {
        return relativePath;
      }
      return window.location.origin + relativePath;
    }
    
    // 앱에서 보내는 상태 업데이트 처리
    function updatePlayerState(data) {
      try {
        const eventType = data.event;
        
        switch (eventType) {
          case 'stateChanged':
            isPlaying = data.playing || false;
            updateUI();
            if (data.playing) {
              updateStatus(`"${data.title || currentTrack?.title || '알 수 없음'}" 재생 중`);
            } else {
              updateStatus('재생이 일시정지되었습니다.');
            }
            break;
            
          case 'stop':
            isPlaying = false;
            updateUI();
            updateStatus('재생이 정지되었습니다.');
            break;
            
          default:
            console.log('알 수 없는 이벤트:', eventType, data);
        }
      } catch (error) {
        console.error('상태 업데이트 처리 실패:', error);
      }
    }
  </script>
</body>

3. 해당 오디오 재생은 http://...mp3 이런식으로 네트워크에서 요청을 통해 불러와서 재생을 해.
 - 따라서, 연속으로 다른 팟캐스트 이미지를 클릭하면서 연속적으로 오디오를 재생하려 하면 문제가 될 수 있어. 이 점을 고려해서 만들어줘.
 

생성 시 단계적으로 생각하세요(Let's think _step by step_)
```