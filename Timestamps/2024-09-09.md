
#### Day Planner
---
- [x] 하루 1회 프론트엔드 지식 및 Next.js 관련 기술 정리하기


#### Work
---
- [x] (0:30) 지도로 보는 김해 - 백엔드 / 페이징 마커 데이터 imgUrl innerjoin 추가
- [x] (2:00) 지도로 보는 김해 - 로컬 메뉴이미지, 로컬 마커이미지 추가
- [x] (2:30) 지도로 보는 김해 - 프론트엔드 / 메뉴 데이터 및 로컬 메뉴 이미지 연동작업 
- [x] (1:00) 지도로 보는 김해 - 프론트엔드 / 메뉴 데이터 및 로컬 마커 이미지 연동작업
- [x] (0:50) 지도로 보는 김해 - DB 테이블 카테고리별 마커 URL INSERT 작업
- [ ] (1:10)

#### Daily Log
---
> [!question]
> 1. ...
> 2. ...

> [!Ideas]
> 1. ...
> 2. ...


#### 임시저장 (지도로 보는 김해 : 2024-09-09)

```tsx
"use client";

import styles from "./GimhaeShowMapClient.module.scss";
import { useEffect, useLayoutEffect, useRef, useState } from "react";
import { useRecoilState } from "recoil";
import {
  ppltnCntHighState,
  ppltnCntLowState,
  ppltnCntMediumState,
  ppltnCntModeratelyHighState,
  ppltnCntModeratelyLowState,
  selectGMapDepth2MainMenuState,
  selectGMapDepth2SubMenuState,
  selectGMapDepth3MainMenuState,
  selectGMapDepth3SubMenuState,
} from "@/recoil/gMap/gMapState";
import BaseNaverMap from "@/components/map/naverMap/BaseNaverMap/BaseNaverMap";
import {
  getNewNaverMapInstance,
  setNewNaverInfoWindow,
  setNewNaverMarker,
  setNewNaverPolygon,
} from "@/utils/map/naverMap/shape/naverMapShapeUtils";
import useGeoLocation, {
  GeoLocationProps,
} from "@/hooks/common/map/useGeoLocation";
import {
  closeInfoWindowEventListener,
  setNaverMapEventListener,
} from "@/utils/map/naverMap/eventListener/naverMapEventListenerUtils";
import { contentToString } from "@/utils/common/common";
import {
  getCurPolygonOption,
  getGMapNaverMapMarkerIcon,
  getGMapPolygonFillColorGroup,
  gMapIncludeBoundaryAggregation,
} from "./option/option";
import {
  GimhaeShowMarkerPopup,
  GimhaeShowPolygonPopup,
} from "./component/infoWindow/GimhaeShowPolygonPopup";
import { NaverPolygonOptionInterface } from "@/types/common/map/naverMap";
import {
  gimhaeCenterLatLng,
  transformEPSG5179Coords,
} from "@/utils/map/common/commonMapUtils";
import Button from "@/components/common/Button/Button";
import { RiLineChartFill, RiMapPin2Line } from "react-icons/ri";
import DetailGimhaeShowMapSection from "./component/detailSection/DetailGimhaeShowMapSection";
import { TableHeader } from "@/components/common/Table/Table";
import {
  CLOSE_POPUP_BTN_ID,
  NAVER_MARKER_TOP_OFFSET,
  naverMapInfoWindowOption,
} from "@/utils/map/naverMap/naverMapUtils";
import { AdmdstGeomDetailResponse } from "@/types/common/admdstGeom/admdstGeomType";
import { GeometryCoordinatesInterface } from "@/types/common/map/commonMap";
import { useGetPplAdmdstAgePpltnList } from "@/hooks/portal/gMap/useGetPplAdmdstAgePpltnList";
import Loading from "@/components/common/Loading/Loading";
import { useGetMapGhMarkerList } from "@/hooks/portal/gMap/useGetMapGhMarkerList";
import { AuthMenuTreeResponse } from "@/types/common/MenuType";
import {
  MapGhDetailPageResponse,
  MapGhMarkerResponse,
  MapGhPageResponse,
  SearchMapGhCommand,
} from "@/types/portal/gMap/gMapType";
import { useGetMapGhMarkerPage } from "@/hooks/portal/gMap/useGetMapGhMarkerPage";

// 실제 사용 인터페이스
interface IProps {
  admdstGeomAllList: AdmdstGeomDetailResponse[] | null;
}

interface GimhaePolygonGeomInterface {
  admdstCd: string;
  admdstNm: string;
  geom: GeometryCoordinatesInterface[][];
}

export default function GimhaeShowMapClient({ admdstGeomAllList }: IProps) {
  /**
   * @name isMounted : 렌더링 -> 최초 마운트 확인용도
   * @name naverMapRef : 네이버 맵 element 접근을 위한 ref 객체
   * @name naverMap : 네이버 맵 초기세팅이 완료됨을 다른 useEffect에 알리기 위한 요소 (ref는 다른 컴포넌트에 props 전달 시 zoom과 같은 조작이 불가)
   * @name openInfoWindows : selectMapDepth3MainMenuState 변경에 따라(추가 변돌될 수 있음) 현재 띄워져있는 infoWindow를 지우기 위해 관리
   * @name infoWindowsRef : InfoWindow들을 관리할 배열
   */
  const [isMounted, setIsMounted] = useState<boolean>(false);
  const [naverMap, setNaverMap] = useState<any | null>(null);
  const openInfoWindowsRef = useRef<any | null>(null);
  const naverMapRef = useRef<any | null>(null);
  const infoWindowsRef = useRef<any[]>([]);

  const boundaryZoomLevel = 18;
  const [loadingInfoWindow, setLoadingInfoWindow] = useState<boolean>(false);

  /**
   * @name recoil요소 : recoil state 불러오기 및 세팅 (타 페이지 컴포넌트에서 전역 관리를 위함)
   */
  const [selectMapDepth2MainMenuState, setSelectMapDepth2MainMenuState] =
    useRecoilState(selectGMapDepth2MainMenuState);
  const [selectMapDepth2SubMenuState, setSelectMapDepth2SubMenuState] =
    useRecoilState(selectGMapDepth2SubMenuState);
  const [selectMapDepth3MainMenuState, setSelectMapDepth3MainMenuState] =
    useRecoilState(selectGMapDepth3MainMenuState);
  const [selectMapDepth3SubMenuState, setSelectMapDepth3SubMenuState] =
    useRecoilState(selectGMapDepth3SubMenuState);

  const [ppltnCntLow, setPpltnCntLowState] = useRecoilState(ppltnCntLowState);
  const [ppltnCntModeratelyLow, setPpltnCntModeratelyLowState] = useRecoilState(
    ppltnCntModeratelyLowState
  );
  const [ppltnCntMedium, setPpltnCntMediumState] =
    useRecoilState(ppltnCntMediumState);
  const [ppltnCntModeratelyHigh, setPpltnCntModeratelyHighState] =
    useRecoilState(ppltnCntModeratelyHighState);
  const [ppltnCntHigh, setPpltnCntHighState] =
    useRecoilState(ppltnCntHighState);

  /**
   * @name loadLocation : 사용자 위치 정보를 불러오는 useGeoLocation hooks 사용
   */
  const [loadLocation, setLoadLocation] = useState<GeoLocationProps | null>(
    null
  );
  const location = useGeoLocation();

  /**
   * @name gimhaePolygonGeoms
   * @description polygon 데이터 필터링 : 필터링된 데이터를 저장
   *
   * @name gimhaePolygonGeomInstances
   * @description selectMapDepth3MainMenuState 변경 시 마다, 폴리곤을 지웠다가 다시 그리기 위해 사용
   **/
  const [gimhaePolygonGeoms, setGimhaePolygonGeoms] = useState<
    GimhaePolygonGeomInterface[] | null
  >(null);
  const [gimhaePolygonGeomInstances, setGimhaePolygonGeomInstances] = useState<
    any[] | null
  >(null);

  const gimhaePolygonGeomInstancesRef = useRef<any>(null);

  /**
   * @name markerInstancesRef
   * @description selectMapDepth3SubMenuState 변경 시 마다, 마커를 지웠다가 다시 그리기 위해 사용
   *
   * @name markersRef
   * @description 마커들을 관리할 배열
   *
   * @name markerPagingSearchOption
   * @description 마커 페이징 옵션
   *
   * @name markerQuery
   * @description 마커 데이터 쿼리
   *
   * @name markerPagingQuery
   * @description 마커 테이블 정보 쿼리
   **/

  const markerInstancesRef = useRef<any[]>([]);
  const markersRef = useRef<any[]>([]);
  const [markerPagingSearchOption, setMarkerPagingSearchOption] =
    useState<SearchMapGhCommand>({
      page: 0,
      size: 10,
      sort: "rowId",
      orderBy: "desc",
      ctgryCd: null,
      mapGhSearchType: "ALL",
      searchKeyWord: "",
    });

  const markerQuery = useGetMapGhMarkerList(selectMapDepth3SubMenuState);
  const markerPagingQuery = useGetMapGhMarkerPage(
    markerPagingSearchOption,
    selectMapDepth3SubMenuState
  );

  /**
   * @name isDetailSectionOpen
   * @description 상세데이터보기 영역 오픈여부 결정 (상세데이터 보기)
   *
   * @name detailSectionCloseBtnRef
   * @description 상세데이터보기 닫기버튼에 해당하는 ref (자동으로 포커스 이동)
   *
   * @name detailDataShowBtnRef
   * @description 상세데이터보기 버튼에 해당하는 ref (자동으로 포커스 복귀시키기 위함)
   *
   * @name returnDetailSectionCloseBtnElement
   * @description 상세데이터보기 닫기버튼 클릭 후 자동으로 포커스를 복귀시킬 element로, ref는 string이라 안먹어서, element 자체를 리턴받아야함
   * @description infowindow 내의 버튼에 해당
   */
  const [isDetailSectionOpen, setIsDetailSectionOpen] =
    useState<boolean>(false);
  const detailSectionCloseBtnRef = useRef<HTMLButtonElement | null>(null);
  const detailDataShowBtnRef = useRef<HTMLButtonElement | null>(null);

  const [
    returnDetailSectionCloseBtnElement,
    setReturnDetailSectionCloseBtnElement,
  ] = useState<HTMLButtonElement | null>(null);

  /**
   * @name tableHeader
   * @description dummy
   *
   * @name tableData
   * @description dummy
   */
  const tableHeader: TableHeader[] = [
    {
      name: "순번",
      value: "rowId",
      width: "10%",
      accessFn: (item: MapGhPageResponse, idx: number) => {
        return <div className="pc">{item.rowId?.toLocaleString()}</div>;
      },
    },
    {
      name: "이름",
      value: "fcltNm",
      width: "20%",
      accessFn: (item: MapGhPageResponse, idx: number) => {
        return (
          <>
            <div className={`pc ${styles.tr_fac_nm}`}>{item.fcltNm}</div>
            <div className={`mobile ${styles.tr_fac_nm}`}>{item.fcltNm}</div>
          </>
        );
      },
    },
    {
      name: "주소",
      value: "roadNmAddr",
      width: "70%",
      accessFn: (item: MapGhPageResponse, idx: number) => {
        return (
          <>
            <div className={`pc ${styles.pc_tr_addr}`}>
              <span>{item.roadNmAddr || item.lotnoAddr}</span>
              <button
                onClick={() => {
                  if (!markerQuery.data) return;
                  setLoadingInfoWindow(true);

                  // 세부 사항 섹션 닫기 및 infoWindow 닫기 버튼에 포커스
                  setIsDetailSectionOpen(false);
                  const map = naverMapRef.current;
                  const markerData = item; // 클릭된 아이템의 데이터

                  // 새로운 마커 데이터 설정
                  const newMarkerData = markerData;
                  const naverMarkerOption =
                    getGMapNaverMapMarkerIcon(newMarkerData);

                  // 새로운 마커 생성
                  const newMarker = setNewNaverMarker(
                    map,
                    "LATLNG",
                    {
                      lat: Number(newMarkerData.lat),
                      lng: Number(newMarkerData.lot),
                    },
                    naverMarkerOption
                  );

                  // 새로운 infoWindow 생성
                  const newInfoWindow = setNewNaverInfoWindow(
                    naverMapInfoWindowOption()
                  );
                  if (newInfoWindow) {
                    newInfoWindow.setContent(
                      contentToString(
                        GimhaeShowMarkerPopup(
                          selectMapDepth3SubMenuState!.menuNm,
                          newMarkerData.fcltNm,
                          newMarkerData.roadNmAddr || null,
                          newMarkerData.lotnoAddr || null
                        )
                      )
                    );
                  }

                  // 새로운 마커와 infoWindow를 refs에 추가
                  markersRef.current.push(newMarker);
                  markerInstancesRef.current.push(newMarker);
                  infoWindowsRef.current.push(newInfoWindow);

                  // 비동기적으로 지도 중심과 줌 레벨 설정
                  map.panTo(newMarker.getPosition(), {
                    duration: 200, // 애니메이션 설정
                  });

                  // `panTo` 애니메이션 완료 후 줌 레벨 설정
                  setTimeout(() => {
                    map.setZoom(boundaryZoomLevel, false); // 줌 레벨 설정
                  }, 300); // `panTo` 애니메이션이 완료된 후 설정

                  // infoWindow 열기
                  setTimeout(() => {
                    setLoadingInfoWindow(false);

                    newInfoWindow!.open(map, newMarker);
                    openInfoWindowsRef.current = newInfoWindow;
                    closeInfoWindowEventListener(newInfoWindow!, () => {});

                    const infoWindowCloseBtnElement: HTMLButtonElement | null =
                      document.querySelector(`#${CLOSE_POPUP_BTN_ID}`);
                    if (infoWindowCloseBtnElement) {
                      infoWindowCloseBtnElement.focus();
                    }
                  }, 2000);
                }}
              >
                <RiMapPin2Line
                  size={16}
                  role="img"
                  aria-label={`${item.fcltNm} 위치보기`}
                />
                위치보기
              </button>
            </div>
            <div className={`mobile ${styles.mobile_tr_addr}`}>
              <span>{item.roadNmAddr || item.lotnoAddr}</span>
              <button
                onClick={() => {
                  if (!markerQuery.data) return;
                  setLoadingInfoWindow(true);

                  // 세부 사항 섹션 닫기 및 infoWindow 닫기 버튼에 포커스
                  setIsDetailSectionOpen(false);
                  const map = naverMapRef.current;
                  const markerData = item; // 클릭된 아이템의 데이터

                  // 새로운 마커 데이터 설정
                  const newMarkerData = markerData;
                  const naverMarkerOption =
                    getGMapNaverMapMarkerIcon(newMarkerData);

                  // 새로운 마커 생성
                  const newMarker = setNewNaverMarker(
                    map,
                    "LATLNG",
                    {
                      lat: Number(newMarkerData.lat),
                      lng: Number(newMarkerData.lot),
                    },
                    naverMarkerOption
                  );

                  // 새로운 infoWindow 생성
                  const newInfoWindow = setNewNaverInfoWindow(
                    naverMapInfoWindowOption()
                  );
                  if (newInfoWindow) {
                    newInfoWindow.setContent(
                      contentToString(
                        GimhaeShowMarkerPopup(
                          selectMapDepth3SubMenuState!.menuNm,
                          newMarkerData.fcltNm,
                          newMarkerData.roadNmAddr || null,
                          newMarkerData.lotnoAddr || null
                        )
                      )
                    );
                  }

                  // 새로운 마커와 infoWindow를 refs에 추가
                  markersRef.current.push(newMarker);
                  markerInstancesRef.current.push(newMarker);
                  infoWindowsRef.current.push(newInfoWindow);

                  // 비동기적으로 지도 중심과 줌 레벨 설정
                  map.panTo(newMarker.getPosition(), {
                    duration: 200, // 애니메이션 설정
                  });

                  // `panTo` 애니메이션 완료 후 줌 레벨 설정
                  setTimeout(() => {
                    map.setZoom(boundaryZoomLevel, false); // 줌 레벨 설정
                  }, 300); // `panTo` 애니메이션이 완료된 후 설정

                  // infoWindow 열기
                  setTimeout(() => {
                    setLoadingInfoWindow(false);

                    newInfoWindow!.open(map, newMarker);
                    openInfoWindowsRef.current = newInfoWindow;
                    closeInfoWindowEventListener(newInfoWindow!, () => {});

                    const infoWindowCloseBtnElement: HTMLButtonElement | null =
                      document.querySelector(`#${CLOSE_POPUP_BTN_ID}`);
                    if (infoWindowCloseBtnElement) {
                      infoWindowCloseBtnElement.focus();
                    }
                  }, 2000);
                }}
              >
                <RiMapPin2Line
                  size={14}
                  role="img"
                  aria-label={`${item.fcltNm} 위치보기`}
                />
                위치보기
              </button>
            </div>
          </>
        );
      },
    },
  ];
  const [tableData, setTableData] = useState<MapGhDetailPageResponse | null>(
    null
  );

  /**
   * @name admdstAgePpltnQuery
   * @description 인구/가구수 데이터 불러오기 hook
   */
  const admdstAgePpltnQuery = useGetPplAdmdstAgePpltnList(null);

  /**
   * @name handleDetailSectionOpen()
   * @description polygon infoWindow 내 버튼 클릭 시 상세 section을 열고, 포커스를 이동시키는 함수
   */
  const handleDetailSectionOpen = () => {
    setIsDetailSectionOpen(true);

    if (detailSectionCloseBtnRef && detailSectionCloseBtnRef.current) {
      detailSectionCloseBtnRef.current.focus();
    }
  };

  /**
   * @name handleZoomLevelChange()
   * @description 이 함수는 지도의 줌 레벨이 변경될 때 InfoWindow의 위치를 조정하여, 마커 위에 올바르게 표시되도록 하는 함수
   * 마커로부터 @name NAVER_MAKER_TOP_OFFSET 픽셀만큼 올려야 하므로, 위경도값을 픽셀로 변환해서 offset 변화를 준 다음, 그 값을 지도좌표로 변환하여 infowindow 출력위치를 업데이트 한다.
   */
  const handleZoomLevelChange = () => {
    // 지도의 줌 레벨이 변경될 때 InfoWindow의 위치를 조정하여, 마커 위에 올바르게 표시
    if (infoWindowsRef.current.length > 0) {
      // 현재 infoWindowsRef에 등록된 모든 InfoWindow를 반복 처리합니다
      infoWindowsRef.current.forEach((infoWindow, idx) => {
        if (infoWindow && markersRef.current[idx]) {
          // 마커의 현재 위치를 가져옵니다
          const markerLatLng = new naver.maps.LatLng(
            markersRef.current[idx].getPosition().lat(), // 마커의 위도
            markersRef.current[idx].getPosition().lng() // 마커의 경도
          );

          // 좌표를 픽셀로 변환합니다
          const projection = naverMapRef.current.getProjection(); // 현재 지도의 투영 객체를 가져옵니다
          const markerPixelPosition =
            projection.fromCoordToOffset(markerLatLng); // 좌표를 픽셀 위치로 변환

          // 픽셀 위치를 조정합니다
          const adjustedPixelPosition = new naver.maps.Point(
            markerPixelPosition.x, // x축 좌표는 변경하지 않습니다
            markerPixelPosition.y - NAVER_MARKER_TOP_OFFSET // y축 좌표를 NAVER_MARKER_TOP_OFFSET만큼 위로 이동
          );

          // 조정된 픽셀 위치를 다시 좌표로 변환합니다
          const newLatLng = projection.fromOffsetToCoord(adjustedPixelPosition); // 픽셀 위치를 지도 좌표로 변환

          // InfoWindow의 위치를 업데이트합니다
          infoWindow.setPosition(newLatLng); // 새로운 좌표로 InfoWindow의 위치를 설정
        }
      });
    }
  };

  /** -------------------------------------------------------------------------------------------------------------------------------------------------------
   * @name useEffect
   * @description 초기 렌더링 시, naverMapInstance가 2회 생성되는 것을 방지 (isMounted 사용)
   */
  useEffect(() => {
    if (!isMounted) {
      setIsMounted(true);
    }
  }, []);

  /**
   * @name useEffect
   * @description gimhaePolygonGeoms 데이터 세팅
   */
  useEffect(() => {
    if (!admdstGeomAllList) return;
    const newGimhaePolygonGeoms: GimhaePolygonGeomInterface[] =
      admdstGeomAllList.map((admdstGeomData: AdmdstGeomDetailResponse) => {
        const admdstNm = admdstGeomData.admdstNm;
        const admdstCd = admdstGeomData.admdstCd;
        const parseGeom: GeometryCoordinatesInterface[][] = JSON.parse(
          admdstGeomData.geom as string
        ).map((oDD: number[][]) => {
          return oDD.map((tDD: number[]) => {
            const centerEPSG4326Coord = transformEPSG5179Coords(tDD[0], tDD[1]);
            return centerEPSG4326Coord;
          });
        });

        return {
          admdstNm,
          admdstCd,
          geom: parseGeom,
        };
      });

    setGimhaePolygonGeoms(newGimhaePolygonGeoms);
  }, [admdstGeomAllList]);

  /**
   * @name useEffect
   * @description 사용자 현재위치 세팅
   */
  useEffect(() => {
    if (location) {
      setLoadLocation(location);
    }
  }, [location]);

  /**
   * @name useEffect
   * @description isMounted 초기화에 따른 네이버 지도 인스턴스 초기화(이렇게 분리안하면 로고2개뜸)
   */
  useEffect(() => {
    if (isMounted) {
      const map = getNewNaverMapInstance(
        loadLocation && loadLocation.coordinates
          ? loadLocation.coordinates
          : gimhaeCenterLatLng,
        isMounted
      ); // 네이버 지도 인스턴스
      naverMapRef.current = map;
      setNaverMap(map);

      /**
       * @name zoom_changed
       */
      naver.maps.Event.addListener(
        naverMapRef.current,
        "zoom_changed",
        handleZoomLevelChange
      );
    }
  }, [isMounted]);

  /**
   * @name useEffect
   * @description 인구/가구 변경 (polygon 색 변경하거나 삭제 후 다시 그림)
   */
  // useEffect(() => {
  //   if (
  //     !isMounted ||
  //     !naverMap ||
  //     !naverMapRef ||
  //     !naverMapRef.current ||
  //     !gimhaePolygonGeoms ||
  //     !admdstAgePpltnQuery.data ||
  //     !selectMapDepth3MainMenuState
  //   )
  //     return;

  //   // const currentZoomLevel = naverMap.getZoom();
  //   const admdstAgePpltnData = admdstAgePpltnQuery.data;

  //   // 기존 폴리곤 제거
  //   if (gimhaePolygonGeomInstances && gimhaePolygonGeomInstances.length > 0) {
  //     gimhaePolygonGeomInstances.forEach((polygon) => polygon.setMap(null));
  //     setGimhaePolygonGeomInstances(null);
  //   }

  //   // 인구/가구 하위메뉴 depth3 메뉴 선택 시 오픈된 infowindow 닫기
  //   if (openInfoWindowsRef.current) {
  //     openInfoWindowsRef.current.close();
  //   }

  //   // 새로운 폴리곤 추가
  //   const newNaverPolygonInstances = gimhaePolygonGeoms.map(
  //     (polygon: GimhaePolygonGeomInterface, idx: number) => {
  //       const curPolygonOption: NaverPolygonOptionInterface =
  //         getCurPolygonOption(
  //           selectMapDepth3MainMenuState,
  //           polygon,
  //           admdstAgePpltnQuery.data,
  //           ppltnCntLow,
  //           ppltnCntModeratelyLow,
  //           ppltnCntMedium,
  //           ppltnCntModeratelyHigh,
  //           ppltnCntHigh
  //         );

  //       // polygon instance 생성
  //       const newNaverPolygonInstance = setNewNaverPolygon(
  //         naverMapRef.current,
  //         polygon.geom,
  //         curPolygonOption
  //       );

  //       // infowindow 인스턴스 추가
  //       const infoWindow = setNewNaverInfoWindow(naverMapInfoWindowOption());

  //       // polygon hover 시 stroke style 변경
  //       setNaverMapEventListener(newNaverPolygonInstance, "mouseover", () => {
  //         newNaverPolygonInstance.setOptions({
  //           ...curPolygonOption,
  //           paths: polygon.geom,
  //           strokeColor: "#111",
  //           strokeWeight: 2,
  //           zIndex: 1,
  //         });
  //       });

  //       // polygon hover 해제 시 stroke style 변경
  //       setNaverMapEventListener(newNaverPolygonInstance, "mouseout", () => {
  //         newNaverPolygonInstance.setOptions({
  //           ...curPolygonOption,
  //           paths: polygon.geom,
  //         });
  //       });

  //       // infowindow 이벤트 리스너 추가
  //       setNaverMapEventListener(newNaverPolygonInstance, "click", (event) => {
  //         if (!infoWindow) {
  //           alert("데이터가 없어 팝업을 띄울 수 없습니다");
  //           return;
  //         }

  //         if (infoWindow.getMap()) {
  //           infoWindow.close();
  //         } else {
  //           // 팝업 전달 데이터 세팅
  //           const admdstNm = polygon.admdstNm
  //             .replace("경상남도 김해시", "")
  //             .replace(/\s+/g, "");
  //           const admdstCd = polygon.admdstCd;

  //           // 클릭된 데이터에 대한 쿼리 데이터 필터링
  //           const clickPplAdmdstAgePpltn =
  //             admdstAgePpltnData.pplAdmdstAgePpltnList.find(
  //               (data) => data.dongCdNm === admdstNm
  //             )!.dataList;
  //           const clickPplStdgGndrAgePpltn =
  //             admdstAgePpltnData.pplStdgGndrAgeSnglList.find(
  //               (data) => data.dongNm === admdstNm
  //             )!.dataList;

  //           // 팝업 전달 데이터 세팅 (2) : 실제 표시될 데이터의 수치
  //           const row1Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[0])
  //           )!.ppltnCnt;
  //           const row2Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[1])
  //           )!.ppltnCnt;
  //           const row3Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[2])
  //           )!.ppltnCnt;
  //           const row4Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[3])
  //           )!.ppltnCnt;
  //           const row5Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[4])
  //           )!.ppltnCnt;
  //           const row6Cnt = clickPplAdmdstAgePpltn.find((data) =>
  //             data.ageCdNm.includes(gMapIncludeBoundaryAggregation[5])
  //           )!.ppltnCnt;
  //           const row7Cnt = clickPplStdgGndrAgePpltn.find(
  //             (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[6]
  //           )!.totHhCnt;
  //           const row8Cnt = clickPplStdgGndrAgePpltn.find(
  //             (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[7]
  //           )!.totHhCnt;

  //           // info window 오픈 및 오픈 위치 변경
  //           infoWindow.open(naverMapRef.current, {
  //             lat: event.coord.lat(),
  //             lng: event.coord.lng(),
  //           });

  //           // info window의 내부 content
  //           infoWindow.setContent(
  //             contentToString(
  //               GimhaeShowPolygonPopup(
  //                 admdstNm,
  //                 admdstCd,
  //                 row1Cnt,
  //                 row2Cnt,
  //                 row3Cnt,
  //                 row4Cnt,
  //                 row5Cnt,
  //                 row6Cnt,
  //                 row7Cnt,
  //                 row8Cnt
  //               )
  //             )
  //           );

  //           // 오픈된 info window state 변경
  //           openInfoWindowsRef.current = infoWindow;

  //           // 이벤트 위임 설정
  //           const polygonDetailBtnElement: HTMLButtonElement | null =
  //             document.querySelector("#showDetailData_gMapMain_polygon");

  //           if (polygonDetailBtnElement) {
  //             setReturnDetailSectionCloseBtnElement(polygonDetailBtnElement);
  //             polygonDetailBtnElement.addEventListener(
  //               "click",
  //               handleDetailSectionOpen
  //             );
  //           }

  //           // infowindow 닫기 이벤트리스너 추가
  //           closeInfoWindowEventListener(infoWindow, () => {
  //             // error calllback
  //             if (polygonDetailBtnElement) {
  //               polygonDetailBtnElement.removeEventListener(
  //                 "click",
  //                 handleDetailSectionOpen
  //               );
  //             }
  //           });
  //         }
  //       });

  //       return newNaverPolygonInstance;
  //     }
  //   );

  //   // 그려진 polygon instance 관리 (state로)
  //   setGimhaePolygonGeomInstances(newNaverPolygonInstances);

  //   // 경계값 세팅 (gMapLegend)
  //   if (admdstAgePpltnData) {
  //     const roundToThousands = (num: number) => {
  //       if (num < 10000) {
  //         // 작은 값일 경우 끝자리가 한 자리만 0이 되도록 조정
  //         return Math.round(num / 100) * 100;
  //       } else {
  //         // 기본 로직: 끝자리를 세 자리 0으로 맞춤
  //         return Math.round(num / 1000) * 1000;
  //       }
  //     };

  //     // 내가 어느메뉴에 있는지 확인
  //     const menuNm = selectMapDepth3MainMenuState.menuNm;

  //     // api로 응답받은 ageCdNm별, 가장 최대값을 가지는 행정동 반환 (1인가구수 제외)
  //     const maxPplAdmdstAgePpltnList =
  //       admdstAgePpltnData.maxPplAdmdstAgePpltnList;

  //     // api로 응답받은 ageCdNm별, 가장 최대값을 가지는 행정동 반환 (1인가구수)
  //     const maxPplStdgGndrAgeSnglList =
  //       admdstAgePpltnData.maxPplStdgGndrAgeSnglList;

  //     // 5개 경계값 초기화
  //     let ppltnCntLow = 0;
  //     let ppltnCntModeratelyLow = 0;
  //     let ppltnCntMedium = 0;
  //     let ppltnCntModeratelyHigh = 0;
  //     let ppltnCntHigh = 0;
  //     let maxCount = 0;
  //     let dividedCount = 0;

  //     if (menuNm.includes(gMapIncludeBoundaryAggregation[0])) {
  //       // 총인구
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find(
  //         (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[0]
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm.includes(gMapIncludeBoundaryAggregation[1])) {
  //       // 0~4세
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
  //         data.ageCdNm.includes(gMapIncludeBoundaryAggregation[1])
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm.includes(gMapIncludeBoundaryAggregation[2])) {
  //       // 5~19세
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
  //         data.ageCdNm.includes(gMapIncludeBoundaryAggregation[2])
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm.includes(gMapIncludeBoundaryAggregation[3])) {
  //       // 20~39세
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
  //         data.ageCdNm.includes(gMapIncludeBoundaryAggregation[3])
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm.includes(gMapIncludeBoundaryAggregation[4])) {
  //       // 40~64세
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
  //         data.ageCdNm.includes(gMapIncludeBoundaryAggregation[4])
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm.includes(gMapIncludeBoundaryAggregation[5])) {
  //       // 65세 이상
  //       const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
  //         data.ageCdNm.includes(gMapIncludeBoundaryAggregation[5])
  //       );
  //       maxCount = filtedCurMenuMaxData!.ppltnCnt;
  //     } else if (menuNm === gMapIncludeBoundaryAggregation[7]) {
  //       // 1인 가구수(60세 이상)
  //       const filtedCurMenuMaxData = maxPplStdgGndrAgeSnglList.find(
  //         (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[7]
  //       );
  //       maxCount = filtedCurMenuMaxData!.totHhCnt;
  //     } else {
  //       // 1인 가구수
  //       const filtedCurMenuMaxData = maxPplStdgGndrAgeSnglList.find(
  //         (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[6]
  //       );
  //       maxCount = filtedCurMenuMaxData!.totHhCnt;
  //     }
  //     dividedCount = maxCount / 5;
  //     ppltnCntLow = roundToThousands(dividedCount); // 1st 구간
  //     ppltnCntModeratelyLow = roundToThousands(2 * dividedCount); // 2nd 구간
  //     ppltnCntMedium = roundToThousands(3 * dividedCount); // 3rd 구간
  //     ppltnCntModeratelyHigh = roundToThousands(4 * dividedCount); // 4th 구간
  //     ppltnCntHigh = roundToThousands(maxCount); // 5th 구간
  //     setPpltnCntLowState(ppltnCntLow);
  //     setPpltnCntModeratelyLowState(ppltnCntModeratelyLow);
  //     setPpltnCntMediumState(ppltnCntMedium);
  //     setPpltnCntModeratelyHighState(ppltnCntModeratelyHigh);
  //     setPpltnCntHighState(ppltnCntHigh);
  //   }

  //   /**
  //    * @name cleanUp
  //    * @description polygon, infowindow, infowindow 내 버튼 이벤트 리스너 제거
  //    */
  //   return () => {
  //     if (newNaverPolygonInstances) {
  //       newNaverPolygonInstances.forEach((polygonInstance) =>
  //         polygonInstance.setMap(null)
  //       );
  //     }

  //     if (openInfoWindowsRef.current) {
  //       openInfoWindowsRef.current.close();
  //     }

  //     const polygonDetailBtnElement = document.querySelector(
  //       "#showDetailData_gMapMain_polygon"
  //     );

  //     if (polygonDetailBtnElement) {
  //       polygonDetailBtnElement.removeEventListener(
  //         "click",
  //         handleDetailSectionOpen
  //       );
  //     }
  //   };
  // }, [
  //   isMounted,
  //   naverMap,
  //   gimhaePolygonGeoms,

  //   // query
  //   admdstAgePpltnQuery.data,

  //   // recoil
  //   selectMapDepth3MainMenuState,
  //   ppltnCntLow,
  //   ppltnCntModeratelyLow,
  //   ppltnCntMedium,
  //   ppltnCntModeratelyHigh,
  //   ppltnCntHigh,
  // ]);

  useEffect(() => {
    if (
      !isMounted ||
      !naverMap ||
      !naverMapRef ||
      !naverMapRef.current ||
      !gimhaePolygonGeoms ||
      !admdstAgePpltnQuery.data ||
      !selectMapDepth3MainMenuState
    )
      return;

    // const currentZoomLevel = naverMap.getZoom();
    const admdstAgePpltnData = admdstAgePpltnQuery.data;

    let newNaverPolygonInstances: any[] = [];

    // 새로운 폴리곤 추가
    const handleZoomChange = () => {
      // 기존 폴리곤 제거
      if (
        gimhaePolygonGeomInstancesRef.current &&
        gimhaePolygonGeomInstancesRef.current.length > 0
      ) {
        gimhaePolygonGeomInstancesRef.current.forEach((polygon: any) =>
          polygon.setMap(null)
        );

        gimhaePolygonGeomInstancesRef.current = null;
      }

      // 인구/가구 하위메뉴 depth3 메뉴 선택 시 오픈된 infowindow 닫기
      if (openInfoWindowsRef.current) {
        openInfoWindowsRef.current.close();
      }

      if (naverMap) {
        const currentZoomLevel = naverMap.getZoom();

        if (currentZoomLevel < boundaryZoomLevel) {
          newNaverPolygonInstances = gimhaePolygonGeoms.map(
            (polygon: GimhaePolygonGeomInterface, idx: number) => {
              const curPolygonOption: NaverPolygonOptionInterface =
                getCurPolygonOption(
                  selectMapDepth3MainMenuState,
                  polygon,
                  admdstAgePpltnQuery.data,
                  ppltnCntLow,
                  ppltnCntModeratelyLow,
                  ppltnCntMedium,
                  ppltnCntModeratelyHigh,
                  ppltnCntHigh
                );

              // polygon instance 생성
              const newNaverPolygonInstance = setNewNaverPolygon(
                naverMapRef.current,
                polygon.geom,
                curPolygonOption
              );

              // infowindow 인스턴스 추가
              const infoWindow = setNewNaverInfoWindow(
                naverMapInfoWindowOption()
              );

              // polygon hover 시 stroke style 변경
              setNaverMapEventListener(
                newNaverPolygonInstance,
                "mouseover",
                () => {
                  newNaverPolygonInstance.setOptions({
                    ...curPolygonOption,
                    paths: polygon.geom,
                    strokeColor: "#111",
                    strokeWeight: 2,
                    zIndex: 1,
                  });
                }
              );

              // polygon hover 해제 시 stroke style 변경
              setNaverMapEventListener(
                newNaverPolygonInstance,
                "mouseout",
                () => {
                  newNaverPolygonInstance.setOptions({
                    ...curPolygonOption,
                    paths: polygon.geom,
                  });
                }
              );

              // infowindow 이벤트 리스너 추가
              setNaverMapEventListener(
                newNaverPolygonInstance,
                "click",
                (event) => {
                  if (!infoWindow) {
                    alert("데이터가 없어 팝업을 띄울 수 없습니다");
                    return;
                  }

                  if (infoWindow.getMap()) {
                    infoWindow.close();
                  } else {
                    // 팝업 전달 데이터 세팅
                    const admdstNm = polygon.admdstNm
                      .replace("경상남도 김해시", "")
                      .replace(/\s+/g, "");
                    const admdstCd = polygon.admdstCd;

                    // 클릭된 데이터에 대한 쿼리 데이터 필터링
                    const clickPplAdmdstAgePpltn =
                      admdstAgePpltnData.pplAdmdstAgePpltnList.find(
                        (data) => data.dongCdNm === admdstNm
                      )!.dataList;
                    const clickPplStdgGndrAgePpltn =
                      admdstAgePpltnData.pplStdgGndrAgeSnglList.find(
                        (data) => data.dongNm === admdstNm
                      )!.dataList;

                    // 팝업 전달 데이터 세팅 (2) : 실제 표시될 데이터의 수치
                    const row1Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[0])
                    )!.ppltnCnt;
                    const row2Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[1])
                    )!.ppltnCnt;
                    const row3Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[2])
                    )!.ppltnCnt;
                    const row4Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[3])
                    )!.ppltnCnt;
                    const row5Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[4])
                    )!.ppltnCnt;
                    const row6Cnt = clickPplAdmdstAgePpltn.find((data) =>
                      data.ageCdNm.includes(gMapIncludeBoundaryAggregation[5])
                    )!.ppltnCnt;
                    const row7Cnt = clickPplStdgGndrAgePpltn.find(
                      (data) =>
                        data.ageCdNm === gMapIncludeBoundaryAggregation[6]
                    )!.totHhCnt;
                    const row8Cnt = clickPplStdgGndrAgePpltn.find(
                      (data) =>
                        data.ageCdNm === gMapIncludeBoundaryAggregation[7]
                    )!.totHhCnt;

                    // info window 오픈 및 오픈 위치 변경
                    infoWindow.open(naverMapRef.current, {
                      lat: event.coord.lat(),
                      lng: event.coord.lng(),
                    });

                    // info window의 내부 content
                    infoWindow.setContent(
                      contentToString(
                        GimhaeShowPolygonPopup(
                          admdstNm,
                          admdstCd,
                          row1Cnt,
                          row2Cnt,
                          row3Cnt,
                          row4Cnt,
                          row5Cnt,
                          row6Cnt,
                          row7Cnt,
                          row8Cnt
                        )
                      )
                    );

                    // 오픈된 info window state 변경
                    openInfoWindowsRef.current = infoWindow;

                    // 이벤트 위임 설정
                    const polygonDetailBtnElement: HTMLButtonElement | null =
                      document.querySelector(
                        "#showDetailData_gMapMain_polygon"
                      );

                    if (polygonDetailBtnElement) {
                      setReturnDetailSectionCloseBtnElement(
                        polygonDetailBtnElement
                      );
                      polygonDetailBtnElement.addEventListener(
                        "click",
                        handleDetailSectionOpen
                      );
                    }

                    // infowindow 닫기 이벤트리스너 추가
                    closeInfoWindowEventListener(infoWindow, () => {
                      // error calllback
                      if (polygonDetailBtnElement) {
                        polygonDetailBtnElement.removeEventListener(
                          "click",
                          handleDetailSectionOpen
                        );
                      }
                    });
                  }
                }
              );

              return newNaverPolygonInstance;
            }
          );

          // 그려진 polygon instance 관리 (state로)
          gimhaePolygonGeomInstancesRef.current = newNaverPolygonInstances;
        }
      }
    };

    // 경계값 세팅 (gMapLegend)
    if (admdstAgePpltnData) {
      const roundToThousands = (num: number) => {
        if (num < 10000) {
          // 작은 값일 경우 끝자리가 한 자리만 0이 되도록 조정
          return Math.round(num / 100) * 100;
        } else {
          // 기본 로직: 끝자리를 세 자리 0으로 맞춤
          return Math.round(num / 1000) * 1000;
        }
      };

      // 내가 어느메뉴에 있는지 확인
      const menuNm = selectMapDepth3MainMenuState.menuNm;

      // api로 응답받은 ageCdNm별, 가장 최대값을 가지는 행정동 반환 (1인가구수 제외)
      const maxPplAdmdstAgePpltnList =
        admdstAgePpltnData.maxPplAdmdstAgePpltnList;

      // api로 응답받은 ageCdNm별, 가장 최대값을 가지는 행정동 반환 (1인가구수)
      const maxPplStdgGndrAgeSnglList =
        admdstAgePpltnData.maxPplStdgGndrAgeSnglList;

      // 5개 경계값 초기화
      let ppltnCntLow = 0;
      let ppltnCntModeratelyLow = 0;
      let ppltnCntMedium = 0;
      let ppltnCntModeratelyHigh = 0;
      let ppltnCntHigh = 0;
      let maxCount = 0;
      let dividedCount = 0;

      if (menuNm.includes(gMapIncludeBoundaryAggregation[0])) {
        // 총인구
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find(
          (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[0]
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm.includes(gMapIncludeBoundaryAggregation[1])) {
        // 0~4세
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
          data.ageCdNm.includes(gMapIncludeBoundaryAggregation[1])
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm.includes(gMapIncludeBoundaryAggregation[2])) {
        // 5~19세
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
          data.ageCdNm.includes(gMapIncludeBoundaryAggregation[2])
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm.includes(gMapIncludeBoundaryAggregation[3])) {
        // 20~39세
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
          data.ageCdNm.includes(gMapIncludeBoundaryAggregation[3])
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm.includes(gMapIncludeBoundaryAggregation[4])) {
        // 40~64세
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
          data.ageCdNm.includes(gMapIncludeBoundaryAggregation[4])
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm.includes(gMapIncludeBoundaryAggregation[5])) {
        // 65세 이상
        const filtedCurMenuMaxData = maxPplAdmdstAgePpltnList.find((data) =>
          data.ageCdNm.includes(gMapIncludeBoundaryAggregation[5])
        );
        maxCount = filtedCurMenuMaxData!.ppltnCnt;
      } else if (menuNm === gMapIncludeBoundaryAggregation[7]) {
        // 1인 가구수(60세 이상)
        const filtedCurMenuMaxData = maxPplStdgGndrAgeSnglList.find(
          (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[7]
        );
        maxCount = filtedCurMenuMaxData!.totHhCnt;
      } else {
        // 1인 가구수
        const filtedCurMenuMaxData = maxPplStdgGndrAgeSnglList.find(
          (data) => data.ageCdNm === gMapIncludeBoundaryAggregation[6]
        );
        maxCount = filtedCurMenuMaxData!.totHhCnt;
      }
      dividedCount = maxCount / 5;
      ppltnCntLow = roundToThousands(dividedCount); // 1st 구간
      ppltnCntModeratelyLow = roundToThousands(2 * dividedCount); // 2nd 구간
      ppltnCntMedium = roundToThousands(3 * dividedCount); // 3rd 구간
      ppltnCntModeratelyHigh = roundToThousands(4 * dividedCount); // 4th 구간
      ppltnCntHigh = roundToThousands(maxCount); // 5th 구간
      setPpltnCntLowState(ppltnCntLow);
      setPpltnCntModeratelyLowState(ppltnCntModeratelyLow);
      setPpltnCntMediumState(ppltnCntMedium);
      setPpltnCntModeratelyHighState(ppltnCntModeratelyHigh);
      setPpltnCntHighState(ppltnCntHigh);
    }

    // 최초 로드 시 handleZoomChange를 수동으로 호출
    handleZoomChange();

    // 줌 레벨 변경 시마다 handleZoomChange 호출
    naverMap.addListener("zoom_changed", handleZoomChange);

    /**
     * @name cleanUp
     * @description polygon, infowindow, infowindow 내 버튼 이벤트 리스너 제거
     */
    return () => {
      if (newNaverPolygonInstances) {
        newNaverPolygonInstances.forEach((polygonInstance) =>
          polygonInstance.setMap(null)
        );
      }

      if (openInfoWindowsRef.current) {
        openInfoWindowsRef.current.close();
      }

      const polygonDetailBtnElement = document.querySelector(
        "#showDetailData_gMapMain_polygon"
      );

      if (polygonDetailBtnElement) {
        polygonDetailBtnElement.removeEventListener(
          "click",
          handleDetailSectionOpen
        );
      }
    };
  }, [
    isMounted,
    naverMap,
    gimhaePolygonGeoms,

    // query
    admdstAgePpltnQuery.data,

    // recoil
    selectMapDepth3MainMenuState,
    ppltnCntLow,
    ppltnCntModeratelyLow,
    ppltnCntMedium,
    ppltnCntModeratelyHigh,
    ppltnCntHigh,
  ]);

  useEffect(() => {
    if (!isMounted || !naverMapRef || !naverMapRef.current) return;

    // 오픈된 InfoWindow 닫기
    if (openInfoWindowsRef.current) {
      openInfoWindowsRef.current.close();
    }

    // 기존 마커 제거
    if (markerInstancesRef.current) {
      markerInstancesRef.current.forEach((marker) => {
        marker.setMap(null);
      });
      markerInstancesRef.current = [];
    }

    if (markerQuery.data && markerQuery.data.length > 200) {
      const naverMapGimhaeCenterLatLng = new naver.maps.LatLng(
        Number(gimhaeCenterLatLng.lat),
        Number(gimhaeCenterLatLng.lng)
      );
      naverMapRef.current.panTo(naverMapGimhaeCenterLatLng, {
        duration: 0,
      });

      // 중심이동 및 zoom 설정
      setTimeout(() => {
        naverMapRef.current.setZoom(boundaryZoomLevel, false);
      }, 100);
    }

    // 마커 데이터가 있고 줌 레벨이 16 이상일 때 바운더리 내 마커 표시
    const handleMarkers = () => {
      if (markerInstancesRef.current) {
        markerInstancesRef.current.forEach((marker) => {
          marker.setMap(null);
        });
        markerInstancesRef.current = [];
      }

      if (!markerQuery.data || !markerQuery.data.length) return;
      const zoomLevel = naverMapRef.current.getZoom();
      const bounds = naverMapRef.current.getBounds();

      let visibleMarkers: any[] = [];

      // 현재 zoomLevel >= 경계값 zoomLevel
      if (zoomLevel >= boundaryZoomLevel) {
        if (markerQuery.data.length > 200) {
          visibleMarkers = markerQuery.data.filter((marker) => {
            const latLng = new naver.maps.LatLng(
              Number(marker.lat),
              Number(marker.lot)
            );
            return bounds.hasLatLng(latLng);
          });
        } else {
          visibleMarkers = markerQuery.data;
        }
      } else {
        if (markerQuery.data.length > 200) {
          visibleMarkers = [];
        } else {
          visibleMarkers = markerQuery.data;
        }
      }

      const newNaverMarkerInstances: any[] = visibleMarkers.map(
        (marker, idx) => {
          const naverMarkerOption = getGMapNaverMapMarkerIcon(marker);

          const newNaverMarkerInstance = setNewNaverMarker(
            naverMapRef.current,
            "LATLNG",
            { lat: Number(marker.lat), lng: Number(marker.lot) },
            naverMarkerOption
          );

          const infoWindow = setNewNaverInfoWindow(naverMapInfoWindowOption());
          if (infoWindow && selectMapDepth3SubMenuState) {
            infoWindow.setContent(
              contentToString(
                GimhaeShowMarkerPopup(
                  selectMapDepth3SubMenuState.menuNm,
                  marker.fcltNm,
                  marker.roadNmAddr || null,
                  marker.lotnoAddr || null
                )
              )
            );
          }
          markersRef.current[idx] = newNaverMarkerInstance;
          infoWindowsRef.current[idx] = infoWindow;

          // 마커 클릭 이벤트 리스너
          setNaverMapEventListener(newNaverMarkerInstance, "click", () => {
            closeInfoWindowEventListener(infoWindow!, () => {});

            if (infoWindow) {
              if (infoWindow.getMap()) {
                infoWindow.close();
              } else {
                infoWindow.open(naverMapRef.current, {
                  lat: Number(marker.lat),
                  lng: Number(marker.lot),
                });
                openInfoWindowsRef.current = infoWindow;
              }
            }
          });

          return newNaverMarkerInstance;
        }
      );

      markerInstancesRef.current = newNaverMarkerInstances;
    };

    // 줌 레벨 또는 지도 이동 시 처리
    const handleMapEvents = () => {
      handleMarkers(); // 초기 마커 처리

      // 줌 레벨 변경 시
      naverMapRef.current.addListener("zoom_changed", () => {
        if (openInfoWindowsRef.current) {
          openInfoWindowsRef.current.close();
        }
        handleMarkers();
      });

      // 지도 이동 시 바운더리 내 마커만 표시
      naverMapRef.current.addListener("dragend", () => {
        handleMarkers();
      });
    };

    handleMapEvents();

    /**
     * @name cleanUp
     * @description 마커, infowindow, 리스너 정리
     */
    return () => {
      if (markerInstancesRef.current) {
        markerInstancesRef.current.forEach((marker) => marker.setMap(null));
      }
      if (openInfoWindowsRef.current) {
        openInfoWindowsRef.current.close();
      }
    };
  }, [
    isMounted,
    selectMapDepth3SubMenuState,
    markerQuery.data,
    markerPagingQuery.data,
    markerPagingSearchOption.page,
  ]);

  useEffect(() => {
    if (selectMapDepth3SubMenuState && markerPagingQuery.data) {
      const markerDataPage: MapGhDetailPageResponse = markerPagingQuery.data;
      setTableData(markerDataPage);
    }
  }, [isMounted, selectMapDepth3SubMenuState, markerPagingQuery.data]);

  return (
    <>
      <Loading
        open={
          admdstAgePpltnQuery.isLoading ||
          markerQuery.isLoading ||
          markerPagingQuery.isLoading ||
          loadingInfoWindow
        }
        text={
          admdstAgePpltnQuery.isLoading
            ? "인구/가구별 데이터를 불러오고 있습니다."
            : markerQuery.isLoading
              ? "마커 데이터를 불러오고 있습니다."
              : markerPagingQuery.isLoading
                ? "테이블 정보를 불러오고 있습니다."
                : "팝업에 띄울 데이터를 준비 중입니다."
        }
      />
      {/* 상세데이터 버튼 */}
      <div className={`${styles.show_dtd_btn_box}`}>
        <Button
          title="상세 데이터 보기"
          id={`showDetailData_gMapMain`}
          color="blue"
          ref={detailDataShowBtnRef}
          onClickEvent={() => {
            // 상세데이터 창 오픈
            setIsDetailSectionOpen(true);

            // 포커스 이동
            if (detailSectionCloseBtnRef && detailSectionCloseBtnRef.current) {
              detailSectionCloseBtnRef.current.focus();
            }

            if (detailDataShowBtnRef && detailDataShowBtnRef.current) {
              // return 포커스 대상 선정 : ref
              setReturnDetailSectionCloseBtnElement(
                detailDataShowBtnRef.current
              );
            } else {
              // ref를 못찾았으면, 현재 버튼의 element로 설정
              const detailDataShowBtnElement: HTMLButtonElement | null =
                document.querySelector("#showDetailData_gMapMain");

              if (detailDataShowBtnElement) {
                setReturnDetailSectionCloseBtnElement(detailDataShowBtnElement);
              }
            }
          }}
        >
          <RiLineChartFill size={22} role="img" aria-label="차트 아이콘" />
          상세데이터 보기
        </Button>
      </div>

      {/* 지도  */}
      <BaseNaverMap
        ref={naverMapRef}
        accessPage="gMap"
        naverMap={naverMap}
      ></BaseNaverMap>

      {/* 상세데이터보기 다이얼로그 */}
      <DetailGimhaeShowMapSection
        isDetailSectionOpen={isDetailSectionOpen}
        setIsDetailSectionOpen={setIsDetailSectionOpen}
        ref={detailSectionCloseBtnRef}
        returnDetailSectionCloseBtnElement={returnDetailSectionCloseBtnElement}
        selectMapDepth3MainMenuState={selectMapDepth3MainMenuState}
        selectMapDepth3SubMenuState={selectMapDepth3SubMenuState}
        admdstAgePpltnQueryIsLoading={admdstAgePpltnQuery.isLoading}
        admdstAgePpltnQueryData={
          admdstAgePpltnQuery.data ? admdstAgePpltnQuery.data : null
        }
        tableHeader={tableHeader}
        tableData={tableData}
        setMarkerPagingSearchOption={setMarkerPagingSearchOption}
      />
    </>
  );
}

```

