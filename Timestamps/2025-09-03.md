
#### Work
---
- [x] 문제해결필요: 베이직 6개월 -> 프리미엄 6개월 시 정기결제가 2개가 되는 문제
	- changeType이 업그레이드일 때 subscriptionUpgrade에 케이스를 추가해야 함
- [ ] 문제해결필요: 베이직 1개월 -> 베이직 6개월 | 프리미엄 1개월 -> 프리미엄 6개월 적용 시 유저정보 조회용 me API가 FREE | FREE_PLAN으로 날아오는 이유
- [ ] shadcn-ui Dialog open 상태에서 toast 발생 시 toast 창을 조작 가능하도록 변경 (pointer-event)
- [ ] API 중복호출 의심되는 로직 보완 
- [ ] 결제관련코드 가독성 완화
- [ ] 결제 총 3단계에 대한 로딩 컴포넌트 반영
- [ ] 디버깅 코드 제거


> 다시 롤백할 코드
```tsx
import { useCallback, useEffect, useState } from 'react'  
import { toast } from 'sonner'  
import { useOpenMembershipDialog } from '@/pages/my-page/hooks/modal/use-open-membership-dialog.ts'  
import { useAuthStore } from '@/store/use-auth-store.ts'  
import type { DeviceType } from '@/pages/auth/types'  
import { useQueryClient } from '@tanstack/react-query'  
import { useGetUserInfo } from '@/hooks/use-get-user-info-query.ts'  
import { usePaymentInitiate } from '@/pages/my-page/hooks/action/use-payment-initiate-action.ts'  
import { useVerifyGoogleAction } from '@/pages/my-page/hooks/action/use-verify-google-action.ts'  
import type {  
  BasePlanTypeEnum,  
  InnerPaymentPlanId,  
  PaymentInitiationRequest,  
  PaymentInitiationResponse,  
  PaymentPlatformEnum,  
  PaymentVerificationCommonRequest,  
  ProductTypeEnum,  
} from '@/pages/my-page/types'  
import { getCurrentMembershipPlan } from '@/pages/my-page/utils.ts'  
import { useGooglePayment } from '@/pages/my-page/hooks/payment/use-google-payment.ts'  
import { useAppStorePayment } from './use-app-store-payment'  
  
// Google Payment Hook의 타입과 동일하게 유지  
interface PaymentOption {  
  id: InnerPaymentPlanId  
  membershipType: 'PREMIUM' | 'BASIC'  
  plan: 'monthly' | 'sixMonthly'  
}  
  
interface PurchaseResult {  
  success: boolean  
  status?: 'success' | 'pending' | 'failed' | 'cancelled' | 'restored'  
  message?: string  
  error?: string  
  errorMessage?: string  
  errorCode?: string  
  debug?: any  
  availableProducts?: string[]  
  availableBasePlans?: string[]  
  platform?: string  
  receiptData?: string  
  productId?: string  
  transactionId?: string  
  secretKey?: string  
  fcmToken?: string  
  basePlanId?: string  
}  
  
export function useMembershipPayment() {  
  const queryClient = useQueryClient()  
  const { open, onClose: originalOnClose } = useOpenMembershipDialog()  
  const [deviceType, setDeviceType] = useState<DeviceType>('WEB')  
  const [selectedPaymentOption, setSelectedPaymentOption] = useState<InnerPaymentPlanId | null>(null)  
  const [secretKey, setSecretKey] = useState<string | null>(null)  
  const [resSecretKey, setResSecretKey] = useState<string | null>(null)  
  const [isAuthReady, setIsAuthReady] = useState(false)  
  const [isPaymentProcessing, setIsPaymentProcessing] = useState(false)  
  const [authInitialized, setAuthInitialized] = useState(false)  
  const [paymentInitiationResponse, setPaymentInitiationResponse] = useState<PaymentInitiationResponse | null>(null)  
  
  // 2단계 결제 대기 상태 추가  
  const [pendingSecondStep, setPendingSecondStep] = useState<{  
    paymentInitiationResponse: PaymentInitiationResponse  
    paymentOption: PaymentOption  
  } | null>(null)  
  
  // 유저 정보 가져오기  
  const { data: user } = useGetUserInfo(open)  
  
  // Payment hooks  
  const paymentInitiateMutation = usePaymentInitiate()  
  const verifyGoogleMutation = useVerifyGoogleAction()  
  
  // Auth 초기화 함수를 분리  
  const initializeAuth = useCallback(async () => {  
    try {  
      setIsAuthReady(false)  
      setAuthInitialized(false)  
  
      // 디바이스 타입과 토큰을 동시에 가져오기  
      const [type, token] = await Promise.all([useAuthStore.getDeviceType(), useAuthStore.getToken()])  
  
      setDeviceType(type as DeviceType)  
      setSecretKey(token)  
      setIsAuthReady(true)  
      setAuthInitialized(true)  
    } catch (error) {  
      setDeviceType('WEB')  
      setSecretKey(null)  
      setIsAuthReady(true)  
      setAuthInitialized(true)  
    }  
  }, [])  
  
  // 컴포넌트 마운트 시 초기화  
  useEffect(() => {  
    initializeAuth()  
  }, [open, initializeAuth])  
  
  // 디바이스별 결제 훅 활성화 조건  
  const isGooglePaymentEnabled = deviceType === 'ANDROID' && !!resSecretKey  
  const isAppStorePaymentEnabled = deviceType === 'IOS' && !!resSecretKey  
  
  // 구독 변경 타입 판별 - 수정된 버전  
  const getSubscriptionChangeType = (targetOptionId: InnerPaymentPlanId) => {  
    if (!user?.membershipType || !user?.subscriptionPlan) {  
      return 'new'  
    }  
  
    // 현재 구독 중인 플랜 확인  
    const currentPlan = getCurrentMembershipPlan(user.membershipType, user.subscriptionPlan)  
  
    // 현재 무료 사용자인 경우 신규 결제  
    if (!currentPlan) {  
      return 'new'  
    }  
  
    const targetPlan = targetOptionId  
  
    // 업그레이드 (Basic → Premium, 같은 기간 또는 다른 기간)  
    if (currentPlan === 'basic-monthly' && targetPlan === 'premium-monthly') {  
      return 'upgrade'  
    }  
    // 🆕 베이직 6개월 → 프리미엄 6개월 업그레이드  
    if (currentPlan === 'basic-sixmonthly' && targetPlan === 'premium-sixmonthly') {  
      return 'upgrade'  
    }  
  
    // 다운그레이드 (Premium → Basic, 같은 기간)  
    if (currentPlan === 'premium-monthly' && targetPlan === 'basic-monthly') {  
      return 'downgrade'  
    }  
  
    // 기간 변경 - 같은 플랜에서 기간만 변경  
    if (  
      (currentPlan === 'basic-monthly' && targetPlan === 'basic-sixmonthly') ||  
      (currentPlan === 'premium-monthly' && targetPlan === 'premium-sixmonthly')  
    ) {  
      return 'periodChange'  
    }  
  
    // 플랜과 기간 모두 변경 (베이직 월간 → 프리미엄 6개월 등) - periodChange로 처리  
    if (  
      (currentPlan === 'basic-monthly' && targetPlan === 'premium-sixmonthly') ||  
      (currentPlan === 'premium-monthly' && targetPlan === 'basic-sixmonthly') ||  
      (currentPlan === 'basic-sixmonthly' && targetPlan === 'premium-monthly') ||  
      (currentPlan === 'premium-sixmonthly' && targetPlan === 'basic-monthly')  
    ) {  
      return 'periodChange'  
    }  
  
    return 'change'  
  }  
  
  // PaymentPlanId를 PaymentInitiationRequest로 변환  
  const convertToPaymentInitiationRequest = (optionId: InnerPaymentPlanId): PaymentInitiationRequest => {  
    const platformMap: Record<DeviceType, PaymentPlatformEnum> = {  
      ANDROID: 'GOOGLE',  
      IOS: 'APPLE',  
      WEB: 'GOOGLE', // 웹은 기본적으로 구글로 처리  
    }  
  
    const productTypeMap: Record<InnerPaymentPlanId, ProductTypeEnum> = {  
      'premium-monthly': 'PREMIUM',  
      'premium-sixmonthly': 'PREMIUM',  
      'basic-monthly': 'BASIC',  
      'basic-sixmonthly': 'BASIC',  
    }  
  
    const basePlanTypeMap: Record<InnerPaymentPlanId, BasePlanTypeEnum> = {  
      'premium-monthly': 'PREMIUM_MONTHLY',  
      'premium-sixmonthly': 'PREMIUM_SIX_MONTHS',  
      'basic-monthly': 'PREMIUM_MONTHLY', // 기본은 monthly로 매핑  
      'basic-sixmonthly': 'PREMIUM_SIX_MONTHS',  
    }  
  
    return {  
      platform: platformMap[deviceType],  
      productType: productTypeMap[optionId],  
      basePlanType: basePlanTypeMap[optionId],  
    }  
  }  
  
  // Google Payment Hook - 안드로이드일 때만 활성화  
  const {  
    isProcessing: isGoogleProcessing,  
    processingOptionId: googleProcessingOptionId,  
    purchaseProduct: purchaseGoogleProduct,  
    subscriptionUpgrade,  
    subscriptionDowngrade,  
    subscriptionPeriodChange,  
    resetPaymentState: resetGooglePaymentState,  
  } = useGooglePayment({  
    secretKey: resSecretKey || undefined,  
    enabled: isGooglePaymentEnabled,  
    onPurchaseSuccess: async (result: PurchaseResult) => {  
      await handleSecondStepSuccess(result)  
    },  
    onPurchaseError: (error: string) => {  
      handlePaymentFailure(`Google Play 결제 실패: ${error}`)  
    },  
    onReceiptVerification: async (result: PurchaseResult) => {  
      await handleReceiptVerification(result)  
    },  
  })  
  
  // App Store Payment Hook - iOS일 때만 활성화  
  const {  
    isProcessing: isAppStoreProcessing,  
    processingOptionId: appStoreProcessingOptionId,  
    purchaseProduct: purchaseAppStoreProduct,  
    resetPaymentState: resetAppStorePaymentState,  
  } = useAppStorePayment({  
    secretKey: resSecretKey || undefined,  
    enabled: isAppStorePaymentEnabled,  
    onPurchaseSuccess: async (result: PurchaseResult) => {  
      await handleSecondStepSuccess(result)  
    },  
    onPurchaseError: (error: string) => {  
      handlePaymentFailure(`App Store 결제 실패: ${error}`)  
    },  
    onReceiptVerification: async (result: PurchaseResult) => {},  
  })  
  
  // ✅ 완전한 상태 초기화 함수 - 모든 상태를 처음 렌더링될 때와 동일하게 초기화  
  const resetAllStates = useCallback(() => {  
    console.log('🔄 모든 결제 관련 상태를 완전히 초기화합니다...')  
  
    // 1. 기본 상태들 초기화  
    setSelectedPaymentOption(null)  
    setResSecretKey(null)  
    setIsPaymentProcessing(false)  
    setPaymentInitiationResponse(null)  
    setPendingSecondStep(null)  
  
    // 2. 각 결제 훅의 내부 상태 초기화  
    resetGooglePaymentState?.()  
    resetAppStorePaymentState?.()  
  
    // 3. Mutation 상태들 초기화  
    paymentInitiateMutation.reset?.()  
    verifyGoogleMutation.reset?.()  
  
    console.log('✅ 모든 결제 관련 상태 초기화 완료')  
  }, [resetGooglePaymentState, resetAppStorePaymentState, paymentInitiateMutation, verifyGoogleMutation])  
  
  const onClose = () => {  
    originalOnClose(() => {  
      // 다이얼로그 닫을 때도 완전 초기화  
      resetAllStates()  
    })  
  }  
  
  // 기존 resetPaymentState 함수도 resetAllStates를 사용하도록 수정  
  const resetPaymentState = useCallback(() => {  
    resetAllStates()  
  }, [resetAllStates])  
  
  // ✅ 결제 실패 시 호출되는 함수 - 완전한 상태 초기화 적용  
  const handlePaymentFailure = useCallback(  
    (errorMessage: string) => {  
      console.error('❌ Payment failed:', errorMessage)  
      toast.error(errorMessage)  
  
      // 모든 상태를 완전히 초기화  
      resetAllStates()  
    },  
    [resetAllStates],  
  )  
  
  const convertToPaymentOption = (optionId: InnerPaymentPlanId): PaymentOption | null => {  
    const optionMap: Record<InnerPaymentPlanId, PaymentOption> = {  
      'premium-monthly': { id: 'premium-monthly', membershipType: 'PREMIUM', plan: 'monthly' },  
      'premium-sixmonthly': { id: 'premium-sixmonthly', membershipType: 'PREMIUM', plan: 'sixMonthly' },  
      'basic-monthly': { id: 'basic-monthly', membershipType: 'BASIC', plan: 'monthly' },  
      'basic-sixmonthly': { id: 'basic-sixmonthly', membershipType: 'BASIC', plan: 'sixMonthly' },  
    }  
    return optionMap[optionId] || null  
  }  
  
  // resSecretKey가 설정되면 대기 중인 2단계 결제를 실행하는 effect 추가  
  useEffect(() => {  
    if (resSecretKey && pendingSecondStep) {  
      console.log('resSecretKey가 설정되어 2단계 결제를 실행합니다:', resSecretKey.substring(0, 10) + '...')  
      executeSecondStep(pendingSecondStep.paymentInitiationResponse, pendingSecondStep.paymentOption)  
      setPendingSecondStep(null) // 실행 후 대기 상태 해제  
    }  
  }, [resSecretKey, pendingSecondStep])  
  
  // 🆕 현재 구독 기간 확인 헬퍼 함수  
  const getCurrentSubscriptionPeriod = (): 'monthly' | 'sixmonthly' | null => {  
    if (!user?.membershipType || !user?.subscriptionPlan) {  
      return null  
    }  
  
    const currentPlan = getCurrentMembershipPlan(user.membershipType, user.subscriptionPlan)  
  
    if (currentPlan === 'basic-monthly' || currentPlan === 'premium-monthly') {  
      return 'monthly'  
    } else if (currentPlan === 'basic-sixmonthly' || currentPlan === 'premium-sixmonthly') {  
      return 'sixmonthly'  
    }  
  
    return null  
  }  
  
  // 2단계 실행 함수 분리  
  const executeSecondStep = async (  
    paymentInitiationResponse: PaymentInitiationResponse,  
    paymentOption: PaymentOption,  
  ) => {  
    try {  
      const changeType = getSubscriptionChangeType(paymentOption.id)  
  
      // paymentInitiationResponse의 receiptData를 purchaseToken으로 사용  
      const purchaseToken = paymentInitiationResponse.receiptData  
  
      switch (deviceType) {  
        case 'ANDROID':  
          // 구독 변경인지 신규 구매인지 판별하여 적절한 함수 호출  
          if (changeType === 'new' || !purchaseToken) {  
            await purchaseGoogleProduct(paymentOption)  
          } else {  
            // 구독 변경 처리  
            switch (changeType) {  
              case 'upgrade': {  
                const currentPeriod = getCurrentSubscriptionPeriod()  
                await subscriptionUpgrade(purchaseToken, currentPeriod || 'monthly')  
                break  
              }  
              case 'downgrade':  
                await subscriptionDowngrade(purchaseToken)  
                break  
              case 'periodChange': {  
                // 현재 플랜과 목표 플랜 정보 추출 - 수정된 로직  
                let currentPlan: 'basic' | 'premium'  
                let toPlan: 'basic' | 'premium'  
  
                // 현재 플랜 정보를 user 객체에서 가져오기  
                if (user?.membershipType === 'BASIC') {  
                  currentPlan = 'basic'  
                } else if (user?.membershipType === 'PREMIUM') {  
                  currentPlan = 'premium'  
                } else {  
                  throw new Error('현재 구독 정보를 확인할 수 없습니다.')  
                }  
  
                // 목표 플랜 정보를 paymentOption에서 가져오기  
                if (paymentOption.membershipType === 'BASIC') {  
                  toPlan = 'basic'  
                } else {  
                  toPlan = 'premium'  
                }  
  
                console.log(`구독 기간 변경: ${currentPlan} → ${toPlan}`)  
                await subscriptionPeriodChange(purchaseToken, currentPlan, toPlan)  
                break  
              }  
              default:  
                // 일반 구독 변경은 purchaseProduct 사용  
                await purchaseGoogleProduct(paymentOption)  
                break  
            }  
          }  
          break  
  
        case 'IOS':  
          // iOS는 아직 구독 변경 기능 미지원 (기본 purchaseProduct만 사용)  
          throw new Error('아직 iOS 디바이스에서 App Store 결제를 지원하지 않습니다.')  
          // await purchaseAppStoreProduct(paymentOption)  
          break  
  
        case 'WEB':  
          throw new Error('웹에서는 다른 결제 방식을 이용해주세요.')  
  
        default:  
          throw new Error('올바르지 않은 디바이스 타입입니다.')  
      }  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '2단계 결제 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  // 1단계 성공 후 2단계 대기 상태로 설정 (수정됨)  
  const handleFirstStepSuccess = async (  
    paymentInitiationResponse: PaymentInitiationResponse,  
    paymentOption: PaymentOption,  
  ) => {  
    try {  
      setPaymentInitiationResponse(paymentInitiationResponse)  
  
      if (paymentInitiationResponse.secretKey) {  
        setResSecretKey(paymentInitiationResponse.secretKey)  
        // resSecretKey가 설정되면 useEffect에서 2단계가 자동 실행됨  
        setPendingSecondStep({ paymentInitiationResponse, paymentOption })  
      } else {  
        throw new Error('1단계 결제에서 secretKey를 받지 못했습니다.')  
      }  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '1단계 결제 완료 후 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  // 2단계 성공 후 로그 출력 (영수증 검증은 별도 처리)  
  const handleSecondStepSuccess = async (result: PurchaseResult) => {  
    console.log('2단계 구글 결제 성공:', result)  
  }  
  
  // ✅ 영수증 검증 처리 (3단계) - 성공 시 완전한 상태 초기화 적용  
  const handleReceiptVerification = async (result: PurchaseResult) => {  
    try {  
      console.log('영수증 검증 시작:', result)  
  
      if (!paymentInitiationResponse) {  
        throw new Error('결제 초기화 정보가 없습니다.')  
      }  
  
      // 영수증 데이터 필수 필드 확인  
      if (!result.receiptData) {  
        throw new Error('영수증 데이터가 없습니다.')  
      }  
  
      if (!result.productId) {  
        throw new Error('상품 ID가 없습니다.')  
      }  
  
      if (!result.basePlanId) {  
        throw new Error('베이스 플랜 ID가 없습니다.')  
      }  
  
      if (!result.transactionId) {  
        throw new Error('거래 ID가 없습니다.')  
      }  
  
      if (!result.secretKey) {  
        throw new Error('시크릿 키가 없습니다.')  
      }  
  
      if (!result.fcmToken) {  
        throw new Error('FCM 토큰이 없습니다.')  
      }  
  
      // 3단계 요청 데이터 구성  
      const verificationRequest: PaymentVerificationCommonRequest = {  
        platform: result.platform as PaymentPlatformEnum,  
        receiptData: result.receiptData,  
        productId: result.productId,  
        basePlanId: result.basePlanId,  
        transactionId: result.transactionId,  
        secretKey: result.secretKey,  
        fcmToken: result.fcmToken,  
      }  
      toast.success(`영수증 검증처리 내 result ${JSON.stringify(verificationRequest)}`)  
  
      console.log('영수증 검증 요청 데이터:', verificationRequest)  
  
      await verifyGoogleMutation.mutateAsync(verificationRequest)  
  
      // 3단계 성공 시 유저 정보 업데이트  
      await queryClient.invalidateQueries({  
        queryKey: ['useGetUserInfo'],  
      })  
  
      // 구독 변경인지 신규인지에 따라 다른 메시지 표시  
      const changeType = selectedPaymentOption ? getSubscriptionChangeType(selectedPaymentOption) : 'new'  
      const successMessage = changeType === 'new' ? '결제가 완료되었습니다!' : '구독 변경이 완료되었습니다!'  
  
      toast.success(successMessage)  
  
      // ✅ 결제 성공 시 모든 상태를 완전히 초기화  
      console.log('✅ 결제 성공: 모든 상태를 초기화합니다.')  
      resetAllStates()  
      onClose()  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '3단계 결제 처리 중 오류가 발생했습니다.'  
      console.error('영수증 검증 실패:', error)  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  const handlePayment = async () => {  
    if (!selectedPaymentOption) {  
      toast.error('결제 옵션을 선택해주세요.')  
      return  
    }  
  
    if (!isAuthReady) {  
      toast.error('사용자 정보를 불러오고 있습니다. 잠시 후 다시 시도해주세요.')  
      return  
    }  
  
    if (!secretKey) {  
      toast.error('사용자 정보를 불러올 수 없습니다. 다시 로그인해주세요.')  
      return  
    }  
  
    const paymentOption = convertToPaymentOption(selectedPaymentOption)  
    if (!paymentOption) {  
      toast.error('잘못된 결제 옵션입니다.')  
      return  
    }  
  
    setIsPaymentProcessing(true)  
  
    try {  
      // 1단계 요청 데이터 구성  
      const paymentInitiationRequest = convertToPaymentInitiationRequest(selectedPaymentOption)  
  
      // 1단계 실행  
      const response = await paymentInitiateMutation.mutateAsync(paymentInitiationRequest)  
  
      // 1단계 성공 시 2단계 대기 상태로 설정  
      await handleFirstStepSuccess(response, paymentOption)  
    } catch (error) {  
      const errorMessage = error instanceof Error ? error.message : '1단계 결제 처리 중 오류가 발생했습니다.'  
      handlePaymentFailure(errorMessage)  
    }  
  }  
  
  // 결제 버튼 비활성화 조건 - 실시간 secretKey 체크  
  const isPaymentButtonDisabled = () => {  
    const disabled =  
      !selectedPaymentOption ||  
      !authInitialized ||  
      !isAuthReady ||  
      !secretKey ||  
      isPaymentProcessing ||  
      isGoogleProcessing ||  
      isAppStoreProcessing ||  
      paymentInitiateMutation.isPending ||  
      verifyGoogleMutation.isPending ||  
      !!pendingSecondStep // 2단계 대기 중일 때도 비활성화  
  
    return disabled  
  }  
  
  // 결제 버튼 텍스트  
  const getPaymentButtonText = () => {  
    if (!authInitialized) {  
      return '초기화 중...'  
    }  
  
    if (!isAuthReady) {  
      return '사용자 정보 확인 중...'  
    }  
  
    if (!selectedPaymentOption) {  
      return '결제 옵션을 선택해주세요'  
    }  
  
    if (!secretKey) {  
      return '로그인이 필요합니다'  
    }  
  
    if (paymentInitiateMutation.isPending) {  
      return '1단계 처리 중...'  
    }  
  
    if (pendingSecondStep) {  
      return '2단계 준비 중...'  
    }  
  
    if (isGoogleProcessing || isAppStoreProcessing) {  
      return '2단계 처리 중...'  
    }  
  
    if (verifyGoogleMutation.isPending) {  
      return '3단계 처리 중...'  
    }  
  
    if (isPaymentProcessing) {  
      return '결제 처리 중...'  
    }  
  
    const isCurrentOptionProcessing =  
      selectedPaymentOption === googleProcessingOptionId || selectedPaymentOption === appStoreProcessingOptionId  
  
    if (isCurrentOptionProcessing) {  
      return '결제 처리 중...'  
    }  
  
    // 구독 변경인지 신규 결제인지에 따라 버튼 텍스트 변경  
    const changeType = selectedPaymentOption ? getSubscriptionChangeType(selectedPaymentOption) : 'new'  
    const actionText = changeType === 'new' ? '결제하기' : '구독 변경하기'  
  
    switch (deviceType) {  
      case 'ANDROID':  
        return `Google Play로 ${actionText}`  
      case 'IOS':  
        return `App Store로 ${actionText}`  
      case 'WEB':  
      default:  
        return actionText  
    }  
  }  
  
  const getSupportedPaymentMethod = () => {  
    switch (deviceType) {  
      case 'ANDROID':  
        return 'Google Play'  
      case 'IOS':  
        return 'App Store'  
      case 'WEB':  
        return 'Web Payment'  
      default:  
        return 'Unknown'  
    }  
  }  
  
  // 디바이스 체크 함수들 - 이제 단순히 deviceType 기반으로만 동작  
  const isAndroidDevice = deviceType === 'ANDROID'  
  const isIOSDevice = deviceType === 'IOS'  
  
  return {  
    // 인증 정보  
    secretKey,  
    isAuthReady,  
    authInitialized,  
  
    // 디바이스 정보  
    deviceType,  
    isAndroidDevice,  
    isIOSDevice,  
    getSupportedPaymentMethod,  
  
    // 결제 옵션 상태  
    selectedPaymentOption,  
    setSelectedPaymentOption,  
  
    // 구독 정보  
    getSubscriptionChangeType,  
  
    // 결제 초기화 응답  
    paymentInitiationResponse,  
  
    // 처리 상태  
    isProcessing:  
      isPaymentProcessing ||  
      isGoogleProcessing ||  
      isAppStoreProcessing ||  
      paymentInitiateMutation.isPending ||  
      verifyGoogleMutation.isPending ||  
      !!pendingSecondStep, // 2단계 대기 상태도 포함  
  
    processingOptionId: googleProcessingOptionId || appStoreProcessingOptionId,  
  
    // 함수들  
    handlePayment,  
    getPaymentButtonText,  
    isPaymentButtonDisabled,  
    onClose,  
    resetPaymentState, // 완전한 상태 초기화 함수  
    resetAllStates, // 직접적인 완전 초기화 함수도 export  }  
}
```