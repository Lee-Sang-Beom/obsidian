
#### Day Planner
---
- [ ] 하루 1회 프론트엔드 지식 및 Next.js 관련 기술 정리하기


#### Work
---
- [ ] Stock Chart Tooltip 선택에 따른 반투명처리 진행시도
- [ ] 팟캐스트 오디오생성중 로직 변경
- [ ] 


#### Stock Chart 반투명처리 전체코드
---
```tsx
'use client'  
  
import React, { useEffect, useRef, useState } from 'react'  
import {  
  CategoryScale,  
  Chart as ChartJS,  
  type ChartOptions,  
  Filler,  
  Legend,  
  LinearScale,  
  LineElement,  
  type Plugin,  
  PointElement,  
  Title,  
  Tooltip,  
} from 'chart.js'  
import { Line } from 'react-chartjs-2'  
import { cn, formatPrice } from '@/lib/utils'  
import { type SignalResponse, type TimeFrameResponse } from '@/pages/signal/types'  
import moment from 'moment'  
import { Badge } from '@/components/ui/badge.tsx'  
import { TrendingDown, TrendingUp } from 'lucide-react'  
import { calculatePercentage } from '@/pages/signal/utils.ts'  
  
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend, Filler)  
  
interface StockChartProps {  
  id: string  
  data: TimeFrameResponse[] // 변경된 데이터 타입  
  signalPoints: SignalResponse[]  
  height?: number  
  unit: string  
  totalMaxValue: number  
}  
  
interface CustomTooltipState {  
  visible: boolean  
  x: number  
  y: number  
  data: {  
    date: string  
    price: number  
    lowPrice: number  
    highPrice: number  
    lowPriceTime: string  
    highPriceTime: string  
    currencyCode: string  
    type: 'buy' | 'sell'  
    strategy: string  
    tradingStyle: string  
  } | null  
}  
  
// 툴팁 위치 계산 함수 - 뷰포트 안전성 보장  
const calculateTooltipPosition = (clickX: number, clickY: number) => {  
  const tooltipWidth = 160  
  const tooltipHeight = 140  
  const margin = 16  
  
  const viewportWidth = window.innerWidth  
  const viewportHeight = window.innerHeight  
  
  let finalX = clickX  
  let finalY = clickY - 10  
  let transform = 'translateX(-50%) translateY(-100%)'  
  
  // 수평 위치 조정  
  if (clickX - tooltipWidth / 2 < margin) {  
    finalX = margin + tooltipWidth / 2  
    transform = 'translateX(-50%) translateY(-100%)'  
  } else if (clickX + tooltipWidth / 2 > viewportWidth - margin) {  
    finalX = viewportWidth - margin - tooltipWidth / 2  
    transform = 'translateX(-50%) translateY(-100%)'  
  }  
  
  // 수직 위치 조정  
  if (clickY - tooltipHeight - 20 < margin) {  
    finalY = clickY + 20  
    transform = transform.replace('translateY(-100%)', 'translateY(0%)')  
  }  
  
  if (finalY + tooltipHeight > viewportHeight - margin) {  
    finalY = viewportHeight - margin - tooltipHeight  
    transform = transform.replace('translateY(-100%)', 'translateY(0%)').replace('translateY(0%)', 'translateY(0%)')  
  }  
  
  return { x: finalX, y: finalY, transform }  
}  
  
// 시간 포맷팅 함수 - ISO 문자열을 처리  
const formatTime = (timeString: string) => {  
  return moment(timeString).format('M월 D일 HH시 mm분')  
}  
// 차트 레이블 포맷팅 함수  
const formatChartLabel = (timeString: string) => {  
  const date = new Date(timeString)  
  return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`  
}  
  
export default function StockChart({  
  id,  
  data,  
  signalPoints,  
  height = 200,  
  unit = 'USD',  
  totalMaxValue,  
}: StockChartProps) {  
  const chartRef = useRef<ChartJS<'line'>>(null)  
  const containerRef = useRef<HTMLDivElement>(null)  
  const [signalPositions, setSignalPositions] = useState<  
    Array<{  
      id: string  
      x: number  
      y: number  
      signal: SignalResponse  
    }>  
  >([])  
  
  // 다크 모드 감지  
  const [isDark, setIsDark] = useState(false)  
  
  useEffect(() => {  
    const checkDarkMode = () => {  
      setIsDark(document.documentElement.classList.contains('dark'))  
    }  
  
    checkDarkMode()  
    const observer = new MutationObserver(checkDarkMode)  
    observer.observe(document.documentElement, {  
      attributes: true,  
      attributeFilter: ['class'],  
    })  
  
    return () => observer.disconnect()  
  }, [])  
  
  // 커스텀 툴팁 상태 관리  
  const [customTooltip, setCustomTooltip] = useState<CustomTooltipState & { transform?: string }>({  
    visible: false,  
    x: 0,  
    y: 0,  
    data: null,  
    transform: 'translateX(-50%) translateY(-100%)',  
  })  
  
  // 데이터 유효성 검사  
  const isDataEmpty = !data || data.length === 0  
  const hasOnlyOneDataPoint = data && data.length === 1  
  
  // close 값들로 min/max 계산  
  const values = data.map(d => d.close)  
  const minValue = Math.min(...values) * 0.98  
  const maxValue = totalMaxValue !== 0 ? totalMaxValue * 1.02 : Math.max(...values) * 1.02  
  
  // 시그널 포인트 좌표 계산 함수 - TimeFrameResponse 데이터와 매칭  
  const getSignalPointCoordinates = (signal: SignalResponse, chart: ChartJS<'line'>) => {  
    const {  
      scales: { x, y },  
    } = chart  
    const signalTime = new Date(signal.signalTime)  
  
    // 가장 가까운 시간의 데이터 포인트 찾기  
    let closestIndex = 0  
    let minTimeDiff = Infinity  
  
    data.forEach((d, index) => {  
      const dataTime = new Date(d.time)  
      const timeDiff = Math.abs(signalTime.getTime() - dataTime.getTime())  
      if (timeDiff < minTimeDiff) {  
        minTimeDiff = timeDiff  
        closestIndex = index  
      }  
    })  
  
    // 시그널 포인트는 실제 가격 값이 아닌 시그널의 closingPrice를 사용  
    const actualPrice = signal.closingPrice  
  
    return {  
      xPos: x.getPixelForValue(closestIndex),  
      yPos: y.getPixelForValue(actualPrice),  
      dataIndex: closestIndex,  
    }  
  }  
  
  // 시그널 포인트 클릭 핸들러  
  // 시그널 포인트 클릭 핸들러 - 차트 강제 업데이트 추가  
  const handleSignalPointClick = (point: SignalResponse, event: React.MouseEvent) => {  
    event.preventDefault()  
    event.stopPropagation()  
  
    console.log('Signal point clicked:', point.signalType, formatTime(point.signalTime))  
    console.log('Current customTooltip.visible before:', customTooltip.visible)  
  
    // 기존 툴팁이 같은 시그널 포인트인 경우 토글  
    if (customTooltip.visible && customTooltip.data && customTooltip.data.date === formatTime(point.signalTime)) {  
      console.log('Closing tooltip (same signal)')  
      setCustomTooltip(prev => ({  
        ...prev,  
        visible: false,  
        x: 0,  
        y: 0,  
        data: null,  
      }))  
  
      // 차트 강제 업데이트  
      setTimeout(() => {  
        if (chartRef.current) {  
          chartRef.current.update('none') // 애니메이션 없이 즉시 업데이트  
        }  
      }, 0)  
      return  
    }  
  
    console.log('Opening tooltip for new signal')  
    // 뷰포트 안전 위치 계산  
    const safePosition = calculateTooltipPosition(event.clientX, event.clientY)  
    setCustomTooltip({  
      visible: true,  
      x: safePosition.x,  
      y: safePosition.y,  
      transform: safePosition.transform,  
      data: {  
        date: formatTime(point.signalTime),  
        price: point.closingPrice,  
        lowPrice: point.lowPrice || -1,  
        highPrice: point.highPrice || -1,  
        currencyCode: point.currencyCode || '원',  
        lowPriceTime: point.lowPriceTime || '',  
        highPriceTime: point.highPriceTime || '',  
        type: point.signalType.toLowerCase() as 'buy' | 'sell',  
        strategy: point.strategyName,  
        tradingStyle: point.tradingStyle === 'SHORT' ? '단기' : point.tradingStyle === 'MEDIUM' ? '중기' : '장기',  
      },  
    })  
  
    // 차트 강제 업데이트  
    setTimeout(() => {  
      if (chartRef.current) {  
        chartRef.current.update('none') // 애니메이션 없이 즉시 업데이트  
      }  
    }, 0)  
  }  
  
  // 툴팁 닫기 핸들러  
  const handleCloseTooltip = () => {  
    setCustomTooltip(prev => ({  
      ...prev,  
      visible: false,  
      x: 0,  
      y: 0,  
      data: null,  
    }))  
  }  
  
  // 시그널 포인트 위치 업데이트  
  useEffect(() => {  
    if (chartRef.current && !isDataEmpty) {  
      const positions = signalPoints.map(signal => {  
        const coords = getSignalPointCoordinates(signal, chartRef.current!)  
        return {  
          id: `${id}_${coords.xPos}_${coords.yPos}`,  
          x: coords.xPos,  
          y: coords.yPos,  
          signal,  
        }  
      })  
      setSignalPositions(positions)  
    }  
  }, [data, signalPoints, isDark, isDataEmpty])  
  
  // 차트 리사이즈 시 시그널 포인트 위치 재계산  
  useEffect(() => {  
    const handleResize = () => {  
      if (chartRef.current && !isDataEmpty) {  
        setTimeout(() => {  
          const positions = signalPoints.map(signal => {  
            const coords = getSignalPointCoordinates(signal, chartRef.current!)  
            return {  
              id: `${id}_${coords.xPos}_${coords.yPos}`,  
              x: coords.xPos,  
              y: coords.yPos,  
              signal,  
            }  
          })  
          setSignalPositions(positions)  
        }, 100)  
      }  
    }  
  
    window.addEventListener('resize', handleResize)  
    return () => window.removeEventListener('resize', handleResize)  
  }, [signalPoints, data, isDataEmpty])  
  
  // 가격 텍스트 박스 위치 계산 함수  
  const calculateTextBoxPosition = (xPos: number, yPos: number, textWidth: number, chartWidth: number) => {  
    const padding = 6  
    const bgWidth = textWidth + padding * 2  
    const margin = 10 // 캔버스 가장자리에서의 최소 거리  
  
    let textX = xPos // 텍스트 중심 X 좌표  
    let bgX = xPos - bgWidth / 2 // 배경 박스 왼쪽 X 좌표  
  
    // 왼쪽 끝에 너무 가까운 경우  
    if (bgX < margin) {  
      bgX = margin  
      textX = bgX + bgWidth / 2  
    }  
    // 오른쪽 끝에 너무 가까운 경우  
    else if (bgX + bgWidth > chartWidth - margin) {  
      bgX = chartWidth - margin - bgWidth  
      textX = bgX + bgWidth / 2  
    }  
  
    return { textX, bgX }  
  }  
  
  // 시그널 포인트를 그리는 플러그인 - ref를 사용하여 최신 상태 참조  
  const signalPointPlugin: Plugin<'line'> = {  
    id: 'signalPoints',  
    afterDraw: chart => {  
      const { ctx, width: chartWidth, tooltip } = chart  
  
      // ref를 통해 최신 상태 참조  
      const currentTooltip = customTooltipRef.current  
  
      // 차트의 기본 툴팁이 활성화되어 있는지 확인  
      const isChartTooltipActive = tooltip && tooltip.opacity > 0  
  
      console.log(`[Plugin] customTooltip.visible (ref): ${currentTooltip.visible}`)  
  
      signalPoints.forEach((signal, index) => {  
        const coords = getSignalPointCoordinates(signal, chart)  
        if (!coords) return  
  
        const { xPos, yPos } = coords  
        const isBuy = signal.signalType === 'BUY'  
  
        // 현재 시그널이 커스텀 툴팁에 표시되고 있는지 확인 (ref 사용)  
        const isCurrentSignalSelected =  
          currentTooltip.visible && currentTooltip.data && currentTooltip.data.date === formatTime(signal.signalTime)  
  
        // 디버깅 로그 - 첫 번째 시그널에 대해서만 로그 출력  
        if (index === 0) {  
          console.log(  
            `[Plugin] currentTooltip.visible: ${currentTooltip.visible}, isCurrentSignalSelected: ${isCurrentSignalSelected}`,  
          )  
        }  
  
        ctx.save()  
  
        // 투명도 결정 로직 (ref의 최신 상태 사용)  
        const baseOpacity = !isChartTooltipActive && !currentTooltip.visible ? 1.0 : currentTooltip.visible ? 1.0 : 0.4  
  
        // ... 나머지 그리기 코드는 동일  
        // 그림자 효과 추가  
        const shadowIntensity = baseOpacity === 1.0 ? 1.0 : 0.4  
        ctx.shadowColor = `rgba(0, 0, 0, ${0.15 * shadowIntensity})`  
        ctx.shadowBlur = baseOpacity === 1.0 ? 4 : 2  
        ctx.shadowOffsetX = 0  
        ctx.shadowOffsetY = baseOpacity === 1.0 ? 2 : 1  
  
        // 외부 원형 배경  
        ctx.beginPath()  
        ctx.arc(xPos, yPos, 11, 0, 2 * Math.PI)  
        ctx.globalAlpha = baseOpacity  
        ctx.fillStyle = isBuy ? '#ef4444' : '#3b82f6'  
        ctx.fill()  
  
        // 내부 원형 배경  
        ctx.shadowColor = 'transparent'  
        ctx.beginPath()  
        ctx.arc(xPos, yPos, 8.5, 0, 2 * Math.PI)  
        ctx.fillStyle = isBuy ? '#f87171' : '#60a5fa'  
        ctx.fill()  
  
        // 가장 안쪽 원  
        ctx.beginPath()  
        ctx.arc(xPos, yPos, 6, 0, 2 * Math.PI)  
        ctx.fillStyle = isBuy ? '#fca5a5' : '#93c5fd'  
        ctx.fill()  
  
        // 화살표 그리기  
        ctx.fillStyle = '#ffffff'  
        ctx.strokeStyle = '#ffffff'  
        ctx.lineWidth = 1.5  
        ctx.lineCap = 'round'  
        ctx.lineJoin = 'round'  
  
        if (isBuy) {  
          // 매수 화살표  
          ctx.beginPath()  
          ctx.moveTo(xPos, yPos - 4.5)  
          ctx.lineTo(xPos - 3.5, yPos + 1.5)  
          ctx.lineTo(xPos - 1.5, yPos + 1.5)  
          ctx.lineTo(xPos - 1.5, yPos + 3.5)  
          ctx.lineTo(xPos + 1.5, yPos + 3.5)  
          ctx.lineTo(xPos + 1.5, yPos + 1.5)  
          ctx.lineTo(xPos + 3.5, yPos + 1.5)  
          ctx.closePath()  
          ctx.fill()  
  
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * baseOpacity})`  
          ctx.lineWidth = 0.5  
          ctx.stroke()  
        } else {  
          // 매도 화살표  
          ctx.beginPath()  
          ctx.moveTo(xPos, yPos + 4.5)  
          ctx.lineTo(xPos - 3.5, yPos - 1.5)  
          ctx.lineTo(xPos - 1.5, yPos - 1.5)  
          ctx.lineTo(xPos - 1.5, yPos - 3.5)  
          ctx.lineTo(xPos + 1.5, yPos - 3.5)  
          ctx.lineTo(xPos + 1.5, yPos - 1.5)  
          ctx.lineTo(xPos + 3.5, yPos - 1.5)  
          ctx.closePath()  
          ctx.fill()  
  
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * baseOpacity})`  
          ctx.lineWidth = 0.5  
          ctx.stroke()  
        }  
  
        // 펄스 효과를 위한 외부 링  
        ctx.shadowColor = 'transparent'  
        ctx.beginPath()  
        ctx.arc(xPos, yPos, 13, 0, 2 * Math.PI)  
        ctx.strokeStyle = isBuy ? `rgba(239, 68, 68, ${0.3 * baseOpacity})` : `rgba(59, 130, 246, ${0.3 * baseOpacity})`  
        ctx.lineWidth = 2  
        ctx.stroke()  
  
        // 가격 텍스트 표시  
        const priceText = `${formatPrice(signal.closingPrice, signal.currencyCode)}`  
  
        ctx.font = '14px "Noto Sans KR", sans-serif'  
        const textMetrics = ctx.measureText(priceText)  
        const textWidth = textMetrics.width  
        const textHeight = 12  
        const padding = 6  
  
        const { textX, bgX } = calculateTextBoxPosition(xPos, yPos, textWidth, chartWidth)  
  
        const bgY = yPos + 18  
        const bgWidth = textWidth + padding * 2  
        const bgHeight = textHeight + padding  
  
        // 텍스트 배경 그리기  
        ctx.fillStyle = isBuy ? `rgba(239, 68, 68, ${0.9 * baseOpacity})` : `rgba(59, 130, 246, ${0.9 * baseOpacity})`  
        ctx.beginPath()  
        ctx.roundRect(bgX, bgY, bgWidth, bgHeight, 3)  
        ctx.fill()  
  
        // 텍스트 그리기  
        ctx.fillStyle = `rgba(255, 255, 255, ${baseOpacity})`  
        ctx.textAlign = 'center'  
        ctx.textBaseline = 'middle'  
        ctx.fillText(priceText, textX, bgY + bgHeight / 2)  
  
        ctx.globalAlpha = 1.0  
        ctx.restore()  
      })  
    },  
  }  
  
  // 단일 데이터 포인트를 위한 차트 데이터 처리  
  const getChartData = () => {  
    if (hasOnlyOneDataPoint) {  
      // 단일 포인트의 경우 시각적으로 표현하기 위해 같은 값을 2개 생성  
      const singleData = data[0]  
      return {  
        labels: [formatChartLabel(singleData.time), formatChartLabel(singleData.time)],  
        datasets: [  
          {  
            label: '가격',  
            data: [singleData.close, singleData.close],  
            borderColor: '#3b82f6',  
            backgroundColor: isDark ? 'rgba(59, 130, 246, 0.3)' : 'rgba(59, 130, 246, 0.2)',  
            fill: true,  
            tension: 0,  
            pointRadius: hasOnlyOneDataPoint ? 6 : 0, // 단일 포인트인 경우 점 표시  
            pointHoverRadius: hasOnlyOneDataPoint ? 8 : 4,  
            pointBackgroundColor: '#3b82f6',  
            pointBorderColor: '#ffffff',  
            pointBorderWidth: 2,  
            borderWidth: 2,  
          },  
        ],  
      }  
    }  
  
    return {  
      labels: data.map(d => formatChartLabel(d.time)),  
      datasets: [  
        {  
          label: '가격',  
          data: data.map(d => d.close),  
          borderColor: '#3b82f6',  
          backgroundColor: isDark ? 'rgba(59, 130, 246, 0.3)' : 'rgba(59, 130, 246, 0.2)',  
          fill: true,  
          tension: 0.1,  
          pointRadius: 0,  
          pointHoverRadius: 4,  
          borderWidth: 2,  
        },  
      ],  
    }  
  }  
  
  // 차트 데이터 설정  
  const chartData = getChartData()  
  
  // 차트 옵션 설정  
  const options: ChartOptions<'line'> = {  
    responsive: true,  
    maintainAspectRatio: false,  
    layout: {  
      padding: {  
        left: 5,  
        right: 5,  
        top: 0,  
        bottom: 0,  
      },  
    },  
    plugins: {  
      legend: {  
        display: false,  
      },  
      tooltip: {  
        enabled: true,  
        mode: 'index',  
        intersect: false,  
        yAlign: 'bottom',  
        backgroundColor: isDark ? 'rgba(31, 41, 55, 0.98)' : 'rgba(255, 255, 255, 0.98)',  
        titleColor: isDark ? '#f9fafb' : '#111827',  
        bodyColor: isDark ? '#f9fafb' : '#111827',  
        borderColor: isDark ? '#4b5563' : '#d1d5db',  
        borderWidth: 1,  
        cornerRadius: 6,  
        displayColors: false,  
        titleFont: {  
          size: 13,  
          family: "'Noto Sans KR', sans-serif",  
        },  
        bodyFont: {  
          size: 12,  
          family: "'Noto Sans KR', sans-serif",  
        },  
        callbacks: {  
          // 제목 스타일링 (아이콘 추가)  
          title: items => {  
            if (!items || items.length === 0) return ''  
            return `${moment(items[0].label, 'HH:mm').format('HH시 mm분')}`  
          },  
  
          // 라벨 스타일링 (아이콘, 색상, 포맷팅)  
          label: item => {  
            if (!item || item.parsed === undefined) return ''  
            const price = `${formatPrice(item.parsed.y, unit)}`  
            return `가격: ${price}`  
          },  
        },  
      },  
    },  
    scales: {  
      x: {  
        display: true,  
        grid: {  
          color: isDark ? '#374151' : '#e5e7eb',  
          display: false,  
        },  
        ticks: {  
          maxTicksLimit: hasOnlyOneDataPoint ? 1 : 8, // 단일 포인트인 경우 하나의 레이블만 표시  
          color: isDark ? '#d2e3ff' : '#111111',  
          font: {  
            size: 11,  
            family: "'Noto Sans KR', sans-serif",  
          },  
        },  
        border: {  
          display: false,  
        },  
      },  
      y: {  
        display: false,  
        min: minValue,  
        max: maxValue,  
        grid: {  
          color: isDark ? '#374151' : '#e5e7eb',  
          display: true,  
        },  
        ticks: {  
          display: true,  
          maxTicksLimit: 5,  
          color: isDark ? '#dddddd' : '#111111',  
          font: {  
            size: 11,  
            family: "'Noto Sans KR', sans-serif",  
          },  
          callback: value => {  
            const numValue = Number(value)  
            return numValue.toFixed(2)  
          },  
        },  
        border: {  
          display: false,  
        },  
      },  
    },  
    interaction: {  
      mode: 'nearest',  
      axis: 'x',  
      intersect: false,  
    },  
    onClick: () => {  
      try {  
        if (customTooltip.visible) {  
          handleCloseTooltip()  
        }  
      } catch (error) {  
        console.warn('Chart click error:', error)  
        handleCloseTooltip()  
      }  
    },  
    onHover: (_, elements) => {  
      try {  
        if (chartRef.current) {  
          chartRef.current.canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default'  
        }  
      } catch (error) {  
        console.warn('Chart hover error:', error)  
      }  
    },  
  }  
  
  // customTooltip 상태가 변경될 때마다 차트 업데이트  
  useEffect(() => {  
    console.log('customTooltip state changed:', {  
      visible: customTooltip.visible,  
      hasData: !!customTooltip.data,  
      signalDate: customTooltip.data?.date,  
    })  
  
    // 상태 변경 후 차트 강제 업데이트  
    if (chartRef.current) {  
      // requestAnimationFrame을 사용하여 다음 프레임에 업데이트  
      requestAnimationFrame(() => {  
        if (chartRef.current) {  
          chartRef.current.update('none')  
        }  
      })  
    }  
  }, [customTooltip.visible, customTooltip.data])  
  
  // 또는 useRef를 사용하여 최신 상태를 플러그인에서 참조하는 방법  
  const customTooltipRef = useRef(customTooltip)  
  
  // customTooltip 상태가 변경될 때마다 ref 업데이트  
  useEffect(() => {  
    customTooltipRef.current = customTooltip  
  }, [customTooltip])  
  
  // 차트 외부 클릭 시 툴팁 닫기  
  useEffect(() => {  
    const handleClickOutside = (event: MouseEvent) => {  
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {  
        handleCloseTooltip()  
      }  
    }  
  
    document.addEventListener('mousedown', handleClickOutside)  
    return () => {  
      document.removeEventListener('mousedown', handleClickOutside)  
    }  
  }, [])  
  
  // 스크롤 시 툴팁 닫기 (추가된 부분)  
  useEffect(() => {  
    const handleScroll = () => {  
      if (customTooltip.visible) {  
        handleCloseTooltip()  
      }  
    }  
  
    // 전역 스크롤 이벤트 감지  
    window.addEventListener('scroll', handleScroll, true)  
  
    return () => {  
      window.removeEventListener('scroll', handleScroll, true)  
    }  
  }, [customTooltip.visible])  
  
  return (  
    <div className="bg-gray-50 dark:bg-gray-900">  
      <div        ref={containerRef}  
        className="relative w-full bg-white dark:bg-transparent"  
        style={{ height: `${height}px` }}  
      >  
        {/* Chart Container */}  
        <div className="relative w-full" style={{ height: `${height}px` }}>  
          <Line ref={chartRef} data={chartData} options={options} plugins={[signalPointPlugin]} />  
  
          {/* 단일 데이터 포인트 안내 메시지 */}  
          {hasOnlyOneDataPoint && (  
            <div className="absolute top-2 right-2 rounded bg-blue-100 px-2 py-1 text-xs text-blue-800 dark:bg-blue-900 dark:text-blue-200">  
              단일 데이터 포인트  
            </div>  
          )}  
  
          {/* 절대 위치 시그널 포인트 오버레이 */}  
          {signalPositions.map((pos, idx) => {  
            return (  
              <button  
                key={`${pos.id}_${idx}`}  
                className="absolute z-20 cursor-pointer transition-transform duration-200 ease-out hover:scale-110"  
                style={{  
                  left: `${pos.x - 16}px`,  
                  top: `${pos.y - 16}px`,  
                  width: '32px',  
                  height: '32px',  
                  borderRadius: '50%',  
                  backgroundColor: 'transparent',  
                  border: 'none',  
                  padding: 0,  
                }}  
                onClick={e => handleSignalPointClick(pos.signal, e)}  
                onMouseDown={e => e.preventDefault()}  
                title={`${pos.signal.signalType} Signal - ${formatPrice(pos.signal.closingPrice, pos.signal.currencyCode)}`}  
              />  
            )  
          })}  
  
          {/* 커스텀 툴팁 */}  
          {customTooltip.visible && customTooltip.data && (  
            <div  
              className="pointer-events-none fixed z-50"  
              style={{  
                left: customTooltip.x,  
                top: customTooltip.y,  
                transform: customTooltip.transform || 'translateX(-50%) translateY(-100%)',  
              }}  
            >  
              {/* 메인 툴팁 컨테이너 */}  
              <div className="w-[190px] max-w-[200px] overflow-hidden rounded-lg border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800">  
                {/* 헤더 섹션 */}  
                <div className="border-b border-gray-100 px-3 py-2 dark:border-gray-700">  
                  <div className="flex items-center justify-between gap-2">  
                    <h4 className="truncate text-xs font-semibold text-gray-900 dark:text-gray-100">시그널 포인트</h4>  
                    <div className={'flex items-center gap-0.5'}>  
                      <Badge                        className={`flex-shrink-0 px-1.5 py-0.5 text-[11px] font-medium ${  
                          customTooltip.data.type === 'buy'  
                            ? 'bg-red-200 text-red-800 dark:bg-red-800 dark:text-red-200'  
                            : 'bg-blue-200 text-blue-800 dark:bg-blue-800 dark:text-blue-200'  
                        } hover:bg-opacity-80`}  
                      >  
                        {customTooltip.data.type === 'buy' ? '매수' : '매도'}  
                      </Badge>  
                      <Badge                        variant="outline"  
                        className={cn(  
                          'px-1.5 py-0.5 text-[11px]',  
                          customTooltip.data.tradingStyle === '단기'  
                            ? 'border-orange-500 text-orange-500'  
                            : customTooltip.data.tradingStyle === '중기'  
                              ? 'border-cyan-500 text-cyan-600'  
                              : 'border-purple-600 text-purple-600',  
                        )}  
                      >  
                        {customTooltip.data.tradingStyle}  
                      </Badge>  
                    </div>                  </div>                </div>  
                {/* 상세 정보 섹션 */}  
                <div className="space-y-1.5 px-3 py-2">  
                  <div className="space-y-1">  
                    {/*시간*/}  
                    <div className="flex items-start justify-between gap-2">  
                      <span className="flex-shrink-0 text-[11px] text-gray-600 dark:text-gray-400">시간</span>  
                      <span className="text-right text-[11px] font-medium break-all text-gray-900 dark:text-gray-100">  
                        {customTooltip.data.date}  
                      </span>  
                    </div>  
                    {/*전략명*/}  
                    <div className="flex items-start justify-between gap-2">  
                      <span className="flex-shrink-0 text-[11px] text-gray-600 dark:text-gray-400">전략명</span>  
                      <span className="text-right text-[11px] font-medium break-all text-gray-900 dark:text-gray-100">  
                        {customTooltip.data.strategy}  
                      </span>  
                    </div>  
                    {/*거래금액*/}  
                    <div className="flex items-start justify-between gap-2">  
                      <span className="flex-shrink-0 text-[11px] text-gray-600 dark:text-gray-400">거래금액</span>  
                      <span className="text-right text-[11px] font-medium break-all text-gray-900 dark:text-gray-100">  
                        {formatPrice(customTooltip.data.price, customTooltip.data.currencyCode)}  
                      </span>  
                    </div>  
                    {/*최고가/최저가*/}  
                    <div className="flex items-center justify-between gap-2">  
                      <span className="text-[11px] text-gray-600 dark:text-gray-400">  
                        {customTooltip.data.type === 'buy' ? '최고가' : '최저가'}  
                      </span>  
  
                      <div className="flex flex-col items-end text-right">  
                        {customTooltip.data.type === 'buy' && (  
                          <>  
                            {customTooltip.data.highPrice != -1 ? (  
                              <>  
                                <div className="flex items-center gap-1">  
                                  <TrendingUp className="h-2.5 w-2.5 text-red-500" />  
                                  <span className="text-[11px] font-medium text-red-600 dark:text-red-400">  
                                    {formatPrice(customTooltip.data.highPrice, customTooltip.data.currencyCode)}  
                                  </span>  
                                </div>                                <span className="text-[11px] text-red-500 dark:text-red-300">  
                                  (  
                                  {Math.abs(  
                                    calculatePercentage(customTooltip.data.highPrice, customTooltip.data.price),  
                                  )}  
                                  %)  
                                </span>  
                              </>                            ) : (  
                              <span className="text-[11px] text-red-600">최고가 정보없음</span>  
                            )}  
                          </>  
                        )}  
  
                        {customTooltip.data.type !== 'buy' && (  
                          <>  
                            {customTooltip.data.lowPrice != -1 ? (  
                              <>  
                                <div className="flex items-center gap-1">  
                                  <TrendingDown className="h-2.5 w-2.5 text-blue-700 dark:text-blue-300" />  
                                  <span className="text-[11px] font-medium text-blue-700 dark:text-blue-300">  
                                    {formatPrice(customTooltip.data.lowPrice, customTooltip.data.currencyCode)}  
                                  </span>  
                                </div>                                <span className="text-[11px] text-blue-600 dark:text-blue-200">  
                                  (  
                                  {Math.abs(calculatePercentage(customTooltip.data.lowPrice, customTooltip.data.price))}  
                                  %)  
                                </span>  
                              </>                            ) : (  
                              <span className="text-[11px] text-blue-700 dark:text-blue-300">최저가 정보없음</span>  
                            )}  
                          </>  
                        )}  
                      </div>  
                    </div>  
                    {/*최고가/최저가 갱신일*/}  
                    <div className="flex items-center justify-between gap-2">  
                      <span className="text-[11px] text-gray-600 dark:text-gray-400">  
                        {customTooltip.data.type === 'buy' ? '최고가 갱신일' : '최저가 갱신일'}  
                      </span>  
  
                      <div className={'flex flex-col'}>  
                        {customTooltip.data.type === 'buy' && (  
                          <>  
                            {customTooltip.data.highPrice != -1 ? (  
                              <span className="flex items-center text-[11px] text-red-600 dark:text-red-400">  
                                {moment(customTooltip.data.highPriceTime).format('YY/MM/DD HH:mm')}  
                              </span>  
                            ) : (  
                              <span className={'text-[11px] text-red-600'}>최고가 정보없음</span>  
                            )}  
                          </>  
                        )}  
  
                        {customTooltip.data.type !== 'buy' && (  
                          <>  
                            {customTooltip.data.lowPrice != -1 ? (  
                              <span className="flex items-center text-[11px] text-blue-700 dark:text-blue-300">  
                                {moment(customTooltip.data.lowPriceTime).format('YY/MM/DD HH:mm')}  
                              </span>  
                            ) : (  
                              <span className={'text-[11px] text-blue-700 dark:text-blue-300'}>최저가 정보없음</span>  
                            )}  
                          </>  
                        )}  
                      </div>  
                    </div>                  </div>                </div>              </div>  
              {/* 툴팁 화살표 */}  
              {customTooltip.transform?.includes('translateY(-100%)') ? (  
                <div className="absolute top-full left-1/2 h-0 w-0 -translate-x-1/2 transform border-t-[6px] border-r-[6px] border-l-[6px] border-transparent border-t-gray-200 dark:border-t-gray-700" />  
              ) : (  
                <div className="absolute bottom-full left-1/2 h-0 w-0 -translate-x-1/2 transform border-r-[6px] border-b-[6px] border-l-[6px] border-transparent border-b-gray-200 dark:border-b-gray-700" />  
              )}  
            </div>  
          )}  
        </div>  
      </div>    </div>  )  
}
```