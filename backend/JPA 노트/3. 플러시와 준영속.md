
#### 1. 플러시

- 간단히 말해, **영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것**이다.

###### ※ 플러시 발생
- 데이터베이스 트랜잭션이 커밋될 때
- 수정된 엔티티에 대한 쓰기 지연 SQL 저장소에 등록될 때 (변경감지)
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송할 때 (쓰기지연)

###### ※ 플러시 호출
- `em.flush`: 직접 호출하여, 즉시 쿼리를 DB에 반영
- 트랜잭션 커밋, JPQL 쿼리 실행: 플러스가 자동으로 호출됨


#### 2. JPQL 쿼리 실행과 플러시

- JPQL 쿼리 실행 시, 플러시는 자동으로 호출된다.
```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

// 중간에 JPQL 실행
// em.persist() 후에는 데이터베이스에 아직 반영되지 않았다.
// 근데, 여기서는 바로 select로 Member 테이블에서 데이터를 가져오려고 한다.
// 따라서 JPQL를 실행할 때, 앞선 변경사항을 DB에 반영해야 원하는 동작이 발생하기 때문에, 자동으로 DB에 변경사항을 반영하도록 플러시를 호출한다.
query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

- 플러시 모드 옵션이라는 것도 있다.
![[플러시 모드 옵션.png]]

#### 3. 플러시 정리

- **영속성 컨텍스트를 비우지 않는다.**
	- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화할 뿐이다. (이게 플러시임)

- 트랜잭션이라는 작업 단위가 중요한데, 커밋 직전에만 변경내용을 동기화하면 된다.
	- 플러시라는 매커니즘이 동작 가능한 이유는 **트랜잭션이라는 작업 단위가 있기 때문**이다.


#### 4. 준영속 상태

- 영속 상태에 올라가있다는 건 `persist()`메소드를 사용하여, 영속 컨텍스트 내에 엔티티를 집어넣는 것만을 의미하는 것이 아니다.
	- 1차 캐시에 존재하지 않는 엔티티를 `find()`메소드를 사용하여 조회하려 할 때, DB에서 데이터를 가져오고 1차 캐시에 데이터를 올려준다고 언급했다.
	- 이렇게 1차 캐시에 등록된 엔티티들도 영속 상태에 올라갔다고 말할 수 있다.

- 영속 상태에서 준영속 상태로 전환될 수 있다.
	- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태를 의미한다.

- 영속성 컨텍스트에서 분리되었기 때문에, 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

###### ※ 준영속 상태로 만드는 방법
- `em.detach(entity)` : 특정 엔티티만 준영속 상태로 전환
- `em.clear()`: 영속성 컨텍스트를 완전히 초기화
- `em.close()`: 영속성 컨텍스트를 종료