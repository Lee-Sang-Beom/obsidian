
#### 1. JPA의 정의

- JPA(Java Persistence API)는, Java 언어를 사용하여 관계형 데이터베이스를 다루는 데 사용되는 자바 표준 ORM(Object-Relational Mapping) 기술이다.
	- ORM은 객체 지향 프로그래밍 언어에서, 객체와 관계형 데이터베이스의 테이블 간의 매핑을 자동화하는 기술을 의미한다. 
	- 개발자는 객체 지향적인 방식으로 데이터를 다루고, ORM 프레임워크가 이를 관계형 데이터베이스에 맞게 변환하여 데이터베이스와의 상호작용을 수행할 수 있다.

- JPA는 이러한 ORM 기술을 자바에서 사용할 수 있도록 표준화한 API이다.
	- JPA를 사용하면 **개발자는 데이터베이스와의 상호작용을 위해 SQL 쿼리를 직접 작성하는 대신, 객체를 사용하여 데이터를 조회, 저장, 수정 및 삭제**할 수 있다.
	- 즉, SQL과 데이터 중심 설계에서, 객체 중심의 설계로 패러다임을 전환할 수 있도록 한다.
	- 이는 개발 생산성을 향상시키고, 코드의 가독성을 높이며, 데이터베이스에 대한 의존성을 줄이는 데 도움이 된다.

- JPA는 주로 Java EE(Enterprise Edition) 및 Java SE(Standard Edition) 애플리케이션에서 사용되며, 대표적인 JPA 구현체로는 Hibernate, EclipseLink, OpenJPA 등이 있다.
	- 이러한 JPA 구현체들은 JPA 표준을 구현하면서 각각의 특징과 성능을 제공한다.


#### 2. JPA 환경 설정하기

- `build.gradle` 파일에 JPA 관련 라이브러리 추가
```gradle
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    // implementation 'org.springframework.boot:spring-boot-starter-jdbc'  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    runtimeOnly 'com.h2database:h2'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
}
```

- 스프링 부트(`resources/application.properties`)에 JPA 설정 추가
	- `show-sql`: JPA가 생성하는 SQL 출력
	- `ddl-auto`: JPA는 테이블을 자동으로 생성하는 기능을 제공하는데, `none` 사용 시 해당 기능을 끈다.
		- `create` 사용 시, Entity 정보 기반으로, 테이블을 직접 생성한다.
```null
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.driver-class-name=org.h2.Driver  
spring.datasource.username=sa  

# 추가
spring.jpa.show-sql=true  
spring.jpa.hibernate.ddl-auto=none
```


#### 3. Entity Mapping

> [!note] Entity
> - Entity(엔티티)는 객체 지향 프로그래밍에서 식별 가능한 개별적인 객체를 나타낸다.
> 	- 이는, 데이터베이스에서 테이블로 표현되는 개체에 대응하는 개념이다.
> 	- Entity(엔티티)는 비즈니스 도메인에서 중요한 개념을 나타내며, **Attribute**과 **Method**를 가질 수 있다. 
> - 본 예제에서는, Member이라는 Entity(엔티티)는 회원의 정보를 표현한다. 
> 	- 이 회원 Entity(엔티티)는 id, name 등의 속성을 가지며, 회원가입 등의 동작을 수행할 수 있다.
> 	- 엔티티는 애플리케이션에서 데이터를 표현하고 조작하는 데 사용된다.

- JPA를 쓰려면, 이 **Entity**라는 것을 매핑해야 한다.
	- JPA는 이러한 ORM 기술을 자바에서 사용할 수 있도록 표준화한 API이라고 했다. ORM은 Object Relational Mapping의 줄임말이다.
	- **OOP(Object Oriented Programming)에서 쓰는 객체라는 개념을 구현한 클래스**와  **RDB(Relational DataBase)에서 쓰이는 데이터인 테이블을 매핑(연결)** 하는 작업을 필요로 한다.

```java
package hello.hellospring.domain;  
  
import jakarta.persistence.Entity;  
import jakarta.persistence.GeneratedValue;  
import jakarta.persistence.GenerationType;  
import jakarta.persistence.Id;  
  
// @Entity annotation을 붙이면, JPA가 관리하는 Entity가 된다.  
// 근데,이걸 붙이면 PK(Primary key)가 관리되어야 한다.  
@Entity  
public class Member {  
  
    // @Id: Primary Key 지정  
    // @GeneratedValue: 현재 DB에서 id는 자동 생성된다. id를 자동으로 생성해주는 것을 identity 전략이라 부른다.  
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
    private String name;  
  
    public Long getId() {  
        // id값 전달 (getter)        return id;  
    }  
  
    public void setId(Long id) {  
        // id값 세팅 (setter)        this.id = id;  
    }  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
}
```

- 이제 Mapping을 해보자. 살펴볼 것은 크게 3가지이다.
	1. `@Entity`:  이 annotation은 해당 클래스가 JPA Entity임을 표시한다. 즉, 데이터베이스의 테이블과 매핑되는 클래스이다.
	2. `@Id`: 이 annotation은 해당 필드가 Entity의 기본 키(primary key)임을 나타낸다. 여기서는 `id` 필드가 기본 키로 사용된다.
	3. `@GeneratedValue`: 이 annotation은 기본 키 값이 자동으로 생성되는 방식을 지정한다.
		- 여기서는 데이터베이스가 기본 키를 자동으로 생성하도록 지정되었다.
		- `id`는 아래 DDL문에 의해 자동 생성된 것을 기억할 것이다. (아마)
```sql
create table member (
id bigint generated by default as identity,
name varchar(255),
primary key (id)
);
```


#### 4. JpaMemberRepository 생성

```java
package hello.hellospring.repository;  
  
  
import hello.hellospring.domain.Member;  
import jakarta.persistence.EntityManager;  
  
import java.util.List;  
import java.util.Optional;  
public class JpaMemberRepository implements MemberRepository {
	// jpa는 entitymanager라는 걸 이용해서, 모든 게 동작
	// `build.gradle`파일의 `dependencies`에 JPA implementation을 등록해주면 스프링부트가 자동으로 EntityManager를 생성해준다. (DB와 통신하는 거 얘 내부에서 알아서 처리함)
    private final EntityManager em;  
  
    public JpaMemberRepository(EntityManager em) {  
        this.em = em;  
    }  
  
    public Member save(Member member) {  
	    // persist: 영속화 / 영구저장하다
	    // jpa가 INSERT 쿼리 만들어서, DB에 알아서 저장 (setId까지 해줌)
        em.persist(member);  
        return member;  
    }  
  
    public Optional<Member> findById(Long id) {  
	    // em.find() 메소드 사용: 조회할 type과 식별자 id로 조회
	    // return 시, 값이 없을수도 있으므로, optional로 반환
        Member member = em.find(Member.class, id);  
        return Optional.ofNullable(member);  
    }  
  
    public List<Member> findAll() {  
	    // 특별한 JPQL이라는 객체지향 쿼리언어를 써야함
	    // select m from Member as m
        return em.createQuery("select m from Member m", Member.class).getResultList();  
    }  
  
    public Optional<Member> findByName(String name) {  
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class).setParameter("name", name).getResultList();  
        return result.stream().findAny();  
    }  
}
```

- 여기서는, JPA(Java Persistence API)를 사용하여 회원(Member) Entity를 데이터베이스와 상호 작용하는 Repository 클래스를 정의하고 있다.
	- 이 Repository는 Member Entity의 CRUD(Create, Read, Update, Delete) 작업을 수행한다.

- 여기서 사용된 기능과 메소드들은 아래와 같다.
	-  **EntityManager**
		- JPA에서 Entity를 관리하고 데이터베이스와의 상호 작용을 처리하는 인터페이스이다.
		- JPA는 EntityManager라는 것으로 모든 게 동작한다.
		- `build.gradle`파일의 `dependencies`에 JPA implementation을 등록해주면 스프링부트가 자동으로 EntityManager를 생성해준다. (DB와 통신하는 거 얘 내부에서 알아서 처리함)
    
	- **save(Member member)**
		- `persist()` 메소드를 사용하여 영속성 컨텍스트에 Entity를 추가하고 데이터베이스에 반영한다.
    
	- **findById(Long id)**
		- 데이터베이스에서 해당 Entity를 직접 조회하여 반환한다.
    
	- **findAll()**
		- 데이터베이스에 있는 모든 Member Entity를 조회하여 리스트로 반환한다.
		- JPQL(Java Persistence Query Language)을 사용하여 데이터베이스 쿼리를 작성하여 모든 Member를 검색한다.
    
	- **findByName(String name)**
		- JPQL을 사용하여 이름으로 Member를 검색한다.

- JPA 제공 기능에 대해 다시 알아보자
	1. **객체-관계 매핑(Object-Relational Mapping, ORM)**
		- JPA는 자바 객체와 데이터베이스 테이블 간의 매핑을 처리하여 객체 지향 프로그래밍 언어인 자바와 관계형 데이터베이스 간의 데이터 변환을 자동화한다.
	    
	2. **영속성 컨텍스트(Persistence Context)**
		- JPA는 영속성 컨텍스트를 통해 Entity 객체의 상태를 관리하고, 데이터베이스와의 상호 작용을 추상화한다.
		- 이를 통해 Entity의 생명 주기를 관리하고, 변경을 추적하여 데이터베이스에 자동으로 반영할 수 있다.
	    
	3. **JPQL(Java Persistence Query Language)**
		- JPA는 객체 지향적인 쿼리 언어인 JPQL을 제공하여 데이터베이스에 대한 쿼리를 수행할 수 있다.
		- 이를 통해 데이터베이스에 대한 복잡한 쿼리를 객체 지향적으로 작성할 수 있다.


#### 5. JPQL 쿼리 1. findAll()

- JPQL 쿼리에 대해 알아보기 위해, 아래 코드를 살펴보자.
```java
 public List<Member> findAll() {  
	// createQuery 1번째 인자: Query
	// createQuery 2번째 인자: 반환 타입 (Member)
	return em.createQuery("select m from Member m", Member.class).getResultList(); 
}  
```

- `em.createQuery("select m from Member m", Member.class)` 부분은 JPQL(Java Persistence Query Language)을 사용하여 데이터베이스에 쿼리를 보내고, 이를 통해 Member Entity의 모든 레코드를 가져오는 쿼리를 생성한다.
	- 여기서 `m`은 Member Entity를 가리키는 별칭(alias)이다.
	- `getResultList()` 메서드는 이 쿼리를 실행하고, 결과를 `List<Member>` 형태로 반환한다.

- JPQL에서는 SQL과는 달리 `SELECT *`를 사용하지 않는다. 
	- 대신에 엔티티와 속성을 기반으로 쿼리를 작성한다.
	- JPQL에서는 Entity의 속성을 명시적으로 지정하여 가져올 수 있다.
	- 이는 객체지향 프로그래밍의 관점을 유지하면서 필요한 데이터만을 가져올 수 있게 한다.

- 따라서 `select * from Member` 대신에 `select m from Member m`과 같이 사용한 것이다.
	- 여기서 `m`은 Member Entity를 가리키는 변수이다.


#### 6. JPQL 쿼리 2. findByName()

- 이번에는, `findByName()` 메소드에 대해 알아보자.
```java
public Optional<Member> findByName(String name) {  
    List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class).setParameter("name", name).getResultList();  
    return result.stream().findAny();  
}
```

- 이 코드는, `name`으로  `Member` Entity를 조회하는 메소드이다.

- `em.createQuery("select m from Member m where m.name = :name", Member.class)` 부분은 JPQL을 사용하여 데이터베이스에 쿼리를 보내고, 이를 통해 주어진 이름과 일치하는 Member Entiry를 가져오는 쿼리를 생성하는 부분이다.
	- 여기서 `:name`은 JPQL의 파라미터(named parameter)로, 나중에 설정될 값이다. 
	- `m"` Member Entity를 가리키는 별칭이다.

-  `.setParameter("name", name)` 부분은 파라미터 `:name`에 값을 설정하는 부분이다.
	- 이 값을 통해 JPQL 쿼리가 실행될 때 실제로 주어진 이름과 일치하는 레코드를 찾는다.
	-  `getResultList()` 메소드는 이 쿼리를 실행하고, 결과를 `List<Member>` 형태로 반환한다.

- `result.stream().findAny()` 부분은 조회된 결과 리스트를 스트림으로 변환한 뒤, 그 중 임의의 요소를 반환하는 코드이다.
	- 이때 `Optional<Member>`로 반환되는데, 이는 조회된 결과가 있을 수도 있고 없을 수도 있기 때문이다. 
	- 따라서 이 메소드를 호출한 곳에서는 결과가 존재하는지 여부를 확인하고 처리할 수 있다.


#### 7. Transcational

- 데이터 저장 및 수정 시, 항상 `@Transcational` annotation이 필요하다.
- 본 예제에서는, 데이터 저장 및 수정이 서비스 측 메소드에서 발생하므로 서비스 측에 걸어주면 된다.
	- `@Transcational` annotation을 걸어주면, 스프링은 해당 클래스의 메소드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 **Commit**한다
	- 만약 런타임 예외가 발생하면 롤백한다.

- **JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다는 것을 명심하자

```java
package hello.hellospring.service;  
  
import hello.hellospring.domain.Member;  
import hello.hellospring.repository.MemberRepository;  
import hello.hellospring.repository.MemoryMemberRepository;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
import org.springframework.transaction.annotation.Transactional;  
  
import java.util.List;  
import java.util.Optional;  
  


@Transactional  
public class MemberService {  
    private final MemberRepository memberRepository;  
  
    // @Autowired  
    public MemberService(MemberRepository memberRepository){  
        this.memberRepository = memberRepository;  
    }  
    public Long join(Member member) {  
        validateDuplicatedMember(member); // 중복회원 검증  
        memberRepository.save(member);  
        return member.getId();  
    }  
  
    /**  
     * 전체회원 조회  
     */  
    public List<Member> findMembers(){  
        return memberRepository.findAll();  
    }  
  
    public Optional<Member> findOne(Long memberId){  
        return memberRepository.findById(memberId);  
    }  
  
    /**  
     * 아이디에 해당하는 유저 반환  
     */  
    public Optional<Member> findMember(Long memberId){  
        return memberRepository.findById(memberId);  
    }  
  
    /**  
     * 같은 이름의 중복 회원이 있는지 먼저 검사  
     */  
    private void validateDuplicatedMember(Member member) {  
        memberRepository.findByName(member.getName()).ifPresent(m -> {  
            throw new IllegalStateException("이미 존재하는 회원입니다.");  
        });  
    }  
  
}
```

#### 8. 테스트를 위한 `SpringConfig.java` 변경

```java
package hello.hellospring;  
  
import hello.hellospring.repository.*;  
import hello.hellospring.service.MemberService;  
import jakarta.persistence.EntityManager;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
import javax.sql.DataSource;  
  
// 스프링이 실행될 때, Configuration을 먼저 읽고, config 내부의 @Bean annotation으로 설정된 요소를 스프링이 스프링 컨테이너에 스프링 빈으로 등록한다.  
@Configuration  
public class SpringConfig {  
    private EntityManager em;  
	public SpringConfig(EntityManager em){  
		this.em = em;  
	}  
    @Bean
    public MemberService memberService(){  
        return new MemberService(memberRepository());  
    }  
    @Bean  
    public MemberRepository memberRepository(){  
        return new JpaMemberRepository(em);
    }  
}
```

![[테스트 결과.png]]