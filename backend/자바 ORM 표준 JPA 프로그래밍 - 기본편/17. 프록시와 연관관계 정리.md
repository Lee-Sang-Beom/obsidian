
#### 1. Overview

- Member를 조회할 때, Team도 함께 조회하여야 하는가에 대한 상황을 생각해보자.
	- 아래는 비즈니스 로직 중 하나의 예제라고 가정하자.
![[member조회 시, team도 함께 조회.png]]
```java
public void printUserAndTeam(String memberId){
	Member member = em.find(Member.class, memberId);
	Team team = member.getTeam();

	System.out.println("소속팀 : " + team.getName())

	// 굳이 Team에 접근하여 사용하지 않는경우, 연관관계가 걸려있다고 하여, Team까지 굳이 땡겨와 가져와버리면 손해임 (최적화가 아닌거임)
	System.out.println("회원 이름: " + member.getUsername());

}
```

- JPA에서는 이러한 상황을 극복하기 위해, **프록시**와 **지연 로딩**이라는 기법을 사용한다.


#### 2. 프록시

- JPA에서는, `em.find()`말고, `em.getReference()`라는 메소드도 있다.
	- `em.find()` : 데이터베이스를 통하여 실제 엔티티 객체를 조회하는 메소드
	- `em.getReference()` : 데이터베이스 조회를 미루는 가짜 엔티티객체 조회 (DB 쿼리가 안나가는데, 객체를 조회함)

![[entityManger.getReference 메소드.png]]

```java
public void printUserAndTeam(String memberId){
	// 쿼리발생 o
	Member findMember = em.find(Member.class, memberId);
}
```
- 위 코드에서, `em.find()`로 테이블을 조회할 때는, 쿼리를 날려 연관관계가 걸려있는 테이블과 Join하여 미리 데이터를 가져온다.

```java
public void printUserAndTeam(String memberId){
	// 쿼리발생 x
	Member findMember = em.find(Member.class, memberId);
}
```
- 반면, `em.getReference()`로 테이블을 조회할 때는 쿼리를 날리지 않는다.

```java
public void printUserAndTeam(String memberId){\
	// 쿼리발생 x
	Member findMember = em.find(Member.class, memberId);

	// 추가 : 이 때, 쿼리발생 o
	System.out.pringln("findMember.id is " + findMember.getId())
}
```
- 또, 위와 같이 `findMember`의 값을 **실제 사용하는 시점**에서는 데이터베이스 쿼리가 발생한다.
