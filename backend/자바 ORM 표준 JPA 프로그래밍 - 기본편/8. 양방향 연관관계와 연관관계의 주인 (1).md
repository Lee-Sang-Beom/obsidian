
#### 1. 양방향 매핑

![[양방향 매핑 연관관계.png]]
- 다음과 같은 연관관계를 구현해야 한다고 하자.
	- 기존에는 `member.getTeam()`과 같이, member 객체에서 team 정보를 구할 수 있었다.
	- 하지만 `team.getMember()`는 불가능하다.

- 이를 가능하도록 하기 위해서는 **양방향 연관관계**라는 것을 만들어주어야 한다.
	- 위 이미지에서, **[테이블 연관관계]** 는 하나도 바뀌는 게 없다.
	- 하지만, **[양방향 객체 연관관계]** 측에서, Team 객체에 `List members`가 추가되었다.
		- Team에서 Member에 접근할 수 있도록 한 것이다.

###### ※ 양방향 매핑 (Member 엔티티는 단방향과 동일)
```java
@Entity
public class Member{
	@Id @GeneratedValue
	private Long id;

	@Column(name="USERNAME")
	private String name;
	private int age;

	@ManyToOne
	@JoinColumn(name="TEAM_ID")
	private Team team;

	// ...
}
```

###### ※ 양방향 매핑 (Team 엔티티는 컬렉션 추가)
```java
@Entity
public class Member{
	@Id @GeneratedValue
	private Long id;
	private String name;

	@OneToMany(mappedBy = "team")
	List<Member> members = new ArrayList<Member>();

	// ...
}
```
- Member와 Team의 관계를 생각해보면, Team이 여러 Member를 가질 수 있기 때문에, Member와 Team은 다대일 관계였다.
	- 그래서, Team을 기준으로 보았을 때는 Team과 Member는 일대다 관계이다.
	- 따라서, `@OneToMany`라는 annotation을 붙여주어야 한다.

- `mappedBy`는 일대다 매핑 관계에서, 나는 Member의 어떤 객체속성과 연결되어있냐를 의미한다.
	- 여기서는, Member 객체의 `private Team team`과 연결되어야하므로, `team`으로 전달했다.

###### ※  양방향 매핑 (반대방향으로 객체 그래프 탐색)
```java
// 조회
Team findTeam = em.find(Team.class, team.getId());
int memberSize = findTeam.getMembers().size();


// 이런거도 된다.
Member findMember = em.find(Member.class, member.getId());
List<Member> members = findMember.getTeam().getMembers();
```

###### ※ 연관관계의 주인과 mappedBy
- mappedBy : JPA의 멘탈붕괴 난이도
	- 객체와 테이블 간에 연관관계를 맺는 차이를 이해하여야 한다.


#### 2. 객체와 테이블이 관계를 맺는 차이

###### ※ Overview

![[양방향 매핑 연관관계.png]]

- 객체 연관관계 = 2개
	- **객체는 연관관계가 되는 중요한 key 포인트가 2개이다.**
		- 단방향 연관관계가 2개 합쳐져서, 양방향 연관관계가 만들어지게 되는 것이, 객체 연관관계의 key 포인트이다.
		- Member 객체에서 Team 객체에 접근하기 위해서는 참조값을 넣어놔야 하고, 반대 방향의 경우에도 참조값을 넣어놓아야 한다는 뜻이다.

	- 회원 -> 팀 연관관계 1개 (단방향)
		- Member 객체에서는, `Team team` 속성을 이용

	- 팀 -> 회원 연관관계 1개 (단방향)
		- Team 객체에서는, `List members` 속성을 이용

 - 테이블 연관관계 = 1개
	 - 테이블에서는 Member 테이블의 외래키(FK) 하나면 연관관계의 정리가 끝난다.
	 - 회원 <-> 팀의 연관관계 1개 (양방향)

###### ※ 객체의 양방향 관계 
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단뱡향 관계가 2개 합쳐진 것이다. 
- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.
![[객체의 양방향 관계.png]]

###### ※ 객체의 양방향 관계 
- 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다.
	- 본 예제에서는, MEMBER.TEAM_ID이라는 외래 키 하나로 양방향 연관관계를 가진다.
		- 이는 양쪽으로 조인할 수 있도록 한다.
![[테이블의 양방향 관계.png]]
###### ※ 주의
- 지금 현재, 객체에서는 Member 객체에 Team에 대한 참조 1개, Team 객체에서 Member에 대한 참조 1개가 존재한다. (총 2개)
	- 여기서 문제가 발생하는데, 그것이 `외래키 값을 무엇을 기준으로 업데이트하는가?` 이다.
		- Member 객체의 `Team team` 값이 바뀌었을 때, MEMBER.TEAM_ID 값을 바꿔야 하나?
		- Team 객체의 `List members` 값이 바뀌었을 때,MEMBER.TEAM_ID 값을 바꿔야 하나?

	- DB 입장에서는 MEMBER.TEAM_ID (외래키) 값만 어떻게든 업데이트 하면 된다.

![[둘 중 하나로 외래키를 관리해야 한다..png]]
- 그래서 등장한 Rule이 **둘 중 하나로 외래키를 관리하는 것**이다.
	1. Member의 `Team team`으로 외래키를 관리하는 방법
	2. Team의 `List members`로 외래키를 관리하는 방법

- 그래서 ***연관관계의 주인*** 이라는 것이 필요하다.


#### 3. 연관관계의 주인(Owner)

###### ※ 양방향 매핑 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
- 주인이 아닌쪽은 읽기만 가능
- 주인은 `mappedBy` 속성 사용X
- 주인이 아니면 `mappedBy` 속성으로 주인 지정
###### ※ 누구를 주인으로?
- 외래키가 있는 곳을 주인으로 정하자.
- 여기서는 Member.team이 연관관계의 주인으로 결정해야 한다.
![[연관관계의 주인.png]]

- 그래서 본 예제에서는 Team 객체의 `List member`에 `mappedBy`를 사용했다.
	- 주인이 아니면(Team 객체), `mappedBy`로 주인 지정
	- 주인은(Member 객체) `mappedBy` 사용 불가
	- 본 예제에서 연관관계의 주인은 아래와 같다.
```java

// Member class
@ManyToOne
@JoinColumn(name="TEAM_ID")
private Team team;
```

- **웬만하면, 관계에서, 외래키가 없는 곳이 1이며, 외래키가 있는 곳이 n이다.**
	- 이 말은 즉슨, 외래키가 있는 곳을 기준으로 할 때, 다대일 관계가 만들어진다는 것이다.
	- 본 예제에서도 **외래키가 위치한 Member 객체가 Team과 다대일 관계**이다.
		- Team은 여러 Member 객체를 가지기 때문
###### ※ 양방향 매핑 시 가장 많이 하는 실수
- 연관관계의 주인에 값을 입력하지 않음.
![[양방향 매핑 시 가장 많이하는 실수.png]]
- 위 코드의 문제는, 연관관계의 주인이 아닌 위치에 

- 여기서는, Member의 `team` 속성이 연관관계의 주인이다.
	- 반드시, 연관관계의 주인인 Member의 `team` 속성에 값을 넣어주어야 한다. 
![[양방향 매핑 시 연관관계의 주인에 값을 입력해야 한다..png]]


#### 4. 정리

###### ※ 양방향 연관관계 주의
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자
- 양방향 매핑 시, 무한 루프를 조심하자

###### ※ 양방향 연관관계 정리
- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추 가된 것 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블에 영향을 주지 않음)

###### ※ 양방향 연관관계 시, 연관관계의 주인을 정하는 기준
- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함

