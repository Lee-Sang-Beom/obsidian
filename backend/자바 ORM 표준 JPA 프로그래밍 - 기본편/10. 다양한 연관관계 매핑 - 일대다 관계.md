
#### 1. 일대다 [1:N]

###### ※ 일대다 단방향

![[일대다 단방향.png]]
- Team 엔티티에서는 `List members` 필드를 통해, Team에 속한 Member가 무엇인지만 알고싶고, **Member 엔티티에서는 Team을 알고 싶지 않은 경우**에 이렇게 설계가 가능하다.

- 하지만, DB 입장에서는 무조건 **다(n)** 쪽에 외래키가 들어가야 한다. 
	- Team에는 외래키가 들어갈 수 없다는 뜻이다.

- 따라서 **일대다 단방향 관계**에서는, 관계 중 "**일(1)**"에 위치하는 Team 엔티티의 `List members` 필드가 연관관계의 주인이 되며, 이것이 변경될 때마다 테이블 **MEMBER** 의 TEAM_ID(FK)를 변경시켜 주어야 한다.
	- 정리하면, 관계 중 **'일'** 에 위치하는 엔티티의 **연관 관계 주인 역할을 하는 필드가 변경되면**, 연관관계 매핑이 되어있는 테이블의 외래키를 변경해주어야 하는 것이다.


#### 2. 일대다 단방향 정리

- 일대다 단방향은 **일대다(1:N)에서 일(1)이 연관관계의 주인**이다.
	- 테이블 일대다 관계는 항상 **다(N)** 쪽에 외래키가 있다.

- **객체와 테이블의 차이 때문에, 반대편 테이블의 외래 키를 관리하는 특이한 구조**를 가진다.
	- `@JoinColumn`을 꼭 사용해야 한다.
	- 그렇지 않으면, **조인 테이블**이라는 방식을 사용해야 한다. (중간에 테이블을 하나 추가함)

###### ※ 일대다 단방향 매핑의 단점
- 엔티티가 관리하는 외래 키가 다른 테이블에 있다.
- 연관관계 관리를 위해, 추가로 UPDATE SQL 실행을 해야한다.
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자.

> `Member.java`
- Member는 관계 설정부분이 텅텅 비었다.
![[일대다 단방향 Member.java.png]]

> `Team.java`
- Team에서는 연관관계를 반대쪽에 있는 테이블인 MEMBER의 외래키와 연결해주어야 한다.
- `@OneToMany`를 사용하는 것은 기본이고, 일대다 관계에서는 `@JoinColumn`을 사용해야 한다.
	- `@JoinColumn(name="TEAM_ID")`에서, name은 테이블의 외래키로 지정된 컬럼명이다.
![[일대다 단방향 Team.java.png]]

```java
//...
EntityTransaction tx = em.getTranscation();
tx.begin();

try{
	Member member = new Member();
	member.setUsername("member1");
	em.persist(member);
	
	Team team = new Team();
	team.setName("teamA");
	
	team.getMembers().add(member);	
	em.persist(team);
	tx.commit();
} catch(Exception e) {
	//...
} finally {
	// ...
}
```
- 위의 코드에서, `team`은 저장이 된다.
	- `team.setName(...)`은 TEAM 테이블에 INSERT 되면 OK이다.
	- 하지만, `team.getMembers().add(...)`은 TEAM 테이블에 INSERT되는 내용이 아니다.
		- TEAM 엔티티에 손을 댔지만, `List members`와 연관관계 매핑된 MEMBER 테이블의 FK도 변경되어야 하기 때문에, MEMBER 테이블을 업데이트하는 쿼리가 추가된다.
		- 그래서 성능 상 단점이 존재한다고 한다.


#### 3. 일대다 양방향 정리

- 이런 매핑은 공식적으로 존재하지 않는다.
- `@JoinColumn(insertable=false, updatable=false)`
- 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법이다. 
	- 하지만, **다대일 양방향을 사용하자.**

![[일대다 양방향.png]]
- Team 엔티티의 `List members`가 연관 관계의 주인이다.
	- 만약, 반대쪽 엔티티(Member)에서 읽기 전용으로 확인하고자 하면 아래처럼 작성하면 된다.
		- name: 읽기 전용 매핑으로 연결할 외래 키(Foreign Key)의 이름을 지정
		- insertable=false, updateable=false: 매핑되어있고, 사용 가능하지만 최종적으로 insert, update를 하지 않도록 함 (**읽기 전용으로 한정 지음**)
			- 이는 양방향 매핑을 한 것과 동일해짐

> `Member.java`의 일부
```java
// ...
@ManyToOne
@JoinColumn(name="TEAM_ID",insertable=false, updateable=false)
privat Team team;
// ...
```